<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AzCore API Reference: AZ::OverrunDetectionSchema Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AzCore API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_overrun_detection_schema.html">OverrunDetectionSchema</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_z_1_1_overrun_detection_schema-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::OverrunDetectionSchema Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OverrunDetectionAllocator.h&gt;</code></p>

<p>Inherits <a class="el" href="class_a_z_1_1_i_allocator_allocate.html">AZ::IAllocatorAllocate</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_overrun_detection_schema_1_1_descriptor.html">Descriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_overrun_detection_schema_1_1_platform_allocator.html">PlatformAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction for low-level memory mapping functions provided by the OS.  <a href="class_a_z_1_1_overrun_detection_schema_1_1_platform_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4042ad0456410fc94eb57eb6022785d1"><td class="memItemLeft" align="right" valign="top"><a id="a4042ad0456410fc94eb57eb6022785d1"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer_type</b></td></tr>
<tr class="separator:a4042ad0456410fc94eb57eb6022785d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772432e044136c9903ed8bdbb6d25de"><td class="memItemLeft" align="right" valign="top"><a id="ab772432e044136c9903ed8bdbb6d25de"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:ab772432e044136c9903ed8bdbb6d25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc39f62e0a180796508b078a81ce25"><td class="memItemLeft" align="right" valign="top"><a id="a9ccc39f62e0a180796508b078a81ce25"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a9ccc39f62e0a180796508b078a81ce25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_a_z_1_1_i_allocator_allocate"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_a_z_1_1_i_allocator_allocate')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_a_z_1_1_i_allocator_allocate.html">AZ::IAllocatorAllocate</a></td></tr>
<tr class="memitem:a40fcca34269c77c167dfb79622a2c033 inherit pub_types_class_a_z_1_1_i_allocator_allocate"><td class="memItemLeft" align="right" valign="top"><a id="a40fcca34269c77c167dfb79622a2c033"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer_type</b></td></tr>
<tr class="separator:a40fcca34269c77c167dfb79622a2c033 inherit pub_types_class_a_z_1_1_i_allocator_allocate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3f04d25199d62d2c41fd442bb72d27 inherit pub_types_class_a_z_1_1_i_allocator_allocate"><td class="memItemLeft" align="right" valign="top"><a id="a1a3f04d25199d62d2c41fd442bb72d27"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a1a3f04d25199d62d2c41fd442bb72d27 inherit pub_types_class_a_z_1_1_i_allocator_allocate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbdb0e1097f4093272a594750da3892 inherit pub_types_class_a_z_1_1_i_allocator_allocate"><td class="memItemLeft" align="right" valign="top"><a id="a8dbdb0e1097f4093272a594750da3892"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a8dbdb0e1097f4093272a594750da3892 inherit pub_types_class_a_z_1_1_i_allocator_allocate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aec9238230421ed4fa118b7bed4862910"><td class="memItemLeft" align="right" valign="top"><a id="aec9238230421ed4fa118b7bed4862910"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_TYPE_INFO</b> (&quot;OverrunDetectionSchema&quot;, &quot;{0DF781AC-1615-40AE-81F7-6CA5841E2914}&quot;)</td></tr>
<tr class="separator:aec9238230421ed4fa118b7bed4862910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1a637859181a6db6f310c7465e2cce"><td class="memItemLeft" align="right" valign="top"><a id="aec1a637859181a6db6f310c7465e2cce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OverrunDetectionSchema</b> (const <a class="el" href="struct_a_z_1_1_overrun_detection_schema_1_1_descriptor.html">Descriptor</a> &amp;desc=<a class="el" href="struct_a_z_1_1_overrun_detection_schema_1_1_descriptor.html">Descriptor</a>())</td></tr>
<tr class="separator:aec1a637859181a6db6f310c7465e2cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252e1c20c3dc470a11d5589d3fa852f5"><td class="memItemLeft" align="right" valign="top"><a id="a252e1c20c3dc470a11d5589d3fa852f5"></a>
virtual pointer_type&#160;</td><td class="memItemRight" valign="bottom"><b>Allocate</b> (size_type byteSize, size_type alignment, int flags, const char *name=0, const char *fileName=0, int lineNum=0, unsigned int suppressStackRecord=0) override</td></tr>
<tr class="separator:a252e1c20c3dc470a11d5589d3fa852f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c2a2d581d7f013084034809987c3c6"><td class="memItemLeft" align="right" valign="top"><a id="a67c2a2d581d7f013084034809987c3c6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>DeAllocate</b> (pointer_type ptr, size_type byteSize=0, size_type alignment=0) override</td></tr>
<tr class="separator:a67c2a2d581d7f013084034809987c3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78053752d009d07a81d2f929ba2ea38e"><td class="memItemLeft" align="right" valign="top"><a id="a78053752d009d07a81d2f929ba2ea38e"></a>
virtual pointer_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_overrun_detection_schema.html#a78053752d009d07a81d2f929ba2ea38e">ReAllocate</a> (pointer_type ptr, size_type newSize, size_type newAlignment) override</td></tr>
<tr class="memdesc:a78053752d009d07a81d2f929ba2ea38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realloc an allocate memory memory block. Similar to Resize except it will move the memory block if needed. Return NULL if realloc is not supported or run out of memory. <br /></td></tr>
<tr class="separator:a78053752d009d07a81d2f929ba2ea38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a96c1ee3dcd592bd808b61f0a44f10f"><td class="memItemLeft" align="right" valign="top"><a id="a4a96c1ee3dcd592bd808b61f0a44f10f"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_overrun_detection_schema.html#a4a96c1ee3dcd592bd808b61f0a44f10f">Resize</a> (pointer_type ptr, size_type newSize) override</td></tr>
<tr class="memdesc:a4a96c1ee3dcd592bd808b61f0a44f10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an allocated memory block. Returns the new adjusted size (as close as possible or equal to the requested one) or 0 (if you don't support resize at all). <br /></td></tr>
<tr class="separator:a4a96c1ee3dcd592bd808b61f0a44f10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cbeb52a93f33a6a04ea29f38e3aab4"><td class="memItemLeft" align="right" valign="top"><a id="a42cbeb52a93f33a6a04ea29f38e3aab4"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_overrun_detection_schema.html#a42cbeb52a93f33a6a04ea29f38e3aab4">AllocationSize</a> (pointer_type ptr) override</td></tr>
<tr class="memdesc:a42cbeb52a93f33a6a04ea29f38e3aab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns allocation size for given address. 0 if the address doesn't belong to the allocator. <br /></td></tr>
<tr class="separator:a42cbeb52a93f33a6a04ea29f38e3aab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6f2d21b6a8f4c3be93f41042164704"><td class="memItemLeft" align="right" valign="top"><a id="a6d6f2d21b6a8f4c3be93f41042164704"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><b>NumAllocatedBytes</b> () const override</td></tr>
<tr class="separator:a6d6f2d21b6a8f4c3be93f41042164704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d0171a1edbfc396796046b3d089b0c"><td class="memItemLeft" align="right" valign="top"><a id="ab3d0171a1edbfc396796046b3d089b0c"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_overrun_detection_schema.html#ab3d0171a1edbfc396796046b3d089b0c">Capacity</a> () const override</td></tr>
<tr class="memdesc:ab3d0171a1edbfc396796046b3d089b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the Allocator in bytes. If the return value is 0 the Capacity is undefined (usually depends on another allocator) <br /></td></tr>
<tr class="separator:ab3d0171a1edbfc396796046b3d089b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fa083881cfa8c63083051a49c51c49"><td class="memItemLeft" align="right" valign="top"><a id="a15fa083881cfa8c63083051a49c51c49"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_overrun_detection_schema.html#a15fa083881cfa8c63083051a49c51c49">GetMaxAllocationSize</a> () const override</td></tr>
<tr class="memdesc:a15fa083881cfa8c63083051a49c51c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max allocation size if possible. If not returned value is 0. <br /></td></tr>
<tr class="separator:a15fa083881cfa8c63083051a49c51c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb55e437ebc4595844ed29b37eab3057"><td class="memItemLeft" align="right" valign="top"><a id="acb55e437ebc4595844ed29b37eab3057"></a>
virtual <a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_overrun_detection_schema.html#acb55e437ebc4595844ed29b37eab3057">GetSubAllocator</a> () override</td></tr>
<tr class="memdesc:acb55e437ebc4595844ed29b37eab3057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a sub-allocator or NULL. <br /></td></tr>
<tr class="separator:acb55e437ebc4595844ed29b37eab3057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab438c93e9ff5bf2efc980e3af6705376"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_overrun_detection_schema.html#ab438c93e9ff5bf2efc980e3af6705376">GarbageCollect</a> () override</td></tr>
<tr class="separator:ab438c93e9ff5bf2efc980e3af6705376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_a_z_1_1_i_allocator_allocate"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_z_1_1_i_allocator_allocate')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_a_z_1_1_i_allocator_allocate.html">AZ::IAllocatorAllocate</a></td></tr>
<tr class="memitem:a74867750b0dc972aea01368d3cce8f66 inherit pub_methods_class_a_z_1_1_i_allocator_allocate"><td class="memItemLeft" align="right" valign="top">virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_allocate.html#a74867750b0dc972aea01368d3cce8f66">GetUnAllocatedMemory</a> (bool isPrint=false) const</td></tr>
<tr class="separator:a74867750b0dc972aea01368d3cce8f66 inherit pub_methods_class_a_z_1_1_i_allocator_allocate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Overrun detection allocator scheme Use if you suspect a memory overrun. Application will crash at the point of memory access outside the allocated range. This allocator is intended for short-term debugging purposes only. It consumes a lot of extra memory and leaks it at shutdown.</p>
<p>In broad strokes, this technique works by reserving but not allocating an extra "trap" page after the requested space, and realigning the requested allocation to end right before the trap begins. Attempts to write to memory beyond the requested allocation will write into the trap page, triggering an exception.</p>
<p>This greatly bloats memory allocations, as the minimum allocation size becomes 2x the page size of the OS (a page for the requested memory, plus the trap page). On most platforms this is 8kb (4kb * 2 pages). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab438c93e9ff5bf2efc980e3af6705376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab438c93e9ff5bf2efc980e3af6705376">&#9670;&nbsp;</a></span>GarbageCollect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::OverrunDetectionSchema::GarbageCollect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call from the system when we want allocators to free unused memory. IMPORTANT: This function is/should be thread safe. We can call it from any context to free memory. Freeing the actual memory is optional (if you can), thread safety is a must. </p>

<p>Reimplemented from <a class="el" href="class_a_z_1_1_i_allocator_allocate.html#afb5bdf55f07eff5debf51703b4ea021d">AZ::IAllocatorAllocate</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 6 2021 15:03:50 for AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
