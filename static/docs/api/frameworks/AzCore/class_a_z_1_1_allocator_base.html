<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.17" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>AzCore API Reference: AZ::AllocatorBase Class Reference</title>
<link href="/css/api-ref/tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="/css/api-ref/doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">AzCore API Reference
   </div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div class="navpath" id="nav-path">
<ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_allocator_base.html">AllocatorBase</a></li> </ul>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="#pro-methods">Protected Member Functions</a> |
<a href="class_a_z_1_1_allocator_base-members.html">List of all members</a> </div>
<div class="headertitle">
<div class="title">AZ::AllocatorBase Class Reference</div> </div>
</div><!--header-->
<div class="contents">
<p><code>#include &lt;AllocatorBase.h&gt;</code></p>
<p>Inherits <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a>.</p>
<p>Inherited by <a class="el" href="class_a_z_1_1_best_fit_external_map_allocator.html">AZ::BestFitExternalMapAllocator</a>, <a class="el" href="class_a_z_1_1_o_s_allocator.html">AZ::OSAllocator</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; Schema, DescriptorType, ProfileAllocations, ReportOutOfMemory &gt;</a>, <a class="el" href="class_a_z_1_1_system_allocator.html">AZ::SystemAllocator</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; AZ::HphaSchema, AZ::HphaSchema::Descriptor, false &gt;</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; AZ::OverrunDetectionSchema &gt;</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; PoolSchema, PoolSchema ::Descriptor, true, false &gt;</a>, and <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; Schema, Schema::Descriptor, true, false &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4df1fa8684e8d251f813019af6061d72"><td align="right" class="memItemLeft" valign="top"><a id="a4df1fa8684e8d251f813019af6061d72"></a>
const char * </td><td class="memItemRight" valign="bottom"><b>GetName</b> () const override</td></tr>
<tr class="separator:a4df1fa8684e8d251f813019af6061d72"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a61f81b666bc40af8c0bf5ba433053598"><td align="right" class="memItemLeft" valign="top"><a id="a61f81b666bc40af8c0bf5ba433053598"></a>
const char * </td><td class="memItemRight" valign="bottom"><b>GetDescription</b> () const override</td></tr>
<tr class="separator:a61f81b666bc40af8c0bf5ba433053598"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a768a085abadeff74e31e03b696a13da9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a768a085abadeff74e31e03b696a13da9">GetSchema</a> () override</td></tr>
<tr class="separator:a768a085abadeff74e31e03b696a13da9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae4a05165309c18fcd9e00861b89d4299"><td align="right" class="memItemLeft" valign="top"><a id="ae4a05165309c18fcd9e00861b89d4299"></a>
<a class="el" href="class_a_z_1_1_debug_1_1_allocation_records.html">Debug::AllocationRecords</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ae4a05165309c18fcd9e00861b89d4299">GetRecords</a> () final</td></tr>
<tr class="memdesc:ae4a05165309c18fcd9e00861b89d4299"><td class="mdescLeft"> </td><td class="mdescRight">Returns a pointer to the allocation records. They might be available or not depending on the build type. <a class="el" href="class_a_z_1_1_debug_1_1_allocation_records.html">Debug::AllocationRecords</a>. <br/></td></tr>
<tr class="separator:ae4a05165309c18fcd9e00861b89d4299"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a030d903bb426f7a88bd2398b1eb191"><td align="right" class="memItemLeft" valign="top"><a id="a3a030d903bb426f7a88bd2398b1eb191"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a3a030d903bb426f7a88bd2398b1eb191">SetRecords</a> (<a class="el" href="class_a_z_1_1_debug_1_1_allocation_records.html">Debug::AllocationRecords</a> *records) final</td></tr>
<tr class="memdesc:a3a030d903bb426f7a88bd2398b1eb191"><td class="mdescLeft"> </td><td class="mdescRight">Sets the allocation records. <br/></td></tr>
<tr class="separator:a3a030d903bb426f7a88bd2398b1eb191"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b10cc083fcbbe17112c15604923dcb8"><td align="right" class="memItemLeft" valign="top"><a id="a3b10cc083fcbbe17112c15604923dcb8"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a3b10cc083fcbbe17112c15604923dcb8">IsReady</a> () const final</td></tr>
<tr class="memdesc:a3b10cc083fcbbe17112c15604923dcb8"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if this allocator is ready to use. <br/></td></tr>
<tr class="separator:a3b10cc083fcbbe17112c15604923dcb8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad73f2808a210140b5d2317f22c960ed2"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ad73f2808a210140b5d2317f22c960ed2">CanBeOverridden</a> () const final</td></tr>
<tr class="separator:ad73f2808a210140b5d2317f22c960ed2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4f0a8e0d1826e5d68de7c48a54127c74"><td align="right" class="memItemLeft" valign="top"><a id="a4f0a8e0d1826e5d68de7c48a54127c74"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a4f0a8e0d1826e5d68de7c48a54127c74">PostCreate</a> () override</td></tr>
<tr class="memdesc:a4f0a8e0d1826e5d68de7c48a54127c74"><td class="mdescLeft"> </td><td class="mdescRight">All conforming allocators must call <a class="el" href="class_a_z_1_1_allocator_base.html#a4f0a8e0d1826e5d68de7c48a54127c74" title="All conforming allocators must call PostCreate() after their custom Create() method in order to be pr...">PostCreate()</a> after their custom Create() method in order to be properly registered. <br/></td></tr>
<tr class="separator:a4f0a8e0d1826e5d68de7c48a54127c74"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab8c706a1394df8e06a4ec118da0946fe"><td align="right" class="memItemLeft" valign="top"><a id="ab8c706a1394df8e06a4ec118da0946fe"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ab8c706a1394df8e06a4ec118da0946fe">PreDestroy</a> () final</td></tr>
<tr class="memdesc:ab8c706a1394df8e06a4ec118da0946fe"><td class="mdescLeft"> </td><td class="mdescRight">All conforming allocators must call <a class="el" href="class_a_z_1_1_allocator_base.html#ab8c706a1394df8e06a4ec118da0946fe" title="All conforming allocators must call PreDestroy() before their custom Destroy() method in order to be ...">PreDestroy()</a> before their custom Destroy() method in order to be properly deregistered. <br/></td></tr>
<tr class="separator:ab8c706a1394df8e06a4ec118da0946fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2472cdf0a944b0657bfcbba28cfb64fa"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a2472cdf0a944b0657bfcbba28cfb64fa">SetLazilyCreated</a> (bool lazy) final</td></tr>
<tr class="separator:a2472cdf0a944b0657bfcbba28cfb64fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1888c05c8d2aa8ae3b305a81ca964121"><td align="right" class="memItemLeft" valign="top"><a id="a1888c05c8d2aa8ae3b305a81ca964121"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a1888c05c8d2aa8ae3b305a81ca964121">IsLazilyCreated</a> () const final</td></tr>
<tr class="memdesc:a1888c05c8d2aa8ae3b305a81ca964121"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if the allocator was lazily created. Exposed primarily for testing systems that need to verify the state of allocators. <br/></td></tr>
<tr class="separator:a1888c05c8d2aa8ae3b305a81ca964121"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4b5066e11564d2204e6cda0fe77a88d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ad4b5066e11564d2204e6cda0fe77a88d">SetProfilingActive</a> (bool active) final</td></tr>
<tr class="separator:ad4b5066e11564d2204e6cda0fe77a88d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c400ce989f21e09674ab4568f728097"><td align="right" class="memItemLeft" valign="top"><a id="a7c400ce989f21e09674ab4568f728097"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a7c400ce989f21e09674ab4568f728097">IsProfilingActive</a> () const final</td></tr>
<tr class="memdesc:a7c400ce989f21e09674ab4568f728097"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if profiling calls will be made. <br/></td></tr>
<tr class="separator:a7c400ce989f21e09674ab4568f728097"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_class_a_z_1_1_i_allocator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_z_1_1_i_allocator')"><img alt="-" src="/images/api-ref/closed.png"/> Public Member Functions inherited from <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a></td></tr>
<tr class="memitem:a6b00fb0bdaa8be2af1c04e1d26e8acfa inherit pub_methods_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top"><a id="a6b00fb0bdaa8be2af1c04e1d26e8acfa"></a>
 </td><td class="memItemRight" valign="bottom"><b>IAllocator</b> (<a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> *allocationSource)</td></tr>
<tr class="separator:a6b00fb0bdaa8be2af1c04e1d26e8acfa inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40a0bb675ebe399ac9715d8a5af68a61 inherit pub_methods_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top"><a id="a40a0bb675ebe399ac9715d8a5af68a61"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator.html#a40a0bb675ebe399ac9715d8a5af68a61">GetAllocationSource</a> () const</td></tr>
<tr class="memdesc:a40a0bb675ebe399ac9715d8a5af68a61 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="mdescLeft"> </td><td class="mdescRight">Returns the current allocation source, which may be used to perform memory allocations. <br/></td></tr>
<tr class="separator:a40a0bb675ebe399ac9715d8a5af68a61 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74658c63bce1638fb1fd5c1b8fff9369 inherit pub_methods_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top"><a id="a74658c63bce1638fb1fd5c1b8fff9369"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator.html#a74658c63bce1638fb1fd5c1b8fff9369">GetOriginalAllocationSource</a> () const</td></tr>
<tr class="memdesc:a74658c63bce1638fb1fd5c1b8fff9369 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="mdescLeft"> </td><td class="mdescRight">Returns the original allocation source. Generally only used for debugging purposes. <br/></td></tr>
<tr class="separator:a74658c63bce1638fb1fd5c1b8fff9369 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a340971448a4861bbbc6e0fd7783e86b5 inherit pub_methods_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top"><a id="a340971448a4861bbbc6e0fd7783e86b5"></a>
AZ_FORCE_INLINE bool </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator.html#a340971448a4861bbbc6e0fd7783e86b5">IsAllocationSourceChanged</a> () const</td></tr>
<tr class="memdesc:a340971448a4861bbbc6e0fd7783e86b5 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if the allocation source has changed from its original value. <br/></td></tr>
<tr class="separator:a340971448a4861bbbc6e0fd7783e86b5 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06320a82ca9f2a7b843cd555f6cfea4d inherit pub_methods_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator.html#a06320a82ca9f2a7b843cd555f6cfea4d">SetAllocationSource</a> (<a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> *allocationSource)</td></tr>
<tr class="separator:a06320a82ca9f2a7b843cd555f6cfea4d inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21aff2de855c7a751bfb0e506040dbf7 inherit pub_methods_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator.html#a21aff2de855c7a751bfb0e506040dbf7">ResetAllocationSource</a> ()</td></tr>
<tr class="separator:a21aff2de855c7a751bfb0e506040dbf7 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac4e085ec8fce3decb571034055e62309 inherit pub_methods_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top"><a id="ac4e085ec8fce3decb571034055e62309"></a>
virtual <a class="el" href="struct_a_z_1_1_allocator_debug_config.html">AllocatorDebugConfig</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator.html#ac4e085ec8fce3decb571034055e62309">GetDebugConfig</a> ()=0</td></tr>
<tr class="memdesc:ac4e085ec8fce3decb571034055e62309 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="mdescLeft"> </td><td class="mdescRight">Returns the debug configuration for this allocator. <br/></td></tr>
<tr class="separator:ac4e085ec8fce3decb571034055e62309 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a41aeb5178133b9b34c91e06a244e8215"><td align="right" class="memItemLeft" valign="top"><a id="a41aeb5178133b9b34c91e06a244e8215"></a>
 </td><td class="memItemRight" valign="bottom"><b>AllocatorBase</b> (<a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> *allocationSource, const char *name, const char *desc)</td></tr>
<tr class="separator:a41aeb5178133b9b34c91e06a244e8215"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaf5bdb7646ca2cffc0241ac919335efb"><td align="right" class="memItemLeft" valign="top"><a id="aaf5bdb7646ca2cffc0241ac919335efb"></a>
AZ_FORCE_INLINE size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#aaf5bdb7646ca2cffc0241ac919335efb">MemorySizeAdjustedUp</a> (size_t byteSize) const</td></tr>
<tr class="memdesc:aaf5bdb7646ca2cffc0241ac919335efb"><td class="mdescLeft"> </td><td class="mdescRight">Returns the size of a memory allocation after adjusting for tracking. <br/></td></tr>
<tr class="separator:aaf5bdb7646ca2cffc0241ac919335efb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:add248fc9ce272bb9673579d8aee7f4f0"><td align="right" class="memItemLeft" valign="top"><a id="add248fc9ce272bb9673579d8aee7f4f0"></a>
AZ_FORCE_INLINE size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#add248fc9ce272bb9673579d8aee7f4f0">MemorySizeAdjustedDown</a> (size_t byteSize) const</td></tr>
<tr class="memdesc:add248fc9ce272bb9673579d8aee7f4f0"><td class="mdescLeft"> </td><td class="mdescRight">Returns the size of a memory allocation, removing any tracking overhead. <br/></td></tr>
<tr class="separator:add248fc9ce272bb9673579d8aee7f4f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0204d34a485416e304d5384c5a7a04c3"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a0204d34a485416e304d5384c5a7a04c3">DisableOverriding</a> ()</td></tr>
<tr class="separator:a0204d34a485416e304d5384c5a7a04c3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9db7f2fedbda2663e5b12434ab5b09a1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a9db7f2fedbda2663e5b12434ab5b09a1">DisableRegistration</a> ()</td></tr>
<tr class="separator:a9db7f2fedbda2663e5b12434ab5b09a1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3fde2583165effaca7f0fce7b327830b"><td align="right" class="memItemLeft" valign="top"><a id="a3fde2583165effaca7f0fce7b327830b"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a3fde2583165effaca7f0fce7b327830b">ProfileAllocation</a> (void *ptr, size_t byteSize, size_t alignment, const char *name, const char *fileName, int lineNum, int suppressStackRecord)</td></tr>
<tr class="memdesc:a3fde2583165effaca7f0fce7b327830b"><td class="mdescLeft"> </td><td class="mdescRight">Records an allocation for profiling. <br/></td></tr>
<tr class="separator:a3fde2583165effaca7f0fce7b327830b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a01ad18ec2ce4cadbbc40979392a7a719"><td align="right" class="memItemLeft" valign="top"><a id="a01ad18ec2ce4cadbbc40979392a7a719"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a01ad18ec2ce4cadbbc40979392a7a719">ProfileDeallocation</a> (void *ptr, size_t byteSize, size_t alignment, <a class="el" href="struct_a_z_1_1_debug_1_1_allocation_info.html">Debug::AllocationInfo</a> *info)</td></tr>
<tr class="memdesc:a01ad18ec2ce4cadbbc40979392a7a719"><td class="mdescLeft"> </td><td class="mdescRight">Records a deallocation for profiling. <br/></td></tr>
<tr class="separator:a01ad18ec2ce4cadbbc40979392a7a719"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca8ebd8941d7dffdec13864008712f4d"><td align="right" class="memItemLeft" valign="top"><a id="aca8ebd8941d7dffdec13864008712f4d"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#aca8ebd8941d7dffdec13864008712f4d">ProfileReallocationBegin</a> (void *ptr, size_t newSize)</td></tr>
<tr class="memdesc:aca8ebd8941d7dffdec13864008712f4d"><td class="mdescLeft"> </td><td class="mdescRight">Records a reallocation for profiling. <br/></td></tr>
<tr class="separator:aca8ebd8941d7dffdec13864008712f4d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a578c5cbf30fa3027df60be7f038660c2"><td align="right" class="memItemLeft" valign="top"><a id="a578c5cbf30fa3027df60be7f038660c2"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a578c5cbf30fa3027df60be7f038660c2">ProfileReallocationEnd</a> (void *ptr, void *newPtr, size_t newSize, size_t newAlignment)</td></tr>
<tr class="memdesc:a578c5cbf30fa3027df60be7f038660c2"><td class="mdescLeft"> </td><td class="mdescRight">Records the beginning of a reallocation for profiling. <br/></td></tr>
<tr class="separator:a578c5cbf30fa3027df60be7f038660c2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab8cde659f584df96b281b961cdb54566"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ab8cde659f584df96b281b961cdb54566">ProfileReallocation</a> (void *ptr, void *newPtr, size_t newSize, size_t newAlignment)</td></tr>
<tr class="separator:ab8cde659f584df96b281b961cdb54566"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac9160e4e32dec84dee39e2421e1f7954"><td align="right" class="memItemLeft" valign="top"><a id="ac9160e4e32dec84dee39e2421e1f7954"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ac9160e4e32dec84dee39e2421e1f7954">ProfileResize</a> (void *ptr, size_t newSize)</td></tr>
<tr class="memdesc:ac9160e4e32dec84dee39e2421e1f7954"><td class="mdescLeft"> </td><td class="mdescRight">Records a resize for profiling. <br/></td></tr>
<tr class="separator:ac9160e4e32dec84dee39e2421e1f7954"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d190d6a079f57c4bacc3ef7ab505a33"><td align="right" class="memItemLeft" valign="top"><a id="a1d190d6a079f57c4bacc3ef7ab505a33"></a>
bool </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a1d190d6a079f57c4bacc3ef7ab505a33">OnOutOfMemory</a> (size_t byteSize, size_t alignment, int flags, const char *name, const char *fileName, int lineNum)</td></tr>
<tr class="memdesc:a1d190d6a079f57c4bacc3ef7ab505a33"><td class="mdescLeft"> </td><td class="mdescRight">User allocator should call this function when they run out of memory! <br/></td></tr>
<tr class="separator:a1d190d6a079f57c4bacc3ef7ab505a33"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_a_z_1_1_i_allocator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_a_z_1_1_i_allocator')"><img alt="-" src="/images/api-ref/closed.png"/> Protected Attributes inherited from <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a></td></tr>
<tr class="memitem:a11df19dfde459bed88a746253ee28f9d inherit pro_attribs_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top"><a id="a11df19dfde459bed88a746253ee28f9d"></a>
<a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> * </td><td class="memItemRight" valign="bottom"><b>m_allocationSource</b></td></tr>
<tr class="separator:a11df19dfde459bed88a746253ee28f9d inherit pro_attribs_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee35fae266e98c3fc88e0f5bfc96b436 inherit pro_attribs_class_a_z_1_1_i_allocator"><td align="right" class="memItemLeft" valign="top"><a id="aee35fae266e98c3fc88e0f5bfc96b436"></a>
<a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a> * </td><td class="memItemRight" valign="bottom"><b>m_originalAllocationSource</b></td></tr>
<tr class="separator:aee35fae266e98c3fc88e0f5bfc96b436 inherit pro_attribs_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_a_z_1_1_allocator_base.html">AllocatorBase</a> - all AZ-compatible allocators should inherit from this implementation of <a class="el" href="class_a_z_1_1_i_allocator.html">IAllocator</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad73f2808a210140b5d2317f22c960ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73f2808a210140b5d2317f22c960ed2">◆ </a></span>CanBeOverridden()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool AZ::AllocatorBase::CanBeOverridden </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns true if this allocator can be overridden with a different source. Almost all allocators should return true. There are very few minor exceptions, such as the OS Allocator, that are required for direct interfacing with the kernel and must never be overridden under any circumstances. </p>
<p>Implements <a class="el" href="class_a_z_1_1_i_allocator.html#a3ba8b9f73b151a0f0cccaefeec39a1c8">AZ::IAllocator</a>.</p>
</div>
</div>
<a id="a0204d34a485416e304d5384c5a7a04c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0204d34a485416e304d5384c5a7a04c3">◆ </a></span>DisableOverriding()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void AZ::AllocatorBase::DisableOverriding </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Call to disallow this allocator from being overridden. Only kernel-level allocators where it would be especially problematic for them to be overridden should do this. </p>
</div>
</div>
<a id="a9db7f2fedbda2663e5b12434ab5b09a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db7f2fedbda2663e5b12434ab5b09a1">◆ </a></span>DisableRegistration()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void AZ::AllocatorBase::DisableRegistration </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Call to disallow this allocator from being registered with the <a class="el" href="class_a_z_1_1_allocator_manager.html">AllocatorManager</a>. Only kernel-level allocators where it would be especially problematic for them to be registered with the <a class="el" href="class_a_z_1_1_allocator_manager.html">AllocatorManager</a> should do this. </p>
</div>
</div>
<a id="a768a085abadeff74e31e03b696a13da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768a085abadeff74e31e03b696a13da9">◆ </a></span>GetSchema()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="class_a_z_1_1_i_allocator_allocate.html">IAllocatorAllocate</a>* AZ::AllocatorBase::GetSchema </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the schema, if the allocator uses one. Returns nullptr if the allocator does not use a schema. This is mainly used when debugging to determine if allocators alias each other under the hood. </p>
<p>Implements <a class="el" href="class_a_z_1_1_i_allocator.html#a31b4adc37ee7c6402213394c427d9287">AZ::IAllocator</a>.</p>
<p>Reimplemented in <a class="el" href="class_a_z_1_1_system_allocator.html#a8f85c2f674f09982c7ee79f8e76c6406">AZ::SystemAllocator</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html#aa50ef41e0ec3bb537fe9a7936e1b403e">AZ::SimpleSchemaAllocator&lt; Schema, DescriptorType, ProfileAllocations, ReportOutOfMemory &gt;</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html#aa50ef41e0ec3bb537fe9a7936e1b403e">AZ::SimpleSchemaAllocator&lt; Schema, Schema::Descriptor, true, false &gt;</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html#aa50ef41e0ec3bb537fe9a7936e1b403e">AZ::SimpleSchemaAllocator&lt; PoolSchema, PoolSchema ::Descriptor, true, false &gt;</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html#aa50ef41e0ec3bb537fe9a7936e1b403e">AZ::SimpleSchemaAllocator&lt; AZ::OverrunDetectionSchema &gt;</a>, and <a class="el" href="class_a_z_1_1_simple_schema_allocator.html#aa50ef41e0ec3bb537fe9a7936e1b403e">AZ::SimpleSchemaAllocator&lt; AZ::HphaSchema, AZ::HphaSchema::Descriptor, false &gt;</a>.</p>
</div>
</div>
<a id="ab8cde659f584df96b281b961cdb54566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cde659f584df96b281b961cdb54566">◆ </a></span>ProfileReallocation()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void AZ::AllocatorBase::ProfileReallocation </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>ptr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>newPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>newSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>newAlignment</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Deprecated. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Please use ProfileReallocationBegin/ProfileReallocationEnd instead. </dd></dl>
</div>
</div>
<a id="a2472cdf0a944b0657bfcbba28cfb64fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2472cdf0a944b0657bfcbba28cfb64fa">◆ </a></span>SetLazilyCreated()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void AZ::AllocatorBase::SetLazilyCreated </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lazy</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Determines whether the allocator was lazily created, possibly at static initialization. This is primarily meant to support older allocation systems, such as those used by CryEngine. Newer systems should create and destroy their allocators deliberately at program start-up and shut-down. </p>
<p>Implements <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a>.</p>
</div>
</div>
<a id="ad4b5066e11564d2204e6cda0fe77a88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b5066e11564d2204e6cda0fe77a88d">◆ </a></span>SetProfilingActive()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void AZ::AllocatorBase::SetProfilingActive </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>active</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets whether profiling calls should be made. This is primarily a performance compromise, as the profiling calls go out on an <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> that may not exist if not activated, and will result in an expensive hash lookup if that is the case. </p>
<p>Implements <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a>.</p>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 19 2021 13:49:54 for AzCore API Reference by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="/images/api-ref/doxygen.png"/>
</a> 1.8.17
</small></address>
</body>
</html>
