<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.17" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Atom API Reference: AZ::RPI::Shader Class Reference</title>
<link href="/css/api-ref/tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="/css/api-ref/doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">Atom API Reference
   </div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div class="navpath" id="nav-path">
<ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><b>RPI</b></li><li class="navelem"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a></li> </ul>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="#pub-static-methods">Static Public Member Functions</a> |
<a href="#friends">Friends</a> |
<a href="class_a_z_1_1_r_p_i_1_1_shader-members.html">List of all members</a> </div>
<div class="headertitle">
<div class="title">AZ::RPI::Shader Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div> </div>
</div><!--header-->
<div class="contents">
<p><code>#include &lt;Shader.h&gt;</code></p>
<p>Inherits InstanceData, Handler, and Handler.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5165cd5fb68c205f9030ab09197aee63"><td align="right" class="memItemLeft" valign="top"><a id="a5165cd5fb68c205f9030ab09197aee63"></a>
 </td><td class="memItemRight" valign="bottom"><b>AZ_INSTANCE_DATA</b> (<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a>, "{3576FF16-C3C5-48A6-9388-C3628A231BC3}")</td></tr>
<tr class="separator:a5165cd5fb68c205f9030ab09197aee63"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa823e42d73bfb12ac2fa0e19b97a0b30"><td align="right" class="memItemLeft" valign="top"><a id="aa823e42d73bfb12ac2fa0e19b97a0b30"></a>
 </td><td class="memItemRight" valign="bottom"><b>AZ_CLASS_ALLOCATOR</b> (<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a>, SystemAllocator, 0)</td></tr>
<tr class="separator:aa823e42d73bfb12ac2fa0e19b97a0b30"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7cca2fab422754c10c889ce6b63ac3b"><td align="right" class="memItemLeft" valign="top"><a id="aa7cca2fab422754c10c889ce6b63ac3b"></a>
 </td><td class="memItemRight" valign="bottom"><b>AZ_DISABLE_COPY_MOVE</b> (<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a>)</td></tr>
<tr class="separator:aa7cca2fab422754c10c889ce6b63ac3b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a99869e38b85d03c4b1c12d7026c67ef5"><td align="right" class="memItemLeft" valign="top"><a id="a99869e38b85d03c4b1c12d7026c67ef5"></a>
<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a99869e38b85d03c4b1c12d7026c67ef5">CreateShaderOptionGroup</a> () const</td></tr>
<tr class="memdesc:a99869e38b85d03c4b1c12d7026c67ef5"><td class="mdescLeft"> </td><td class="mdescRight">Constructs a shader option group suitable to generate a shader variant key for this shader. <br/></td></tr>
<tr class="separator:a99869e38b85d03c4b1c12d7026c67ef5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac924cb3db2580f715f1ea03c907ffe63"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#ac924cb3db2580f715f1ea03c907ffe63">GetVariant</a> (const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> &amp;shaderVariantId)</td></tr>
<tr class="separator:ac924cb3db2580f715f1ea03c907ffe63"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2511e12233eb7c359abb63789632dbc4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_search_result.html">ShaderVariantSearchResult</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a2511e12233eb7c359abb63789632dbc4">FindVariantStableId</a> (const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> &amp;shaderVariantId) const</td></tr>
<tr class="separator:a2511e12233eb7c359abb63789632dbc4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb0d4d7b02a99b542ec60ea9bd92bc30"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#aeb0d4d7b02a99b542ec60ea9bd92bc30">GetVariant</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderVariantStableId</a> shaderVariantStableId)</td></tr>
<tr class="separator:aeb0d4d7b02a99b542ec60ea9bd92bc30"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4a431cca7c4be1c8c2297c6bfc7361b"><td align="right" class="memItemLeft" valign="top"><a id="ad4a431cca7c4be1c8c2297c6bfc7361b"></a>
const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#ad4a431cca7c4be1c8c2297c6bfc7361b">GetRootVariant</a> ()</td></tr>
<tr class="memdesc:ad4a431cca7c4be1c8c2297c6bfc7361b"><td class="mdescLeft"> </td><td class="mdescRight">Convenient function that returns the root variant. <br/></td></tr>
<tr class="separator:ad4a431cca7c4be1c8c2297c6bfc7361b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6259837e04ee8b1f81647eaf5c10061c"><td align="right" class="memItemLeft" valign="top"><a id="a6259837e04ee8b1f81647eaf5c10061c"></a>
RHI::PipelineStateType </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a6259837e04ee8b1f81647eaf5c10061c">GetPipelineStateType</a> () const</td></tr>
<tr class="memdesc:a6259837e04ee8b1f81647eaf5c10061c"><td class="mdescLeft"> </td><td class="mdescRight">Returns the pipeline state type generated by variants of this shader. <br/></td></tr>
<tr class="separator:a6259837e04ee8b1f81647eaf5c10061c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae196a31f9b4b193995f5eb17cee83937"><td align="right" class="memItemLeft" valign="top"><a id="ae196a31f9b4b193995f5eb17cee83937"></a>
const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state.html">RHI::PipelineState</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#ae196a31f9b4b193995f5eb17cee83937">AcquirePipelineState</a> (const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_descriptor.html">RHI::PipelineStateDescriptor</a> &amp;descriptor) const</td></tr>
<tr class="memdesc:ae196a31f9b4b193995f5eb17cee83937"><td class="mdescLeft"> </td><td class="mdescRight">Acquires a pipeline state directly from a descriptor. <br/></td></tr>
<tr class="separator:ae196a31f9b4b193995f5eb17cee83937"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a76f472810d80e4c461adde454adeed81"><td align="right" class="memItemLeft" valign="top"><a id="a76f472810d80e4c461adde454adeed81"></a>
const Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_resource_group_asset.html">ShaderResourceGroupAsset</a> &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a76f472810d80e4c461adde454adeed81">FindShaderResourceGroupAsset</a> (const Name &amp;shaderResourceGroupName) const</td></tr>
<tr class="memdesc:a76f472810d80e4c461adde454adeed81"><td class="mdescLeft"> </td><td class="mdescRight">Finds and returns the shader resource group asset with the requested name. Returns an empty handle if no matching group was found. <br/></td></tr>
<tr class="separator:a76f472810d80e4c461adde454adeed81"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a10b9bd4d7d2c89611172d1b22f7a4247"><td align="right" class="memItemLeft" valign="top"><a id="a10b9bd4d7d2c89611172d1b22f7a4247"></a>
const Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_resource_group_asset.html">ShaderResourceGroupAsset</a> &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a10b9bd4d7d2c89611172d1b22f7a4247">FindShaderResourceGroupAsset</a> (uint32_t bindingSlot) const</td></tr>
<tr class="memdesc:a10b9bd4d7d2c89611172d1b22f7a4247"><td class="mdescLeft"> </td><td class="mdescRight">Finds and returns the shader resource group asset associated with the requested binding slot. Returns an empty handle if no matching group was found. <br/></td></tr>
<tr class="separator:a10b9bd4d7d2c89611172d1b22f7a4247"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7ebb55e151fead0f9ddcd8731534e411"><td align="right" class="memItemLeft" valign="top"><a id="a7ebb55e151fead0f9ddcd8731534e411"></a>
const Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_resource_group_asset.html">ShaderResourceGroupAsset</a> &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a7ebb55e151fead0f9ddcd8731534e411">FindFallbackShaderResourceGroupAsset</a> () const</td></tr>
<tr class="memdesc:a7ebb55e151fead0f9ddcd8731534e411"><td class="mdescLeft"> </td><td class="mdescRight">Finds and returns the shader resource group asset designated as a ShaderVariantKey fallback. <br/></td></tr>
<tr class="separator:a7ebb55e151fead0f9ddcd8731534e411"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa46d0fd6566b935e545980183158c964"><td align="right" class="memItemLeft" valign="top"><a id="aa46d0fd6566b935e545980183158c964"></a>
AZStd::array_view&lt; Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_resource_group_asset.html">ShaderResourceGroupAsset</a> &gt; &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#aa46d0fd6566b935e545980183158c964">GetShaderResourceGroupAssets</a> () const</td></tr>
<tr class="memdesc:aa46d0fd6566b935e545980183158c964"><td class="mdescLeft"> </td><td class="mdescRight">Returns the set of shader resource groups referenced by all variants in the shader asset. <br/></td></tr>
<tr class="separator:aa46d0fd6566b935e545980183158c964"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a56b99cab8bd35c1f67c89fa027b734ee"><td align="right" class="memItemLeft" valign="top"><a id="a56b99cab8bd35c1f67c89fa027b734ee"></a>
const Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_asset.html">ShaderAsset</a> &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a56b99cab8bd35c1f67c89fa027b734ee">GetAsset</a> () const</td></tr>
<tr class="memdesc:a56b99cab8bd35c1f67c89fa027b734ee"><td class="mdescLeft"> </td><td class="mdescRight">Returns a reference to the asset used to initialize this shader. <br/></td></tr>
<tr class="separator:a56b99cab8bd35c1f67c89fa027b734ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ad14c8c63c7e09e1974723c2994add3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">RHI::DrawListTag</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a1ad14c8c63c7e09e1974723c2994add3">GetDrawListTag</a> () const</td></tr>
<tr class="separator:a1ad14c8c63c7e09e1974723c2994add3"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa4d0e4ad03415a4f7985527e2044bb08"><td align="right" class="memItemLeft" valign="top"><a id="aa4d0e4ad03415a4f7985527e2044bb08"></a>
static Data::Instance&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#aa4d0e4ad03415a4f7985527e2044bb08">FindOrCreate</a> (const Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_asset.html">ShaderAsset</a> &gt; &amp;shaderAsset)</td></tr>
<tr class="memdesc:aa4d0e4ad03415a4f7985527e2044bb08"><td class="mdescLeft"> </td><td class="mdescRight">Returns the shader instance associated with the provided asset. <br/></td></tr>
<tr class="separator:aa4d0e4ad03415a4f7985527e2044bb08"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a70b04e69b416446a007ccf02ad66e61a"><td align="right" class="memItemLeft" valign="top"><a id="a70b04e69b416446a007ccf02ad66e61a"></a>
class </td><td class="memItemRight" valign="bottom"><b>ShaderSystem</b></td></tr>
<tr class="separator:a70b04e69b416446a007ccf02ad66e61a"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> is effectively an 'uber-shader' containing a collection of 'variants'. Variants are designed to be 'variations' on the same core shader technique. To enforce this, every variant in the shader shares the same pipeline layout (i.e. set of shader resource groups).</p>
<p>A shader owns a library of pipeline states. When a variant is resolved to a pipeline state, its lifetime is determined by the lifetime of the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> (unless an explicit reference is taken). If an asset reload event occurs, the pipeline state cache is reset.</p>
<p>To use <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a>: 1) Construct a <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a> instance using CreateShaderOptionGroup. 2) Configure the group by setting values on shader options. 3) Find the ShaderVariantStableId using the <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> generated from the configured <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a>. 4) Acquire the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> instance using the ShaderVariantStableId. 5) Configure a pipeline state descriptor on the variant; make local overrides as necessary (e.g. to configure runtime render state). 6) Acquire a <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state.html">RHI::PipelineState</a> instance from the shader using the configured pipeline state descriptor.</p>
<p>Remember that the returned <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state.html">RHI::PipelineState</a> instance lifetime is tied to the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> lifetime. If you need guarantee lifetime, it is safe to take a reference on the returned pipeline state. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2511e12233eb7c359abb63789632dbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2511e12233eb7c359abb63789632dbc4">◆ </a></span>FindVariantStableId()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_search_result.html">ShaderVariantSearchResult</a> AZ::RPI::Shader::FindVariantStableId </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> &amp; </td>
<td class="paramname"><em>shaderVariantId</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Finds the best matching shader variant asset and returns its StableId. In cases where you can't cache the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a>, and recurrently you may need the same <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> at different times, then it can be convenient (and more performant) to call this method to cache the ShaderVariantStableId and call <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#aeb0d4d7b02a99b542ec60ea9bd92bc30">GetVariant(ShaderVariantStableId)</a> when needed. If the asset is not immediately found in the file system, it will return the StableId of the root variant. Callers should listen to ShaderReloadNotificationBus to get notified whenever the exact variant is loaded and available or if a variant changes, etc. </p>
</div>
</div>
<a id="a1ad14c8c63c7e09e1974723c2994add3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad14c8c63c7e09e1974723c2994add3">◆ </a></span>GetDrawListTag()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">RHI::DrawListTag</a> AZ::RPI::Shader::GetDrawListTag </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the DrawListTag that identifies which <a class="el" href="class_a_z_1_1_r_p_i_1_1_pass.html">Pass</a> and <a class="el" href="class_a_z_1_1_r_p_i_1_1_view.html">View</a> objects will process this shader. This tag corresponds to the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_asset.html">ShaderAsset</a> object's DrawListName. </p>
</div>
</div>
<a id="ac924cb3db2580f715f1ea03c907ffe63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac924cb3db2580f715f1ea03c907ffe63">◆ </a></span>GetVariant() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a>&amp; AZ::RPI::Shader::GetVariant </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> &amp; </td>
<td class="paramname"><em>shaderVariantId</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Finds the best matching <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> for the given shaderVariantId, If the variant is loaded and ready it will return the corresponding <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a>. If the variant is not yet available it will return the root <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a>. Callers should listen to ShaderReloadNotificationBus to get notified whenever the exact variant is loaded and available or if a variant changes, etc. This function should be your one stop shop to get a <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> from a <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a>. Alternatively: You can call <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a2511e12233eb7c359abb63789632dbc4">FindVariantStableId()</a> followed by GetVariant(shaderVariantStableId). </p>
</div>
</div>
<a id="aeb0d4d7b02a99b542ec60ea9bd92bc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0d4d7b02a99b542ec60ea9bd92bc30">◆ </a></span>GetVariant() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a>&amp; AZ::RPI::Shader::GetVariant </td>
<td>(</td>
<td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderVariantStableId</a> </td>
<td class="paramname"><em>shaderVariantStableId</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the variant associated with the provided StableId. You should call <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a2511e12233eb7c359abb63789632dbc4">FindVariantStableId()</a> which caches the variant, later when this function is called the variant is fetched from a local map. If the variant is not found, the root variant is returned. "Alternatively: a more convenient approach is to call GetVariant(ShaderVariantId) which does both, the find and the get." </p>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 4 2021 15:16:55 for Atom API Reference by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="/images/api-ref/doxygen.png"/>
</a> 1.8.17
</small></address>
</body>
</html>
