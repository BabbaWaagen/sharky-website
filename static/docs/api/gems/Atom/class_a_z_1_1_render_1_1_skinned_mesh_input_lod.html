<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Atom API Reference: AZ::Render::SkinnedMeshInputLod Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Atom API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><b>Render</b></li><li class="navelem"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html">SkinnedMeshInputLod</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::Render::SkinnedMeshInputLod Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;SkinnedMeshInputBuffers.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a44df9a8863631937eed90b990c88254e"><td class="memItemLeft" align="right" valign="top"><a id="a44df9a8863631937eed90b990c88254e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a44df9a8863631937eed90b990c88254e">SetIndexCount</a> (uint32_t indexCount)</td></tr>
<tr class="memdesc:a44df9a8863631937eed90b990c88254e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of indices for the lod. Must be called before calling CreateIndexBuffer. <br /></td></tr>
<tr class="separator:a44df9a8863631937eed90b990c88254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af673611c32f065dda14338c4d62e3bd7"><td class="memItemLeft" align="right" valign="top"><a id="af673611c32f065dda14338c4d62e3bd7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#af673611c32f065dda14338c4d62e3bd7">SetVertexCount</a> (uint32_t vertexCount)</td></tr>
<tr class="memdesc:af673611c32f065dda14338c4d62e3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of vertices for the lod. Must be called before calling CreateSkinningInputBuffer or CreateStaticBuffer. <br /></td></tr>
<tr class="separator:af673611c32f065dda14338c4d62e3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab877a5beb782ec0f1b3612cacf52b9"><td class="memItemLeft" align="right" valign="top"><a id="a3ab877a5beb782ec0f1b3612cacf52b9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a3ab877a5beb782ec0f1b3612cacf52b9">GetVertexCount</a> () const</td></tr>
<tr class="memdesc:a3ab877a5beb782ec0f1b3612cacf52b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices for the lod. <br /></td></tr>
<tr class="separator:a3ab877a5beb782ec0f1b3612cacf52b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fa4e26bafea84848f72023378cb868"><td class="memItemLeft" align="right" valign="top"><a id="ae5fa4e26bafea84848f72023378cb868"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#ae5fa4e26bafea84848f72023378cb868">SetIndexBuffer</a> (const Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_buffer_asset.html">RPI::BufferAsset</a> &gt; bufferAsset)</td></tr>
<tr class="memdesc:ae5fa4e26bafea84848f72023378cb868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the index buffer asset. <br /></td></tr>
<tr class="separator:ae5fa4e26bafea84848f72023378cb868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326be1249850ecc88fceec5bcf8bc637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a326be1249850ecc88fceec5bcf8bc637">CreateIndexBuffer</a> (const uint32_t *data, const AZStd::string &amp;bufferNamePrefix=&quot;&quot;)</td></tr>
<tr class="separator:a326be1249850ecc88fceec5bcf8bc637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63b90d5a2c70cf0e1d78f3174be9e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#af63b90d5a2c70cf0e1d78f3174be9e74">CreateSkinningInputBuffer</a> (void *data, SkinnedMeshInputVertexStreams inputStream, const AZStd::string &amp;bufferNamePrefix=&quot;&quot;)</td></tr>
<tr class="separator:af63b90d5a2c70cf0e1d78f3174be9e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5f9731aa9f85fe5cf5ca4b5e501802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a2d5f9731aa9f85fe5cf5ca4b5e501802">CreateStaticBuffer</a> (void *data, SkinnedMeshStaticVertexStreams staticInputStream, const AZStd::string &amp;bufferNamePrefix=&quot;&quot;)</td></tr>
<tr class="separator:a2d5f9731aa9f85fe5cf5ca4b5e501802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24711ba523b8562c8cf06cab65bc4c27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a24711ba523b8562c8cf06cab65bc4c27">SetSubMeshProperties</a> (const AZStd::vector&lt; <a class="el" href="struct_a_z_1_1_render_1_1_skinned_sub_mesh_properties.html">SkinnedSubMeshProperties</a> &gt; &amp;subMeshProperties)</td></tr>
<tr class="separator:a24711ba523b8562c8cf06cab65bc4c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3518ddbd742086dd539f45023c191a88"><td class="memItemLeft" align="right" valign="top"><a id="a3518ddbd742086dd539f45023c191a88"></a>
const AZStd::vector&lt; <a class="el" href="struct_a_z_1_1_render_1_1_skinned_sub_mesh_properties.html">SkinnedSubMeshProperties</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a3518ddbd742086dd539f45023c191a88">GetSubMeshProperties</a> () const</td></tr>
<tr class="memdesc:a3518ddbd742086dd539f45023c191a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties of each submesh. <br /></td></tr>
<tr class="separator:a3518ddbd742086dd539f45023c191a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d17bc2d37eb52148959a195b8d156b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#aa5d17bc2d37eb52148959a195b8d156b">AddMorphTarget</a> (float minWeight, float maxWeight, float minDelta, float maxDelta, uint32_t vertexCount, const AZStd::vector&lt; uint32_t &gt; &amp;deltas, const AZStd::string &amp;bufferNamePrefix)</td></tr>
<tr class="separator:aa5d17bc2d37eb52148959a195b8d156b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8e2358fb5889acde6340970679f1b0"><td class="memItemLeft" align="right" valign="top"><a id="a3b8e2358fb5889acde6340970679f1b0"></a>
const AZStd::vector&lt; <a class="el" href="struct_a_z_1_1_render_1_1_morph_target_meta_data.html">MorphTargetMetaData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a3b8e2358fb5889acde6340970679f1b0">GetMorphTargetMetaDatas</a> () const</td></tr>
<tr class="memdesc:a3b8e2358fb5889acde6340970679f1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MetaDatas for all the morph targets that can be applied to an instance of this skinned mesh. <br /></td></tr>
<tr class="separator:a3b8e2358fb5889acde6340970679f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1f2f1294eb1ffaaad1fe6185b7ce6a"><td class="memItemLeft" align="right" valign="top"><a id="ada1f2f1294eb1ffaaad1fe6185b7ce6a"></a>
const AZStd::vector&lt; AZStd::intrusive_ptr&lt; <a class="el" href="class_a_z_1_1_render_1_1_morph_target_input_buffers.html">MorphTargetInputBuffers</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#ada1f2f1294eb1ffaaad1fe6185b7ce6a">GetMorphTargetInputBuffers</a> () const</td></tr>
<tr class="memdesc:ada1f2f1294eb1ffaaad1fe6185b7ce6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_a_z_1_1_render_1_1_morph_target_input_buffers.html">MorphTargetInputBuffers</a> for all the morph targets that can be applied to an instance of this skinned mesh. <br /></td></tr>
<tr class="separator:ada1f2f1294eb1ffaaad1fe6185b7ce6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed60b05162e385b7364f524be4c3b9e"><td class="memItemLeft" align="right" valign="top"><a id="a2ed60b05162e385b7364f524be4c3b9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a2ed60b05162e385b7364f524be4c3b9e">SetSkinningInputBufferAsset</a> (const Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_buffer_asset.html">RPI::BufferAsset</a> &gt; bufferAsset, SkinnedMeshInputVertexStreams inputStream)</td></tr>
<tr class="memdesc:a2ed60b05162e385b7364f524be4c3b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input for an input vertex stream from an existing buffer asset. <br /></td></tr>
<tr class="separator:a2ed60b05162e385b7364f524be4c3b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd33dc5c293f20bacc71772087f381f"><td class="memItemLeft" align="right" valign="top"><a id="a8fd33dc5c293f20bacc71772087f381f"></a>
const Data::Asset&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_buffer_asset.html">RPI::BufferAsset</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a8fd33dc5c293f20bacc71772087f381f">GetSkinningInputBufferAsset</a> (SkinnedMeshInputVertexStreams stream) const</td></tr>
<tr class="memdesc:a8fd33dc5c293f20bacc71772087f381f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the BufferAsset of an input vertex stream. <br /></td></tr>
<tr class="separator:a8fd33dc5c293f20bacc71772087f381f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab65aeabfba5920013fe97703f3439c"><td class="memItemLeft" align="right" valign="top"><a id="a0ab65aeabfba5920013fe97703f3439c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html#a0ab65aeabfba5920013fe97703f3439c">WaitForUpload</a> ()</td></tr>
<tr class="memdesc:a0ab65aeabfba5920013fe97703f3439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="class_a_z_1_1_r_p_i_1_1_buffer.html#aaa126f04cdea4d5532ec8e6737030cbe" title="Blocks until a streaming upload has completed (if one is currently in flight).">RPI::Buffer::WaitForUpload</a> for each buffer in the lod. <br /></td></tr>
<tr class="separator:a0ab65aeabfba5920013fe97703f3439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5a6eb82f484241bee5f1e4f805efd975"><td class="memItemLeft" align="right" valign="top"><a id="a5a6eb82f484241bee5f1e4f805efd975"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkinnedMeshInputBuffers</b></td></tr>
<tr class="separator:a5a6eb82f484241bee5f1e4f805efd975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Container for all the buffers and views needed for a single lod of a skinned mesh To create a <a class="el" href="class_a_z_1_1_render_1_1_skinned_mesh_input_lod.html">SkinnedMeshInputLod</a>, follow the general pattern lod.SetIndexCount() lod.SetVertexCount() lod.CreateIndexBuffer() for each input buffer lod.CreateSkinningInputBuffer() for each static buffer lod.CreateStaticBuffer() lod.SetSubMeshProperties() </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa5d17bc2d37eb52148959a195b8d156b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d17bc2d37eb52148959a195b8d156b">&#9670;&nbsp;</a></span>AddMorphTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::Render::SkinnedMeshInputLod::AddMorphTarget </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZStd::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>deltas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZStd::string &amp;&#160;</td>
          <td class="paramname"><em>bufferNamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a single morph target that can be applied to an instance of this skinned mesh </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minWeight</td><td>The minimum weight. Used in combination with the min/max deltas to determine the maximum value this morph could possibly offset a vertex. </td></tr>
    <tr><td class="paramname">maxWeight</td><td>The maximum weight. Used in combination with the min/max deltas to determine the maximum value this morph could possibly offset a vertex. </td></tr>
    <tr><td class="paramname">minDelta</td><td>The minimum value of all the deltas. Used for decoding the deltas. </td></tr>
    <tr><td class="paramname">maxDelta</td><td>The maximum value of all the deltas. Used for decoding the deltas. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>The total number of vertices that are deformed. </td></tr>
    <tr><td class="paramname">vertexNumbers</td><td>The indices of the vertices that are deformed, since the morph target can deform a sparse set of vertices. </td></tr>
    <tr><td class="paramname">deltas</td><td>The encoded deltas, stored as a raw buffer of 4 byte components. </td></tr>
    <tr><td class="paramname">bufferNamePrefix</td><td>A prefix that can be used to identify this morph target when creating names for the buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a326be1249850ecc88fceec5bcf8bc637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326be1249850ecc88fceec5bcf8bc637">&#9670;&nbsp;</a></span>CreateIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::Render::SkinnedMeshInputLod::CreateIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZStd::string &amp;&#160;</td>
          <td class="paramname"><em>bufferNamePrefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the index buffer. SetIndexCount must be called first as CreateIndexBuffer depends on that to know the number of indices to create. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The indices to be used for the index buffer. The index buffer is used by the target skinned model, but is not modified during skinning so it is shared between all instances of the same skinned mesh. </td></tr>
    <tr><td class="paramname">bufferName</td><td>Optional debug name for the buffer. A Uuid will automatically be appended to make it unique. If none is specified, a default name will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af63b90d5a2c70cf0e1d78f3174be9e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63b90d5a2c70cf0e1d78f3174be9e74">&#9670;&nbsp;</a></span>CreateSkinningInputBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::Render::SkinnedMeshInputLod::CreateSkinningInputBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkinnedMeshInputVertexStreams&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZStd::string &amp;&#160;</td>
          <td class="paramname"><em>bufferNamePrefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the buffer for the specified inputStream. SetVertexCount must be called first as CreateSkinningInputBuffer depends on that to know the number of vertices to create. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The per-vertex data to use as input. The stride of data is expected to match the SkinnedMeshVertexStreamInfo::elementSize for the given input stream, and the size of the data buffer should be m_vertexCount * elementSize. </td></tr>
    <tr><td class="paramname">inputStream</td><td>The input stream this buffer is used for. SkinnedMeshInputVertexStreams are used for input to the skinning shader. </td></tr>
    <tr><td class="paramname">bufferName</td><td>Optional debug name for the buffer. A Uuid will automatically be appended to make it unique. If none is specified, a default name for the inputStream will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d5f9731aa9f85fe5cf5ca4b5e501802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5f9731aa9f85fe5cf5ca4b5e501802">&#9670;&nbsp;</a></span>CreateStaticBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::Render::SkinnedMeshInputLod::CreateStaticBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkinnedMeshStaticVertexStreams&#160;</td>
          <td class="paramname"><em>staticInputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZStd::string &amp;&#160;</td>
          <td class="paramname"><em>bufferNamePrefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the buffer for the specified staticInputStream. SetVertexCount must be called first as CreateSkinningInputBuffer depends on that to know the number of vertices to create. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The per-vertex data to use as input. The stride of data is expected to match the SkinnedMeshVertexStreamInfo::elementSize for the given input stream, and the size of the data buffer should be m_vertexCount * elementSize. </td></tr>
    <tr><td class="paramname">staticInputStream</td><td>The static input stream this buffer is used for. SkinnedMeshStaticInputVertexStreams are used by the target skinned ModelLod, but are not modified during skinning so they are shared between all instances of the same skinned mesh. </td></tr>
    <tr><td class="paramname">bufferName</td><td>Optional debug name for the buffer. A Uuid will automatically be appended to make it unique. If none is specified, a default name for the staticInputStream will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24711ba523b8562c8cf06cab65bc4c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24711ba523b8562c8cf06cab65bc4c27">&#9670;&nbsp;</a></span>SetSubMeshProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::Render::SkinnedMeshInputLod::SetSubMeshProperties </td>
          <td>(</td>
          <td class="paramtype">const AZStd::vector&lt; <a class="el" href="struct_a_z_1_1_render_1_1_skinned_sub_mesh_properties.html">SkinnedSubMeshProperties</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subMeshProperties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the properties used by each sub-mesh of a target skinned ModelLod and create per-sub-mesh views of the index and static buffers. Since this function is creating buffer views, it must be called after CreateIndexBuffer and CreateStaticBuffer. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 29 2021 11:34:00 for Atom API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
