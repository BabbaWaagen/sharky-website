<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.17" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Atom API Reference: AZ::RHI::FrameScheduler Class Reference</title>
<link href="/css/api-ref/tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="/css/api-ref/doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">Atom API Reference
   </div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div class="navpath" id="nav-path">
<ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><b>RHI</b></li><li class="navelem"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html">FrameScheduler</a></li> </ul>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="class_a_z_1_1_r_h_i_1_1_frame_scheduler-members.html">List of all members</a> </div>
<div class="headertitle">
<div class="title">AZ::RHI::FrameScheduler Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div> </div>
</div><!--header-->
<div class="contents">
<p><code>#include &lt;FrameScheduler.h&gt;</code></p>
<p>Inherits <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_graph_builder.html">AZ::RHI::FrameGraphBuilder</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a417c02963a5e65d3645e4c7b794260ee"><td align="right" class="memItemLeft" valign="top"><a id="a417c02963a5e65d3645e4c7b794260ee"></a>
 </td><td class="memItemRight" valign="bottom"><b>AZ_CLASS_ALLOCATOR</b> (<a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html">FrameScheduler</a>, AZ::SystemAllocator, 0)</td></tr>
<tr class="separator:a417c02963a5e65d3645e4c7b794260ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a25a84d030b4e7a3bba65a222210e6e"><td align="right" class="memItemLeft" valign="top"><a id="a3a25a84d030b4e7a3bba65a222210e6e"></a>
 </td><td class="memItemRight" valign="bottom"><b>FrameScheduler</b> (const <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html">FrameScheduler</a> &amp;)=delete</td></tr>
<tr class="separator:a3a25a84d030b4e7a3bba65a222210e6e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaa07d983389ff6ab61252cb35f5a50fc"><td align="right" class="memItemLeft" valign="top"><a id="aaa07d983389ff6ab61252cb35f5a50fc"></a>
bool </td><td class="memItemRight" valign="bottom"><b>IsInitialized</b> () const</td></tr>
<tr class="separator:aaa07d983389ff6ab61252cb35f5a50fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02330ecb6b6c491d26243209e9795438"><td align="right" class="memItemLeft" valign="top"><a id="a02330ecb6b6c491d26243209e9795438"></a>
ResultCode </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#a02330ecb6b6c491d26243209e9795438">Init</a> (<a class="el" href="class_a_z_1_1_r_h_i_1_1_device.html">Device</a> &amp;device, const <a class="el" href="struct_a_z_1_1_r_h_i_1_1_frame_scheduler_descriptor.html">FrameSchedulerDescriptor</a> &amp;descriptor)</td></tr>
<tr class="memdesc:a02330ecb6b6c491d26243209e9795438"><td class="mdescLeft"> </td><td class="mdescRight">Initializes the frame scheduler and connects it to the buses. <br/></td></tr>
<tr class="separator:a02330ecb6b6c491d26243209e9795438"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afba4653abcb4bbf2afaffa93bd25e542"><td align="right" class="memItemLeft" valign="top"><a id="afba4653abcb4bbf2afaffa93bd25e542"></a>
void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#afba4653abcb4bbf2afaffa93bd25e542">Shutdown</a> ()</td></tr>
<tr class="memdesc:afba4653abcb4bbf2afaffa93bd25e542"><td class="mdescLeft"> </td><td class="mdescRight">Shuts down the frame scheduler. <br/></td></tr>
<tr class="separator:afba4653abcb4bbf2afaffa93bd25e542"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a57d781868ee2be6d498de1e11e5f0dd0"><td align="right" class="memItemLeft" valign="top"><a id="a57d781868ee2be6d498de1e11e5f0dd0"></a>
ResultCode </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#a57d781868ee2be6d498de1e11e5f0dd0">BeginFrame</a> ()</td></tr>
<tr class="memdesc:a57d781868ee2be6d498de1e11e5f0dd0"><td class="mdescLeft"> </td><td class="mdescRight">Begin GPU frame. Any GPU-related operations should occur between this call and EndFrame. <br/></td></tr>
<tr class="separator:a57d781868ee2be6d498de1e11e5f0dd0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af78f7895fdc8818c610d4c8d0d67e6c3"><td align="right" class="memItemLeft" valign="top"><a id="af78f7895fdc8818c610d4c8d0d67e6c3"></a>
ResultCode </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#af78f7895fdc8818c610d4c8d0d67e6c3">EndFrame</a> ()</td></tr>
<tr class="memdesc:af78f7895fdc8818c610d4c8d0d67e6c3"><td class="mdescLeft"> </td><td class="mdescRight">Ends GPU frame. Must be called after Execute if Compile was called. <br/></td></tr>
<tr class="separator:af78f7895fdc8818c610d4c8d0d67e6c3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae5ecd4437cc1379d9f2ed92487b6f419"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_graph_attachment_interface.html">FrameGraphAttachmentInterface</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#ae5ecd4437cc1379d9f2ed92487b6f419">GetAttachmentDatabase</a> () override</td></tr>
<tr class="separator:ae5ecd4437cc1379d9f2ed92487b6f419"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad9f758b6a5920693b1b29cf3f8ddfcb8"><td align="right" class="memItemLeft" valign="top">ResultCode </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#ad9f758b6a5920693b1b29cf3f8ddfcb8">ImportScopeProducer</a> (<a class="el" href="class_a_z_1_1_r_h_i_1_1_scope_producer.html">ScopeProducer</a> &amp;scopeProducer) override</td></tr>
<tr class="separator:ad9f758b6a5920693b1b29cf3f8ddfcb8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e922f41a610283edd0e5b173bd32d69"><td align="right" class="memItemLeft" valign="top">MessageOutcome </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#a4e922f41a610283edd0e5b173bd32d69">Compile</a> (const <a class="el" href="struct_a_z_1_1_r_h_i_1_1_frame_scheduler_compile_request.html">FrameSchedulerCompileRequest</a> &amp;compileRequest)</td></tr>
<tr class="separator:a4e922f41a610283edd0e5b173bd32d69"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae4d183c50ef20e5cb5b13d3b968e9fd6"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#ae4d183c50ef20e5cb5b13d3b968e9fd6">Execute</a> (JobPolicy jobPolicy)</td></tr>
<tr class="separator:ae4d183c50ef20e5cb5b13d3b968e9fd6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed05405b42713f18fa0e9e6961fbd13d"><td align="right" class="memItemLeft" valign="top"><a id="aed05405b42713f18fa0e9e6961fbd13d"></a>
const <a class="el" href="struct_a_z_1_1_r_h_i_1_1_transient_attachment_statistics.html">TransientAttachmentStatistics</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#aed05405b42713f18fa0e9e6961fbd13d">GetTransientAttachmentStatistics</a> () const</td></tr>
<tr class="memdesc:aed05405b42713f18fa0e9e6961fbd13d"><td class="mdescLeft"> </td><td class="mdescRight">Returns the timing statistics for the previous frame. <br/></td></tr>
<tr class="separator:aed05405b42713f18fa0e9e6961fbd13d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a62c2986e7d63a92f7193e5c7ccc69d8b"><td align="right" class="memItemLeft" valign="top"><a id="a62c2986e7d63a92f7193e5c7ccc69d8b"></a>
const <a class="el" href="struct_a_z_1_1_r_h_i_1_1_cpu_timing_statistics.html">CpuTimingStatistics</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#a62c2986e7d63a92f7193e5c7ccc69d8b">GetCpuTimingStatistics</a> () const</td></tr>
<tr class="memdesc:a62c2986e7d63a92f7193e5c7ccc69d8b"><td class="mdescLeft"> </td><td class="mdescRight">Returns cpu timing statistics for the previous frame. <br/></td></tr>
<tr class="separator:a62c2986e7d63a92f7193e5c7ccc69d8b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5259075fd43e05b99af5743d202b787d"><td align="right" class="memItemLeft" valign="top"><a id="a5259075fd43e05b99af5743d202b787d"></a>
const <a class="el" href="struct_a_z_1_1_r_h_i_1_1_memory_statistics.html">MemoryStatistics</a> * </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#a5259075fd43e05b99af5743d202b787d">GetMemoryStatistics</a> () const</td></tr>
<tr class="memdesc:a5259075fd43e05b99af5743d202b787d"><td class="mdescLeft"> </td><td class="mdescRight">Returns memory statistics for the previous frame. <br/></td></tr>
<tr class="separator:a5259075fd43e05b99af5743d202b787d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9ec8cdddbc2c01bb92759921d88ca44a"><td align="right" class="memItemLeft" valign="top"><a id="a9ec8cdddbc2c01bb92759921d88ca44a"></a>
ScopeId </td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#a9ec8cdddbc2c01bb92759921d88ca44a">GetRootScopeId</a> () const</td></tr>
<tr class="memdesc:a9ec8cdddbc2c01bb92759921d88ca44a"><td class="mdescLeft"> </td><td class="mdescRight">Returns the implicit root scope id. <br/></td></tr>
<tr class="separator:a9ec8cdddbc2c01bb92759921d88ca44a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b872e06caf789e68ee6ea0de95e28c9"><td align="right" class="memItemLeft" valign="top"><a id="a7b872e06caf789e68ee6ea0de95e28c9"></a>
const <a class="el" href="struct_a_z_1_1_r_h_i_1_1_transient_attachment_pool_descriptor.html">TransientAttachmentPoolDescriptor</a> * </td><td class="memItemRight" valign="bottom"><b>GetTransientAttachmentPoolDescriptor</b> () const</td></tr>
<tr class="separator:a7b872e06caf789e68ee6ea0de95e28c9"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>== Overview ==</p>
<p>The frame scheduler is a system for facilitating efficient GPU work submission. It provides a user-facing API for preparing (constructing), compiling, and executing a frame graph. The graph provides knowledge of the whole frame and is processed through phases down to platform-specific actions. Because the graph is known up front, hazard tracking, memory aliasing, and cross-queue synchronization become much simpler problems. The frame becomes fully deterministic.</p>
<p>The graph is constructed from ScopeProducers–user overridden classes which declare information to the graph. ScopeProducers own and maintain a <a class="el" href="class_a_z_1_1_r_h_i_1_1_scope.html">Scope</a>, which contains the generated graph node data. <a class="el" href="class_a_z_1_1_r_h_i_1_1_scope_producer.html">ScopeProducer</a> is overridden by the end-user (feature author), while <a class="el" href="class_a_z_1_1_r_h_i_1_1_scope.html">Scope</a> is overridden by the internal platform implementation. Effectively, scopes contain private data, while ScopeProducers are public producers of that data.</p>
<p>In addition to scopes, the frame graph supports attachments. An attachment is effectively some metadata around a buffer / image resource which tracks its usage across all scopes in a frame. This usage is vital for controlling low-level resource transitions or memory aliasing on the GPU.</p>
<p><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html">FrameScheduler</a> delegates most of the heavy lifting to the <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_graph_compiler.html">FrameGraphCompiler</a> and <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_graph_executer.html">FrameGraphExecuter</a> classes, which are the platform-overridden interfaces for graph construction / execution, respectively. It effectively ties everything together by owning the frame graph and all the necessary sub-components. The class also facilitates jobification of command list recording.</p>
<p>== Usage ==</p>
<p>To use the frame scheduler: 1) Instantiate a <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html">FrameScheduler</a> instance with a valid RHI device. 2) Override and instantiate ScopeProducers. 3) Once per frame: 3.1) Call <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#a57d781868ee2be6d498de1e11e5f0dd0" title="Begin GPU frame. Any GPU-related operations should occur between this call and EndFrame.">BeginFrame()</a>. 3.2) Import ScopeProducers with ImportScopeProducer. You may also directly import / create attachments via GetAttachmentDatabase. 3.3) Call Compile (and validate the return code). 3.4) Call Execute (and validate the return code). 3.5) Call <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html#af78f7895fdc8818c610d4c8d0d67e6c3" title="Ends GPU frame. Must be called after Execute if Compile was called.">EndFrame()</a> to complete execution.</p>
<p>== Statistics ==</p>
<p>Statistics may be gathered for a frame after EndFrame completes. The following statistics are reported: 1) Transient attachment usages with scope timeline. This data represents a grid where one axis is the scope execution order for the current frame, and the other axis is the internal aliased heap (i.e. starting at 0 bytes). The grid communicates the start and end points for each attachment. This data is useful when visualized to show overlap between attachments. 2) GPU timing information of each scope for each queue. GPU timing accuracy depends on the platform; certain platforms (like mobile) do not have a way to extract exact GPU timings. Thus, they may instead represent approximations. 3) GPU memory usage across the RHI associated with the device.</p>
<p>The platform may or may not publish this information. If not, the method will return a null pointer.</p>
<p>== Pool Resolves ==</p>
<p><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_scheduler.html">FrameScheduler</a> contains a single "root" Graphics scope which is always the first scope added to the graph. All subsequent scopes take on a dependency to this root scope. The reason for this is twofold: 1) <a class="el" href="class_a_z_1_1_r_h_i_1_1_resource_pool.html">ResourcePool</a> implementations need a scope to perform resolves (DMA uploads) to GPU memory. These operations occur first in the frame to avoid complicating pool / scope dependencies. Hence, this is done synchronously on the Graphics queue. 2) To make resource transitions and aliasing easier, the first scope in an attachment chain should be a Graphics scope. The root scope guarantees this to be true for any scenario.</p>
<p>== Restrictions ==</p>
<p>Currently, only a one frame scheduler instance is supported. This restriction can be lifted if the ResourceEventBus is replaced with a non-singleton queue data structure. Currently, it is only possible to flush this queue globally, which is incompatible with multiple frame schedulers. See [LY-83241] for more information. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4e922f41a610283edd0e5b173bd32d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e922f41a610283edd0e5b173bd32d69">◆ </a></span>Compile()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">MessageOutcome AZ::RHI::FrameScheduler::Compile </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="struct_a_z_1_1_r_h_i_1_1_frame_scheduler_compile_request.html">FrameSchedulerCompileRequest</a> &amp; </td>
<td class="paramname"><em>compileRequest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compiles the schedule. This should be called after successive calls to RegisterScope, and before calling Execute. </p>
</div>
</div>
<a id="ae4d183c50ef20e5cb5b13d3b968e9fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d183c50ef20e5cb5b13d3b968e9fd6">◆ </a></span>Execute()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void AZ::RHI::FrameScheduler::Execute </td>
<td>(</td>
<td class="paramtype">JobPolicy </td>
<td class="paramname"><em>jobPolicy</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Executes the compiled schedule. Must be called after Compile. This will jobify recording and of command lists associated with each scope in the dependency graph. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">jobPolicy</td><td>The global job policy for the current frame. If serial, it will force serial execution even if the platform supports parallel dispatch. If parallel, it will defer to the platform for parallel dispatch support. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ae5ecd4437cc1379d9f2ed92487b6f419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ecd4437cc1379d9f2ed92487b6f419">◆ </a></span>GetAttachmentDatabase()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_graph_attachment_interface.html">FrameGraphAttachmentInterface</a> AZ::RHI::FrameScheduler::GetAttachmentDatabase </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the frame graph attachment builder, which allows the user to declare global attachments. </p>
<p>Implements <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_graph_builder.html#a207254adfc0b903e3514c6ccccb332d0">AZ::RHI::FrameGraphBuilder</a>.</p>
</div>
</div>
<a id="ad9f758b6a5920693b1b29cf3f8ddfcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f758b6a5920693b1b29cf3f8ddfcb8">◆ </a></span>ImportScopeProducer()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">ResultCode AZ::RHI::FrameScheduler::ImportScopeProducer </td>
<td>(</td>
<td class="paramtype"><a class="el" href="class_a_z_1_1_r_h_i_1_1_scope_producer.html">ScopeProducer</a> &amp; </td>
<td class="paramname"><em>scopeProducer</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Imports a scope producer into the frame graph. <a class="el" href="class_a_z_1_1_r_h_i_1_1_scope.html">Scope</a> producers are prepared in the order they are imported, however the compile phase runs a topological sort based on the attachment and explicit scope dependencies. </p>
<p>Implements <a class="el" href="class_a_z_1_1_r_h_i_1_1_frame_graph_builder.html#adbef3a5c92fd00f928eb7f5be263dc93">AZ::RHI::FrameGraphBuilder</a>.</p>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 14 2021 13:11:02 for Atom API Reference by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="/images/api-ref/doxygen.png"/>
</a> 1.8.17
</small></address>
</body>
</html>
