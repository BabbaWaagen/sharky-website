<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine EMotionFX Gem API Reference: MCore::HaltonSequence Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">23.05.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_core_1_1_halton_sequence.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_core_1_1_halton_sequence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MCore::HaltonSequence Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Random.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a266c1b041ad557aded67e54bab42dae7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a266c1b041ad557aded67e54bab42dae7">HaltonSequence</a> ()</td></tr>
<tr class="separator:a266c1b041ad557aded67e54bab42dae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1c3727802a33a74f0bad9fa5351b67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#add1c3727802a33a74f0bad9fa5351b67">HaltonSequence</a> (uint32 dimensions, uint32 offset=0, uint32 *primes=nullptr)</td></tr>
<tr class="separator:add1c3727802a33a74f0bad9fa5351b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c07a7cd837359a6a5335fb37e2dec6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#ae3c07a7cd837359a6a5335fb37e2dec6">~HaltonSequence</a> ()</td></tr>
<tr class="separator:ae3c07a7cd837359a6a5335fb37e2dec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a8f64bbde7a71b559ba5476fd12fcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a65a8f64bbde7a71b559ba5476fd12fcd">Init</a> (uint32 dimensions, uint32 offset=0, uint32 *primes=nullptr)</td></tr>
<tr class="separator:a65a8f64bbde7a71b559ba5476fd12fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fd2152e6027065aeba7504584f40eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a72fd2152e6027065aeba7504584f40eb">Release</a> ()</td></tr>
<tr class="separator:a72fd2152e6027065aeba7504584f40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa271c38f8aeb628113905aba1272d6c4"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#aa271c38f8aeb628113905aba1272d6c4">GetNumDimensions</a> () const </td></tr>
<tr class="separator:aa271c38f8aeb628113905aba1272d6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6202aca2cae356b2455eed099cea1ce5"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a6202aca2cae356b2455eed099cea1ce5">GetMemoryUsage</a> () const </td></tr>
<tr class="separator:a6202aca2cae356b2455eed099cea1ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6809fe1caf8a316c3917267653bfa63c"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a6809fe1caf8a316c3917267653bfa63c">GetVectorNumber</a> () const </td></tr>
<tr class="separator:a6809fe1caf8a316c3917267653bfa63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa6e25d858e92a01251abf57e25d79d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a2fa6e25d858e92a01251abf57e25d79d">GetNextDimension</a> ()</td></tr>
<tr class="separator:a2fa6e25d858e92a01251abf57e25d79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7682235ed84e54418cc3ff966befdf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#af7682235ed84e54418cc3ff966befdf2">ResetNextDimension</a> ()</td></tr>
<tr class="separator:af7682235ed84e54418cc3ff966befdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935a4712751ec4736e29c521e0b7a9df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a935a4712751ec4736e29c521e0b7a9df">Restart</a> ()</td></tr>
<tr class="separator:a935a4712751ec4736e29c521e0b7a9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296e7675b09a26a6b54c97c64694ccaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a296e7675b09a26a6b54c97c64694ccaa">Next</a> ()</td></tr>
<tr class="separator:a296e7675b09a26a6b54c97c64694ccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3adb10c73e367c18b7535d8ec7ec8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a4f3adb10c73e367c18b7535d8ec7ec8a">SetInstance</a> (uint32 instance)</td></tr>
<tr class="separator:a4f3adb10c73e367c18b7535d8ec7ec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b104cb0031dbe0821012783c2814c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#a87b104cb0031dbe0821012783c2814c8">operator++</a> ()</td></tr>
<tr class="separator:a87b104cb0031dbe0821012783c2814c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5821aa7bf0d3ff4e66d3fe5b27124d9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_halton_sequence.html#af5821aa7bf0d3ff4e66d3fe5b27124d9">operator[]</a> (uint32 j) const </td></tr>
<tr class="separator:af5821aa7bf0d3ff4e66d3fe5b27124d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Halton Sequence class. Halton sequences are pseudo random numbers, actually known as Quasi <a class="el" href="class_m_core_1_1_random.html">Random</a> Numbers. They are often used in Monte Carlo sampling methods, because they are very good for that, especially for higher dimensions. The generated numbers are always the same. You can however add some real randomness to it to let the random numbers you get start at a given random offset (instance). The values generated try to keep an as large as possible distance between eachother, to prevent groups of points very close to eachother at some spots. This is one of the reasons why they are so cool. They work basically the same as stratisfied sampling your values, but with the nice feature that you do not have to know upfront how many random numbers you will need. So you can keep asking for the next value in the set. The values returned by the sequence are in range of [0..1]. If for example you want to generate random points in a 2D box, you can create a two dimensional <a class="el" href="class_m_core_1_1_halton_sequence.html">HaltonSequence</a>. Let me demonstrate with some example code: </p>
<pre></pre><pre>// create a two dimensional Halton sequence
<a class="el" href="class_m_core_1_1_halton_sequence.html">HaltonSequence</a> seq(2);</pre><pre>// generate 100 random points inside the 1x1 unit 2D box.
for (uint32 i=0; i&lt;100; i++)
{
   float x = seq[0];
   float y = seq[1];
   seq.Next();
}</pre><pre></pre><p> You now might want to ask, why not just use the <a class="el" href="class_m_core_1_1_random.html#a17fdcb872df663cf1d07df9b94b9fc14">Random::RandF()</a> function for this? Well, the answer is that the distribution of the samples is much more evenly with the Halton sequences as with just normal random numbers using <a class="el" href="class_m_core_1_1_random.html#a17fdcb872df663cf1d07df9b94b9fc14">Random::RandF()</a>. When not using <a class="el" href="class_m_core_1_1_random.html#a17fdcb872df663cf1d07df9b94b9fc14">Random::RandF()</a> you can get areas where there are more points as in other areas, so no even distribution. This can lead to variance in estimates using random values. HaltonSequences converge much faster, so result in a more accurate estimate. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a266c1b041ad557aded67e54bab42dae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCore::HaltonSequence::HaltonSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default constructor. Be sure to call the Init(...) method before using any other methods of this class. </p>

</div>
</div>
<a class="anchor" id="add1c3727802a33a74f0bad9fa5351b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCore::HaltonSequence::HaltonSequence </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>primes</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extended constructor. This constructor automatically calls the Init method. Please keep in mind that MCore needs to be initialized before doing this, so if you have a global <a class="el" href="class_m_core_1_1_halton_sequence.html">HaltonSequence</a> object that uses this constructor, this will cause a crash. In that case, use the Init method with the default constructor that takes no parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>The number of dimensions for the sequence. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the sequence. </td></tr>
    <tr><td class="paramname">primes</td><td>The list of prime values. Keep this nullptr when you want to generate them automatically. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3c07a7cd837359a6a5335fb37e2dec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCore::HaltonSequence::~HaltonSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6202aca2cae356b2455eed099cea1ce5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MCore::HaltonSequence::GetMemoryUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the memory usage in bytes by this sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>The memory usage in bytes by this sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fa6e25d858e92a01251abf57e25d79d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MCore::HaltonSequence::GetNextDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value of current dimension, and go to the next dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the current dimension, and step to the next dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="aa271c38f8aeb628113905aba1272d6c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MCore::HaltonSequence::GetNumDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of dimensions in the sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dimensions. </dd></dl>

</div>
</div>
<a class="anchor" id="a6809fe1caf8a316c3917267653bfa63c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 MCore::HaltonSequence::GetVectorNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current vector number. </p>
<dl class="section return"><dt>Returns</dt><dd>The vector number. </dd></dl>

</div>
</div>
<a class="anchor" id="a65a8f64bbde7a71b559ba5476fd12fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::HaltonSequence::Init </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>primes</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the sequence. You can also call the Init method multiple times with different parameters to change its settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>The number of dimensions for the sequence. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the sequence. </td></tr>
    <tr><td class="paramname">primes</td><td>The list of prime values. Keep this nullptr when you want to generate them automatically. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a296e7675b09a26a6b54c97c64694ccaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::HaltonSequence::Next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the next values in the sequence. So update the dimension values. </p>

</div>
</div>
<a class="anchor" id="a87b104cb0031dbe0821012783c2814c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::HaltonSequence::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next values in the sequence. So update the dimension values. </p>

</div>
</div>
<a class="anchor" id="af5821aa7bf0d3ff4e66d3fe5b27124d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MCore::HaltonSequence::operator[] </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a value for a given dimension. (*sequence[0]) would be the value of the first dimension and (*sequence[1]) would be the value of the second dimension, etc. </p>

</div>
</div>
<a class="anchor" id="a72fd2152e6027065aeba7504584f40eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::HaltonSequence::Release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all allocated memory. This is automatically called by the destructor. </p>

</div>
</div>
<a class="anchor" id="af7682235ed84e54418cc3ff966befdf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::HaltonSequence::ResetNextDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the dimension stepping (by <a class="el" href="class_m_core_1_1_halton_sequence.html#a2fa6e25d858e92a01251abf57e25d79d">GetNextDimension()</a>) and go to the first dimension again. </p>

</div>
</div>
<a class="anchor" id="a935a4712751ec4736e29c521e0b7a9df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::HaltonSequence::Restart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restart the sequence. </p>

</div>
</div>
<a class="anchor" id="a4f3adb10c73e367c18b7535d8ec7ec8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::HaltonSequence::SetInstance </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the instance in the sequence. So the startpoint/offset in the sequence, where 0 would jump to the beginning again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance value, so the startpoint in the sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/EMotionFX/Code/MCore/Source/Random.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>MCore</b></li><li class="navelem"><a class="el" href="class_m_core_1_1_halton_sequence.html">HaltonSequence</a></li>
    <li class="footer">Generated on Thu Apr 20 2023 21:15:46 for Open 3D Engine EMotionFX Gem API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
