<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine EMotionFX Gem API Reference: MCore::PlaneEq Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">23.05.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_core_1_1_plane_eq.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_core_1_1_plane_eq-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MCore::PlaneEq Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;PlaneEq.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa05eb6c8e5f8463f7623bbe1f28b6483"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#aa05eb6c8e5f8463f7623bbe1f28b6483">EPlane</a> { <a class="el" href="class_m_core_1_1_plane_eq.html#aa05eb6c8e5f8463f7623bbe1f28b6483a73ee0bd152a119ca74c8a1d718e53fda">PLANE_XY</a> = 0, 
<a class="el" href="class_m_core_1_1_plane_eq.html#aa05eb6c8e5f8463f7623bbe1f28b6483a6ffc032c94a1baf6014ef2568a4e7955">PLANE_XZ</a> = 1, 
<a class="el" href="class_m_core_1_1_plane_eq.html#aa05eb6c8e5f8463f7623bbe1f28b6483ac98c3e26645bbb37b58932021618c4e8">PLANE_YZ</a> = 2
 }</td></tr>
<tr class="separator:aa05eb6c8e5f8463f7623bbe1f28b6483"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78a66c48303b7f54e458acfcf5558ac6"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a78a66c48303b7f54e458acfcf5558ac6">PlaneEq</a> ()</td></tr>
<tr class="separator:a78a66c48303b7f54e458acfcf5558ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a74207f71626c5b455b2ca1bedb0c99"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a5a74207f71626c5b455b2ca1bedb0c99">PlaneEq</a> (const AZ::Vector3 &amp;norm, const AZ::Vector3 &amp;pnt)</td></tr>
<tr class="separator:a5a74207f71626c5b455b2ca1bedb0c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e726419b07191b16a2b46748bea80f6"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a2e726419b07191b16a2b46748bea80f6">PlaneEq</a> (const AZ::Vector3 &amp;norm, float d)</td></tr>
<tr class="separator:a2e726419b07191b16a2b46748bea80f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dd003467270d078a2d69da73c09fa9"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#ac5dd003467270d078a2d69da73c09fa9">PlaneEq</a> (const AZ::Vector3 &amp;v1, const AZ::Vector3 &amp;v2, const AZ::Vector3 &amp;v3)</td></tr>
<tr class="separator:ac5dd003467270d078a2d69da73c09fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35947a5c0121108d7561c02b463c057f"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_m_core_1_1_plane_eq.html#aa05eb6c8e5f8463f7623bbe1f28b6483">EPlane</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a35947a5c0121108d7561c02b463c057f">CalcDominantPlane</a> () const </td></tr>
<tr class="separator:a35947a5c0121108d7561c02b463c057f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372c6ee0ce7da3561501cf39ac84a2c9"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a372c6ee0ce7da3561501cf39ac84a2c9">CalcDistanceTo</a> (const AZ::Vector3 &amp;v) const </td></tr>
<tr class="separator:a372c6ee0ce7da3561501cf39ac84a2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2fa7a3ba07fae1b2aa055e1aaedd1f"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a6b2fa7a3ba07fae1b2aa055e1aaedd1f">Construct</a> (const AZ::Vector3 &amp;normal, const AZ::Vector3 &amp;pointOnPlane)</td></tr>
<tr class="separator:a6b2fa7a3ba07fae1b2aa055e1aaedd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9c438f048953217f151c40479a2954"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#aea9c438f048953217f151c40479a2954">Construct</a> (const AZ::Vector3 &amp;normal, float d)</td></tr>
<tr class="separator:aea9c438f048953217f151c40479a2954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1209d4dde3bf7ede7f4e0bea550cbb68"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a1209d4dde3bf7ede7f4e0bea550cbb68">Construct</a> (const AZ::Vector3 &amp;v1, const AZ::Vector3 &amp;v2, const AZ::Vector3 &amp;v3)</td></tr>
<tr class="separator:a1209d4dde3bf7ede7f4e0bea550cbb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be92ce2a5b4b2de9a7fb964cb8d831d"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const AZ::Vector3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a8be92ce2a5b4b2de9a7fb964cb8d831d">GetNormal</a> () const </td></tr>
<tr class="separator:a8be92ce2a5b4b2de9a7fb964cb8d831d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3108a39289c2e33d4ef79b9a7d6ff3d"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#ad3108a39289c2e33d4ef79b9a7d6ff3d">GetDist</a> () const </td></tr>
<tr class="separator:ad3108a39289c2e33d4ef79b9a7d6ff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a6f990ba8a699d9b4eea0948c3d5cb"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE AZ::Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_plane_eq.html#a20a6f990ba8a699d9b4eea0948c3d5cb">Project</a> (const AZ::Vector3 &amp;vectorToProject)</td></tr>
<tr class="separator:a20a6f990ba8a699d9b4eea0948c3d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Plane Equation template. This represents an infinite plane, which is mathematically represented by the following equation: Ax + By + Cz + d = 0. Where ABC is the XYZ of the planes normal and where xyz is a point on the plane. The value d is a constant value, which is precalculated. Now if we put a random point inside this equation, when we already know the normal and the value for d, we can see if the result of Ax + By + Cz + d is 0 or not. If it is 0, this means the point is on the plane. We can also use this to calculate on what side of the plane a point is. This is for example used for constructing BSP trees. So, from this we can conclude that the result of (normal.Dot(point) + d) is the distance from point to the plane, along the planes normal. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aa05eb6c8e5f8463f7623bbe1f28b6483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_m_core_1_1_plane_eq.html#aa05eb6c8e5f8463f7623bbe1f28b6483">MCore::PlaneEq::EPlane</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Axis aligned planes. Used to determine the most dominant axis, which can be used for planar mapping. This is for example used to generate the texture coordinates for lightmaps. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa05eb6c8e5f8463f7623bbe1f28b6483a73ee0bd152a119ca74c8a1d718e53fda"></a>PLANE_XY</em>&nbsp;</td><td class="fielddoc">
<p>The XY plane, so where Z is constant. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa05eb6c8e5f8463f7623bbe1f28b6483a6ffc032c94a1baf6014ef2568a4e7955"></a>PLANE_XZ</em>&nbsp;</td><td class="fielddoc">
<p>The XZ plane, so where Y is constant. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa05eb6c8e5f8463f7623bbe1f28b6483ac98c3e26645bbb37b58932021618c4e8"></a>PLANE_YZ</em>&nbsp;</td><td class="fielddoc">
<p>The YZ plane, so where X is constant. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a78a66c48303b7f54e458acfcf5558ac6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::PlaneEq::PlaneEq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default constructor. Does not initialize anything. So this does not result in a usable/valid plane. </p>

</div>
</div>
<a class="anchor" id="a5a74207f71626c5b455b2ca1bedb0c99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::PlaneEq::PlaneEq </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>pnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor when you know the normal of the plane and a point on the plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>The normal of the plane. </td></tr>
    <tr><td class="paramname">pnt</td><td>A point on the plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e726419b07191b16a2b46748bea80f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::PlaneEq::PlaneEq </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor when you know the normal and the value of d out of the plane equation (Ax + By + Cz + d = 0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>The normal of the plane </td></tr>
    <tr><td class="paramname">d</td><td>The value of 'd' out of the plane equation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5dd003467270d078a2d69da73c09fa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::PlaneEq::PlaneEq </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor when you know 3 points on the plane (the winding matters here (clockwise vs counter-clockwise) The normal will be calculated as ((v2-v1).Cross(v3-v1)).Normalize(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first point on the plane. </td></tr>
    <tr><td class="paramname">v2</td><td>The second point on the plane. </td></tr>
    <tr><td class="paramname">v3</td><td>The third point on the plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a372c6ee0ce7da3561501cf39ac84a2c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE float MCore::PlaneEq::CalcDistanceTo </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the distance of a given point to the plane, along the normal. A mathematical explanation of how this is done can be read in the description of this template/class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector representing the 3D point to use for the calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance from 'v' to this plane, along the normal of this plane. </dd></dl>

</div>
</div>
<a class="anchor" id="a35947a5c0121108d7561c02b463c057f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_m_core_1_1_plane_eq.html#aa05eb6c8e5f8463f7623bbe1f28b6483">EPlane</a> MCore::PlaneEq::CalcDominantPlane </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates and returns the dominant plane. A dominant plane is an axis aligned plane, so it can be 3 types of planes, one for each axis. The way this is calculated is by looking at the normal of the plane, and looking which axis of the normal is the most dominant. Based on this, corresponding axis aligned plane, can be returned. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the type of axis aligned plane. This can be aligned to the XY, XZ or YZ plane. See EPlane for the plane types. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b2fa7a3ba07fae1b2aa055e1aaedd1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::PlaneEq::Construct </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>pointOnPlane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the plane when the normal of the plane and a point on the plane are known. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>The normal of the plane. </td></tr>
    <tr><td class="paramname">pointOnPlane</td><td>A point on the plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea9c438f048953217f151c40479a2954"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::PlaneEq::Construct </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the plane when the normal of the plane is known, as well as the value of 'd' in the plane equation (Ax + By + Cz + d = 0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>The normal of the plane. </td></tr>
    <tr><td class="paramname">d</td><td>The value of 'd' in the above mentioned plane equation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1209d4dde3bf7ede7f4e0bea550cbb68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::PlaneEq::Construct </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the plane when you know three points on the plane. The winding of the vertices matters (clockwise vs counter-clockwise). The normal is calculated as ((v2-v1).Cross(v3-v1)).Normalize() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first point on the plane. </td></tr>
    <tr><td class="paramname">v2</td><td>The second point on the plane. </td></tr>
    <tr><td class="paramname">v3</td><td>The third point on the plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3108a39289c2e33d4ef79b9a7d6ff3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE float MCore::PlaneEq::GetDist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the 'd' out of the plane equation (Ax + By + Cz + d = 0). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the 'd' from the plane equation. </dd></dl>

</div>
</div>
<a class="anchor" id="a8be92ce2a5b4b2de9a7fb964cb8d831d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const AZ::Vector3&amp; MCore::PlaneEq::GetNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the normal of the plane. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the normal of the plane. </dd></dl>

</div>
</div>
<a class="anchor" id="a20a6f990ba8a699d9b4eea0948c3d5cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE AZ::Vector3 MCore::PlaneEq::Project </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>vectorToProject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Project a vector onto the plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectorToProject</td><td>The vector you wish to project onto the plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projected vector. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/EMotionFX/Code/MCore/Source/PlaneEq.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>MCore</b></li><li class="navelem"><a class="el" href="class_m_core_1_1_plane_eq.html">PlaneEq</a></li>
    <li class="footer">Generated on Thu Apr 20 2023 21:15:46 for Open 3D Engine EMotionFX Gem API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
