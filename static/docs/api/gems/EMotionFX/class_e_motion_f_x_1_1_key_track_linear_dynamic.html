<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine EMotionFX Gem API Reference: EMotionFX::KeyTrackLinearDynamic&lt; ReturnType, StorageType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">23.05.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_e_motion_f_x_1_1_key_track_linear_dynamic.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_e_motion_f_x_1_1_key_track_linear_dynamic-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EMotionFX::KeyTrackLinearDynamic&lt; ReturnType, StorageType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;KeyTrackLinearDynamic.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1a73d000d62ea89a7f3bbb10411882b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1a73d000d62ea89a7f3bbb10411882b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_TYPE_INFO_WITH_NAME</b> (<a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">KeyTrackLinearDynamic</a>,&quot;EMotionFX::KeyTrackLinear&quot;,&quot;{8C6EB52A-9720-467B-9D96-B4B967A113D1}&quot;, StorageType)</td></tr>
<tr class="separator:ab1a73d000d62ea89a7f3bbb10411882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ccb24256ddcdd18ad1ef54ddbe4311"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a57ccb24256ddcdd18ad1ef54ddbe4311">KeyTrackLinearDynamic</a> (size_t nrKeys)</td></tr>
<tr class="separator:a57ccb24256ddcdd18ad1ef54ddbe4311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434ba43b4f697204107fbcd08dc16916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a434ba43b4f697204107fbcd08dc16916">Reserve</a> (size_t numKeys)</td></tr>
<tr class="separator:a434ba43b4f697204107fbcd08dc16916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c4b04714a0047f1de3c66d8c273e1b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a63c4b04714a0047f1de3c66d8c273e1b">CalcMemoryUsage</a> (bool includeMembers=true) const </td></tr>
<tr class="separator:a63c4b04714a0047f1de3c66d8c273e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954bc26b47aa11ccd16acfcabe561a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a954bc26b47aa11ccd16acfcabe561a8e">Init</a> ()</td></tr>
<tr class="separator:a954bc26b47aa11ccd16acfcabe561a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fda4ad044a325fe35d7a61b7cc9ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#aa0fda4ad044a325fe35d7a61b7cc9ec8">Shrink</a> ()</td></tr>
<tr class="separator:aa0fda4ad044a325fe35d7a61b7cc9ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fea7e5d3ed97ce5e12a9b8d5b99ff9"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a09fea7e5d3ed97ce5e12a9b8d5b99ff9">Interpolate</a> (size_t startKey, float currentTime) const </td></tr>
<tr class="separator:a09fea7e5d3ed97ce5e12a9b8d5b99ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa08aa163d8b0049a46971b0756673a9"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#aaa08aa163d8b0049a46971b0756673a9">AddKey</a> (float time, const ReturnType &amp;value, bool smartPreAlloc=true)</td></tr>
<tr class="separator:aaa08aa163d8b0049a46971b0756673a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d736bd5031165baff4b9f786fa0387"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a62d736bd5031165baff4b9f786fa0387">AddKeySorted</a> (float time, const ReturnType &amp;value, bool smartPreAlloc=true)</td></tr>
<tr class="separator:a62d736bd5031165baff4b9f786fa0387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7481c699db10d0b5c2cae5e7233bce4c"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a7481c699db10d0b5c2cae5e7233bce4c">RemoveKey</a> (size_t keyNr)</td></tr>
<tr class="separator:a7481c699db10d0b5c2cae5e7233bce4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e414bf6a942cbd6afb9d2887acda0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a13e414bf6a942cbd6afb9d2887acda0c">ClearKeys</a> ()</td></tr>
<tr class="separator:a13e414bf6a942cbd6afb9d2887acda0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97863bc9acf093446cdfec236b247383"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a97863bc9acf093446cdfec236b247383">CheckIfIsAnimated</a> (const ReturnType &amp;initialPose, float maxError) const </td></tr>
<tr class="separator:a97863bc9acf093446cdfec236b247383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d20207257f1573a44eb7fd94b444ae"><td class="memItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a58d20207257f1573a44eb7fd94b444ae">GetValueAtTime</a> (float currentTime, size_t *cachedKey=nullptr, uint8 *outWasCacheHit=nullptr, bool interpolate=true) const </td></tr>
<tr class="separator:a58d20207257f1573a44eb7fd94b444ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1941f587b7b0a76b2964bd4f3737f6c0"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a><br class="typebreak"/>
&lt; ReturnType, StorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a1941f587b7b0a76b2964bd4f3737f6c0">GetKey</a> (size_t nr)</td></tr>
<tr class="separator:a1941f587b7b0a76b2964bd4f3737f6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb3203f786883e1dd23e70b69be5fbf"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a><br class="typebreak"/>
&lt; ReturnType, StorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#aefb3203f786883e1dd23e70b69be5fbf">GetFirstKey</a> ()</td></tr>
<tr class="separator:aefb3203f786883e1dd23e70b69be5fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123778a8441cb62c989f4fa95bf24990"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a><br class="typebreak"/>
&lt; ReturnType, StorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a123778a8441cb62c989f4fa95bf24990">GetLastKey</a> ()</td></tr>
<tr class="separator:a123778a8441cb62c989f4fa95bf24990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b9b72a526510369ffdf8dbe5274ff9"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a><br class="typebreak"/>
&lt; ReturnType, StorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#ae8b9b72a526510369ffdf8dbe5274ff9">GetKey</a> (size_t nr) const </td></tr>
<tr class="separator:ae8b9b72a526510369ffdf8dbe5274ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac408475642460326e98fa81a2c74b38f"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a><br class="typebreak"/>
&lt; ReturnType, StorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#ac408475642460326e98fa81a2c74b38f">GetFirstKey</a> () const </td></tr>
<tr class="separator:ac408475642460326e98fa81a2c74b38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370031370822eda4ac4a57d103ef5ba8"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a><br class="typebreak"/>
&lt; ReturnType, StorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a370031370822eda4ac4a57d103ef5ba8">GetLastKey</a> () const </td></tr>
<tr class="separator:a370031370822eda4ac4a57d103ef5ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f8bcc65f50aba1efea7fa1c2a0b988"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#aa7f8bcc65f50aba1efea7fa1c2a0b988">GetFirstTime</a> () const </td></tr>
<tr class="separator:aa7f8bcc65f50aba1efea7fa1c2a0b988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eb59cb858b3e2d0851012e523607c3"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#ac0eb59cb858b3e2d0851012e523607c3">GetLastTime</a> () const </td></tr>
<tr class="separator:ac0eb59cb858b3e2d0851012e523607c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c06f473cc61e5e5004977e0fb878dd"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a91c06f473cc61e5e5004977e0fb878dd">GetNumKeys</a> () const </td></tr>
<tr class="separator:a91c06f473cc61e5e5004977e0fb878dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516cd6f4f824381c423beb606e85641d"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a><br class="typebreak"/>
&lt; ReturnType, StorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a516cd6f4f824381c423beb606e85641d">FindKey</a> (float curTime) const </td></tr>
<tr class="separator:a516cd6f4f824381c423beb606e85641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee49a3f819317dd05727d4684794fcc"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a4ee49a3f819317dd05727d4684794fcc">FindKeyNumber</a> (float curTime) const </td></tr>
<tr class="separator:a4ee49a3f819317dd05727d4684794fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c0216afffbbf0fdafd4980e416c78f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a89c0216afffbbf0fdafd4980e416c78f">MakeLoopable</a> (float fadeTime=0.3f)</td></tr>
<tr class="separator:a89c0216afffbbf0fdafd4980e416c78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d76c128f5d43a85257ebc9cc5a6a0b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a9d76c128f5d43a85257ebc9cc5a6a0b8">Optimize</a> (float maxError)</td></tr>
<tr class="separator:a9d76c128f5d43a85257ebc9cc5a6a0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4defbaed677d10ebf40bd5875f62f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#ab4defbaed677d10ebf40bd5875f62f69">SetNumKeys</a> (size_t numKeys)</td></tr>
<tr class="separator:ab4defbaed677d10ebf40bd5875f62f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e031da84cad0884e60eebe536d7685"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a29e031da84cad0884e60eebe536d7685">SetKey</a> (size_t keyNr, float time, const ReturnType &amp;value)</td></tr>
<tr class="separator:a29e031da84cad0884e60eebe536d7685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf186e428de2cb335e56a90245c1eb"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a68bf186e428de2cb335e56a90245c1eb">SetStorageTypeKey</a> (size_t keyNr, float time, const StorageType &amp;value)</td></tr>
<tr class="separator:a68bf186e428de2cb335e56a90245c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda8bb9f198c790e7a4047a248e5004e"><td class="memTemplParams" colspan="2"><a class="anchor" id="afda8bb9f198c790e7a4047a248e5004e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afda8bb9f198c790e7a4047a248e5004e"><td class="memTemplItemLeft" align="right" valign="top">MCORE_INLINE AZ::Quaternion&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Interpolate</b> (size_t startKey, float currentTime) const</td></tr>
<tr class="separator:afda8bb9f198c790e7a4047a248e5004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ec254f2c35a85528aaf04bf1d5fa62"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0ec254f2c35a85528aaf04bf1d5fa62"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af0ec254f2c35a85528aaf04bf1d5fa62"><td class="memTemplItemLeft" align="right" valign="top">MCORE_INLINE AZ::Quaternion&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Interpolate</b> (size_t startKey, float currentTime) const</td></tr>
<tr class="separator:af0ec254f2c35a85528aaf04bf1d5fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afcba1095ccfce524a7e354c47ded69d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcba1095ccfce524a7e354c47ded69d2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Reflect</b> (AZ::ReflectContext *context)</td></tr>
<tr class="separator:afcba1095ccfce524a7e354c47ded69d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1a4a87ac29eb9b418e873163d0abeace"><td class="memItemLeft" align="right" valign="top">AZStd::vector&lt; <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a><br class="typebreak"/>
&lt; ReturnType, StorageType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a1a4a87ac29eb9b418e873163d0abeace">m_keys</a></td></tr>
<tr class="separator:a1a4a87ac29eb9b418e873163d0abeace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ReturnType, class StorageType = ReturnType&gt;<br/>
class EMotionFX::KeyTrackLinearDynamic&lt; ReturnType, StorageType &gt;</h3>

<p>The dynamic linear keyframe track. The difference between the standard and dynamic one is that the dynamic one can reserve memory and grow its contents more efficiently, with far less reallocations. For that reason the dynamic version is more efficient for adding and removing keys dynamically. This is a class holding a set of keyframes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a57ccb24256ddcdd18ad1ef54ddbe4311"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::<a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">KeyTrackLinearDynamic</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrKeys</td><td>The number of keyframes which the keytrack contains (preallocates this amount of keyframes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaa08aa163d8b0049a46971b0756673a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType, class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::AddKey </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReturnType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smartPreAlloc</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key to the track (at the back). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time of the keyframe, in seconds. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the keyframe. </td></tr>
    <tr><td class="paramname">smartPreAlloc</td><td>Set to true if you wish to automatically pre-allocate space for multiple keys if we run out of space. This can make adding more keys faster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62d736bd5031165baff4b9f786fa0387"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType, class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::AddKeySorted </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReturnType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smartPreAlloc</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a key to the track, and automatically detects where to place it. NOTE: you will have to call the <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a954bc26b47aa11ccd16acfcabe561a8e">Init()</a> method again when you finished adding keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time value of the keyframe, in seconds. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the keyframe at that time. </td></tr>
    <tr><td class="paramname">smartPreAlloc</td><td>Set to true if you wish to automatically pre-allocate space for multiple keys if we run out of space. This can make adding more keys faster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63c4b04714a0047f1de3c66d8c273e1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType, class StorageType = ReturnType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::CalcMemoryUsage </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeMembers</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the memory usage, in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includeMembers</td><td>Specifies whether to include member variables of the keytrack class itself or not (default=true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes used by this keytrack. </dd></dl>

</div>
</div>
<a class="anchor" id="a97863bc9acf093446cdfec236b247383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType, class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE bool <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::CheckIfIsAnimated </td>
          <td>(</td>
          <td class="paramtype">const ReturnType &amp;&#160;</td>
          <td class="paramname"><em>initialPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given keytrack is animated or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialPose</td><td>The base or initial pose to compare to. If the keyframe values are different from this value, the keytrack is considered to be animated. </td></tr>
    <tr><td class="paramname">maxError</td><td>The maximum error/difference between the specified initial pose and the keyframes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case the keytrack is animated, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a13e414bf6a942cbd6afb9d2887acda0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::ClearKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all keys. </p>

</div>
</div>
<a class="anchor" id="a516cd6f4f824381c423beb606e85641d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a>&lt; ReturnType, StorageType &gt; * <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::FindKey </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>curTime</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key at a given time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTime</td><td>The time of the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the keyframe. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ee49a3f819317dd05727d4684794fcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::FindKeyNumber </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>curTime</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key number at a given time. You will need to interpolate between this and the next key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTime</td><td>The time to retreive the key for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the key number or MCORE_INVALIDINDEX32 when not found. </dd></dl>

</div>
</div>
<a class="anchor" id="aefb3203f786883e1dd23e70b69be5fbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a>&lt; ReturnType, StorageType &gt; * <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetFirstKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the first keyframe. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first keyframe. </dd></dl>

</div>
</div>
<a class="anchor" id="ac408475642460326e98fa81a2c74b38f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a>&lt; ReturnType, StorageType &gt; * <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetFirstKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the first keyframe. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first keyframe. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7f8bcc65f50aba1efea7fa1c2a0b988"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE float <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetFirstTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the time value of the first keyframe. </p>
<dl class="section return"><dt>Returns</dt><dd>The time value of the first keyframe, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a1941f587b7b0a76b2964bd4f3737f6c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a>&lt; ReturnType, StorageType &gt; * <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetKey </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a given keyframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The index, so the keyframe number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the keyframe. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8b9b72a526510369ffdf8dbe5274ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a>&lt; ReturnType, StorageType &gt; * <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetKey </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a given keyframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The index, so the keyframe number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the keyframe. </dd></dl>

</div>
</div>
<a class="anchor" id="a123778a8441cb62c989f4fa95bf24990"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a>&lt; ReturnType, StorageType &gt; * <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetLastKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the last keyframe. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the last keyframe. </dd></dl>

</div>
</div>
<a class="anchor" id="a370031370822eda4ac4a57d103ef5ba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const <a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a>&lt; ReturnType, StorageType &gt; * <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetLastKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the last keyframe. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the last keyframe. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0eb59cb858b3e2d0851012e523607c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE float <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetLastTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the time value of the last keyframe. </p>
<dl class="section return"><dt>Returns</dt><dd>The time value of the last keyframe, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a91c06f473cc61e5e5004977e0fb878dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetNumKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of keyframes in this track. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of currently stored keyframes. </dd></dl>

</div>
</div>
<a class="anchor" id="a58d20207257f1573a44eb7fd94b444ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::GetValueAtTime </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>currentTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cachedKey</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>outWasCacheHit</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interpolate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the interpolated value at the specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentTime</td><td>The time in seconds. </td></tr>
    <tr><td class="paramname">cachedKey</td><td>The keyframe number that should first be checked before finding the keyframes to interpolate between using the keyframe finder. If this value is nullptr (default), this cached key is ignored. The cached value will also be overwritten with the new cached key in case of a cache miss. </td></tr>
    <tr><td class="paramname">outWasCacheHit</td><td>This output value will contain 0 when this method had an internal cache miss and a value of 1 in case it was a cache hit. </td></tr>
    <tr><td class="paramname">interpolate</td><td>Should we interpolate between the keyframes? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value at the specified time. </dd></dl>

</div>
</div>
<a class="anchor" id="a954bc26b47aa11ccd16acfcabe561a8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize all keyframes in this keytrack. Call this after all keys are added and setup, otherwise the interpolation won't work and nothing will happen. </p>

</div>
</div>
<a class="anchor" id="a09fea7e5d3ed97ce5e12a9b8d5b99ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE ReturnType <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::Interpolate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>currentTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform interpolation between two keyframes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startKey</td><td>The first keyframe index. The interpolation will take place between this keyframe and the one after this one. </td></tr>
    <tr><td class="paramname">currentTime</td><td>The global time, in seconds. This time value has to be between the time value of the startKey and the one after that. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated value. </dd></dl>

</div>
</div>
<a class="anchor" id="a89c0216afffbbf0fdafd4980e416c78f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::MakeLoopable </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fadeTime</em> = <code>0.3f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the keytrack loopable, by adding a new keyframe at the end of the keytrack. This added keyframe will have the same value as the first keyframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fadeTime</td><td>The relative offset after the last keyframe. If this value is 0.5, it means it will add a keyframe half a second after the last keyframe currently in the keytrack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d76c128f5d43a85257ebc9cc5a6a0b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::Optimize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimize the keytrack by removing redundant frames. The way this is done is by comparing differences between the resulting curves when removing specific keyframes. If the error (difference) between those curve before and after keyframe removal is within a given maximum error value, the keyframe can be safely removed since there will not be much "visual" difference. The metric of this maximum error depends on the ReturnType of the keytrack (so the return type values of the keyframes). For vectors this will be the squared length between those two vectors. Partial template specialization needs to be used to add support for optimizing different types, such as quaternions. You can do this by creating a specialization of the <a class="el" href="class_m_core_1_1_compare.html#a50e83b34a35a15b7058c96e2afc218c0">MCore::Compare&lt;ReturnType&gt;::CheckIfIsClose</a>(...) method. You can find it in the MCore project in the file Compare.h. We provide implementations for several different types, such as vectors, quaternions and floats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxError</td><td>The maximum allowed error value. The higher you set this value, the more keyframes will be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The method returns the number of removed keyframes. </dd></dl>

</div>
</div>
<a class="anchor" id="a7481c699db10d0b5c2cae5e7233bce4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::RemoveKey </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a given keyframe, by number. Do not forget that you have to re-initialize the keytrack after you have removed one or more keyframes. The reason for this is that the possible tangents inside the interpolators have to be recalculated when the key structure has changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyNr</td><td>The keyframe number, must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html#a91c06f473cc61e5e5004977e0fb878dd">GetNumKeys()</a>-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a434ba43b4f697204107fbcd08dc16916"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::Reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserve space for a given number of keys. This pre-allocates data, so that adding keys doesn't always do a reallocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numKeys</td><td>The number of keys to reserve space for. This is the absolute number of keys, NOT the number to reserve extra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29e031da84cad0884e60eebe536d7685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType, class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::SetKey </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReturnType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the value of a key. Please note that you have to make sure your keys remain in sorted order! (sorted on time value). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyNr</td><td>The keyframe number. </td></tr>
    <tr><td class="paramname">time</td><td>The time value, in seconds. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4defbaed677d10ebf40bd5875f62f69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::SetNumKeys </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pre-allocate a given number of keys. Please keep in mind that any existing keys will remain unchanged. However, newly created keys will be uninitialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numKeys</td><td>The number of keys to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68bf186e428de2cb335e56a90245c1eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::SetStorageTypeKey </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keyNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StorageType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the storage type value of a key. Please note that you have to make sure your keys remain in sorted order! (sorted on time value). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyNr</td><td>The keyframe number. </td></tr>
    <tr><td class="paramname">time</td><td>The time value, in seconds. </td></tr>
    <tr><td class="paramname">value</td><td>The storage type value of the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0fda4ad044a325fe35d7a61b7cc9ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType , class StorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::Shrink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrink the memory usage of this track to as small as possible. This removes any possible pre-allocated data for the array. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a1a4a87ac29eb9b418e873163d0abeace"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReturnType, class StorageType = ReturnType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::vector&lt;<a class="el" href="class_e_motion_f_x_1_1_key_frame.html">KeyFrame</a>&lt;ReturnType, StorageType&gt; &gt; <a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">EMotionFX::KeyTrackLinearDynamic</a>&lt; ReturnType, StorageType &gt;::m_keys</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The collection of keys which form the track. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Gems/EMotionFX/Code/EMotionFX/Source/KeyTrackLinearDynamic.h</li>
<li>Gems/EMotionFX/Code/EMotionFX/Source/KeyTrackLinearDynamic.inl</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>EMotionFX</b></li><li class="navelem"><a class="el" href="class_e_motion_f_x_1_1_key_track_linear_dynamic.html">KeyTrackLinearDynamic</a></li>
    <li class="footer">Generated on Thu Apr 20 2023 21:15:45 for Open 3D Engine EMotionFX Gem API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
