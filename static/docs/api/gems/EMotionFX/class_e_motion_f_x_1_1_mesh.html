<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine EMotionFX Gem API Reference: EMotionFX::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">23.05.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_e_motion_f_x_1_1_mesh.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_e_motion_f_x_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EMotionFX::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Mesh.h&gt;</code></p>

<p>Inherits <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abad5149987933c589f1d0656dd3c6833"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint32 { <br/>
&#160;&#160;<a class="el" href="class_e_motion_f_x_1_1_mesh.html#abad5149987933c589f1d0656dd3c6833a7be1a132bfbde5d166e472f60a1bb1f9">ATTRIB_POSITIONS</a> = 0, 
<a class="el" href="class_e_motion_f_x_1_1_mesh.html#abad5149987933c589f1d0656dd3c6833a99eef4fbd8f2d8915eb680367c7b6512">ATTRIB_NORMALS</a> = 1, 
<a class="el" href="class_e_motion_f_x_1_1_mesh.html#abad5149987933c589f1d0656dd3c6833a49d936535c2b55fbba083af3f1266f75">ATTRIB_TANGENTS</a> = 2, 
<a class="el" href="class_e_motion_f_x_1_1_mesh.html#abad5149987933c589f1d0656dd3c6833a123413862985c24a6be7569caf7f969e">ATTRIB_UVCOORDS</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="class_e_motion_f_x_1_1_mesh.html#abad5149987933c589f1d0656dd3c6833aef89be438a39446e56c1975b49531c14">ATTRIB_ORGVTXNUMBERS</a> = 5, 
<a class="el" href="class_e_motion_f_x_1_1_mesh.html#abad5149987933c589f1d0656dd3c6833ab318d33b84d2a4538d89b8471ca083cb">ATTRIB_BITANGENTS</a> = 7
<br/>
 }</td></tr>
<tr class="separator:abad5149987933c589f1d0656dd3c6833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a14553c9789e8b8c317c9f9e2befeb0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MEMORYBLOCK_ID</b> = 100
 }</td></tr>
<tr class="separator:a4a14553c9789e8b8c317c9f9e2befeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74479ca439124ede407baf4577c3d946"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a74479ca439124ede407baf4577c3d946">EMeshType</a> { <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a74479ca439124ede407baf4577c3d946a769660a6f99888a6ba13c76f1830bdbf">MESHTYPE_STATIC</a> = 0, 
<a class="el" href="class_e_motion_f_x_1_1_mesh.html#a74479ca439124ede407baf4577c3d946a080a2358d9e98aaf31bae0cd26599e96">MESHTYPE_CPU_DEFORMED</a> = 1, 
<a class="el" href="class_e_motion_f_x_1_1_mesh.html#a74479ca439124ede407baf4577c3d946a64824832f258f51f501a3cfa04337f80">MESHTYPE_GPU_DEFORMED</a> = 2
 }</td></tr>
<tr class="separator:a74479ca439124ede407baf4577c3d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3307a9cf47cef2745e962024e448a08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ac3307a9cf47cef2745e962024e448a08">CalcNormals</a> (bool useDuplicates=false)</td></tr>
<tr class="separator:ac3307a9cf47cef2745e962024e448a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381ef7595988dd6122804219f01f78ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a381ef7595988dd6122804219f01f78ac">CalcTangents</a> (uint32 uvLayer=0, bool storeBitangents=false)</td></tr>
<tr class="separator:a381ef7595988dd6122804219f01f78ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680e9c4d0b4f7a567476595469bd61fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a680e9c4d0b4f7a567476595469bd61fd">Allocate</a> (uint32 numVerts, uint32 numIndices, uint32 numPolygons, uint32 numOrgVerts)</td></tr>
<tr class="separator:a680e9c4d0b4f7a567476595469bd61fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25afdbb4978287faaeec38c81c442d0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a25afdbb4978287faaeec38c81c442d0a">ReleaseData</a> ()</td></tr>
<tr class="separator:a25afdbb4978287faaeec38c81c442d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53ef2b52927b66f50abd5a2e7fb86ac"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#af53ef2b52927b66f50abd5a2e7fb86ac">GetNumVertices</a> () const </td></tr>
<tr class="separator:af53ef2b52927b66f50abd5a2e7fb86ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53f8585353fa3600a4320e3198f3924"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ad53f8585353fa3600a4320e3198f3924">CalcNumUVLayers</a> () const </td></tr>
<tr class="separator:ad53f8585353fa3600a4320e3198f3924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4e502c86b48699f9cbf700a14b4d41"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#aaf4e502c86b48699f9cbf700a14b4d41">CalcNumAttributeLayers</a> (uint32 type) const </td></tr>
<tr class="separator:aaf4e502c86b48699f9cbf700a14b4d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b89bf192da6d7746ea7d8274a9381be"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a4b89bf192da6d7746ea7d8274a9381be">GetNumOrgVertices</a> () const </td></tr>
<tr class="separator:a4b89bf192da6d7746ea7d8274a9381be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fee5797e3828123e231b1170b9e226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#aa4fee5797e3828123e231b1170b9e226">ResetToOriginalData</a> ()</td></tr>
<tr class="separator:aa4fee5797e3828123e231b1170b9e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2e6afb48191b77cb2f3db08cdc0122"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a9c2e6afb48191b77cb2f3db08cdc0122">GetIndices</a> () const </td></tr>
<tr class="separator:a9c2e6afb48191b77cb2f3db08cdc0122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ef83765bb84f398cd5da4fd6b49cfb"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ae5ef83765bb84f398cd5da4fd6b49cfb">GetPolygonVertexCounts</a> () const </td></tr>
<tr class="separator:ae5ef83765bb84f398cd5da4fd6b49cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1284a842416cc6283250ba3f7f45ac"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#aab1284a842416cc6283250ba3f7f45ac">GetNumIndices</a> () const </td></tr>
<tr class="separator:aab1284a842416cc6283250ba3f7f45ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447a5a7ea83acab229af54c65670f1ea"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a447a5a7ea83acab229af54c65670f1ea">GetNumPolygons</a> () const </td></tr>
<tr class="separator:a447a5a7ea83acab229af54c65670f1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9e7b93d18b843531e41a5c43ab232f"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a6f9e7b93d18b843531e41a5c43ab232f">AddSubMesh</a> (<a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> *subMesh)</td></tr>
<tr class="separator:a6f9e7b93d18b843531e41a5c43ab232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3c0c2b612b68d6b00f14cc477f0265"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a8a3c0c2b612b68d6b00f14cc477f0265">GetNumSubMeshes</a> () const </td></tr>
<tr class="separator:a8a3c0c2b612b68d6b00f14cc477f0265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0af428f1b59e89db2a7747d414c757e"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#aa0af428f1b59e89db2a7747d414c757e">GetSubMesh</a> (size_t nr) const </td></tr>
<tr class="separator:aa0af428f1b59e89db2a7747d414c757e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5392da8c162a0eec1b0bb0d003c39b49"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a5392da8c162a0eec1b0bb0d003c39b49">SetSubMesh</a> (size_t nr, <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> *subMesh)</td></tr>
<tr class="separator:a5392da8c162a0eec1b0bb0d003c39b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebb650da465324efd692ab814434c18"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a5ebb650da465324efd692ab814434c18">SetNumSubMeshes</a> (size_t numSubMeshes)</td></tr>
<tr class="separator:a5ebb650da465324efd692ab814434c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f20ff4d2fe2e3dbc21cfa5dad3840ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a8f20ff4d2fe2e3dbc21cfa5dad3840ce">RemoveSubMesh</a> (size_t nr, bool delFromMem=true)</td></tr>
<tr class="separator:a8f20ff4d2fe2e3dbc21cfa5dad3840ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd1f3fcdba625b600d52c60017afaa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a1dd1f3fcdba625b600d52c60017afaa1">InsertSubMesh</a> (size_t insertIndex, <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> *subMesh)</td></tr>
<tr class="separator:a1dd1f3fcdba625b600d52c60017afaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773c748b0f41d6f0fa147cd81a7cc191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a773c748b0f41d6f0fa147cd81a7cc191">GetSharedVertexAttributeLayer</a> (size_t layerNr)</td></tr>
<tr class="separator:a773c748b0f41d6f0fa147cd81a7cc191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0bc515cc01828961bf29a10b143b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a7f0bc515cc01828961bf29a10b143b3f">AddSharedVertexAttributeLayer</a> (<a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *layer)</td></tr>
<tr class="separator:a7f0bc515cc01828961bf29a10b143b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1844033ff1bc40fb73d7dc868759beb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ac1844033ff1bc40fb73d7dc868759beb">GetNumSharedVertexAttributeLayers</a> () const </td></tr>
<tr class="separator:ac1844033ff1bc40fb73d7dc868759beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd98c248fc392eefbb763dc819dcd9f5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#afd98c248fc392eefbb763dc819dcd9f5">FindSharedVertexAttributeLayerNumber</a> (uint32 layerTypeID, size_t occurrence=0) const </td></tr>
<tr class="separator:afd98c248fc392eefbb763dc819dcd9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad242b0e3bbcca6ec6142fe47837d37e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ad242b0e3bbcca6ec6142fe47837d37e6">FindSharedVertexAttributeLayer</a> (uint32 layerTypeID, size_t occurence=0) const </td></tr>
<tr class="separator:ad242b0e3bbcca6ec6142fe47837d37e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1274e274dd880316a2f56792c8e4d378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a1274e274dd880316a2f56792c8e4d378">RemoveAllSharedVertexAttributeLayers</a> ()</td></tr>
<tr class="separator:a1274e274dd880316a2f56792c8e4d378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e0a08ab1a3b639635eb2e8c9def3af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a94e0a08ab1a3b639635eb2e8c9def3af">RemoveSharedVertexAttributeLayer</a> (size_t layerNr)</td></tr>
<tr class="separator:a94e0a08ab1a3b639635eb2e8c9def3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17906be1e9f58b8f75e5b1b2434eb8ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a17906be1e9f58b8f75e5b1b2434eb8ad">GetNumVertexAttributeLayers</a> () const </td></tr>
<tr class="separator:a17906be1e9f58b8f75e5b1b2434eb8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d0521813faf52a966a0b1828a1367d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a98d0521813faf52a966a0b1828a1367d">GetVertexAttributeLayer</a> (size_t layerNr)</td></tr>
<tr class="separator:a98d0521813faf52a966a0b1828a1367d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3748a63e736ba6137f561a1b38db2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a7b3748a63e736ba6137f561a1b38db2c">AddVertexAttributeLayer</a> (<a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *layer)</td></tr>
<tr class="separator:a7b3748a63e736ba6137f561a1b38db2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ca791009248832cd0496ff73c8f0b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#af8ca791009248832cd0496ff73c8f0b4">ReserveVertexAttributeLayerSpace</a> (uint32 numLayers)</td></tr>
<tr class="separator:af8ca791009248832cd0496ff73c8f0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073c3bc959b30a5155e5a79b8d786995"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a073c3bc959b30a5155e5a79b8d786995">FindVertexAttributeLayerNumber</a> (uint32 layerTypeID, size_t occurrence=0) const </td></tr>
<tr class="separator:a073c3bc959b30a5155e5a79b8d786995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27974ea94f15edc1386daa7f20f2083d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27974ea94f15edc1386daa7f20f2083d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FindVertexAttributeLayerNumberByName</b> (uint32 layerTypeID, const char *name) const </td></tr>
<tr class="separator:a27974ea94f15edc1386daa7f20f2083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d0890a36c1ef7b1ae2a5e3aa9d34bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7d0890a36c1ef7b1ae2a5e3aa9d34bc"></a>
<a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>FindVertexAttributeLayerByName</b> (uint32 layerTypeID, const char *name) const </td></tr>
<tr class="separator:aa7d0890a36c1ef7b1ae2a5e3aa9d34bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc17a07666dc631690f8f40c0f8c56d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#abc17a07666dc631690f8f40c0f8c56d2">FindVertexAttributeLayer</a> (uint32 layerTypeID, size_t occurence=0) const </td></tr>
<tr class="separator:abc17a07666dc631690f8f40c0f8c56d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676964971cab9c456b2f00e1171cef48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a676964971cab9c456b2f00e1171cef48"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FindVertexAttributeLayerIndexByName</b> (const char *name) const </td></tr>
<tr class="separator:a676964971cab9c456b2f00e1171cef48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa21e5add7b1d59db6d055ea6cfafa3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa21e5add7b1d59db6d055ea6cfafa3f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FindVertexAttributeLayerIndexByNameString</b> (const AZStd::string &amp;name) const </td></tr>
<tr class="separator:aaa21e5add7b1d59db6d055ea6cfafa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d09ceb3f6795c269ebee5f99aeaf46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4d09ceb3f6795c269ebee5f99aeaf46"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FindVertexAttributeLayerIndexByNameID</b> (uint32 nameID) const </td></tr>
<tr class="separator:af4d09ceb3f6795c269ebee5f99aeaf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9141c4946339dc5aa3616a2fe90a06bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9141c4946339dc5aa3616a2fe90a06bf"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FindSharedVertexAttributeLayerIndexByName</b> (const char *name) const </td></tr>
<tr class="separator:a9141c4946339dc5aa3616a2fe90a06bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd246b3edff6faf4c5496eea26503ac5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd246b3edff6faf4c5496eea26503ac5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FindSharedVertexAttributeLayerIndexByNameString</b> (const AZStd::string &amp;name) const </td></tr>
<tr class="separator:acd246b3edff6faf4c5496eea26503ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80975c5935674438f3ca3c01eb98143f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80975c5935674438f3ca3c01eb98143f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>FindSharedVertexAttributeLayerIndexByNameID</b> (uint32 nameID) const </td></tr>
<tr class="separator:a80975c5935674438f3ca3c01eb98143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf9ef53e2acab164ceda0b0138f68b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#adcf9ef53e2acab164ceda0b0138f68b4">RemoveAllVertexAttributeLayers</a> ()</td></tr>
<tr class="separator:adcf9ef53e2acab164ceda0b0138f68b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2560197f1f0b4b7217245b9c18a0169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ac2560197f1f0b4b7217245b9c18a0169">RemoveVertexAttributeLayer</a> (size_t layerNr)</td></tr>
<tr class="separator:ac2560197f1f0b4b7217245b9c18a0169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dcfc00e2f6cbff3a3399fb2052b305"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a49dcfc00e2f6cbff3a3399fb2052b305">Intersects</a> (const Transform &amp;transform, const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;ray)</td></tr>
<tr class="separator:a49dcfc00e2f6cbff3a3399fb2052b305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57259c94b8e3dba9b2e46242c71c0160"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a57259c94b8e3dba9b2e46242c71c0160">Intersects</a> (const Transform &amp;transform, const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;ray, AZ::Vector3 *outIntersect, float *outBaryU=nullptr, float *outBaryV=nullptr, uint32 *outIndices=nullptr)</td></tr>
<tr class="separator:a57259c94b8e3dba9b2e46242c71c0160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6224a3e7ec8b35bd28a914ad25a13b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ae6224a3e7ec8b35bd28a914ad25a13b0">GatherBonesForFace</a> (uint32 startIndexOfFace, AZStd::vector&lt; <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> * &gt; &amp;outBones, <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *actor)</td></tr>
<tr class="separator:ae6224a3e7ec8b35bd28a914ad25a13b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9132c1502223677426f3983a787f1b"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a3a9132c1502223677426f3983a787f1b">CalcMaxNumInfluencesForFace</a> (uint32 startIndexOfFace) const </td></tr>
<tr class="separator:a3a9132c1502223677426f3983a787f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af115ddf66acf21f05d4fb09ffec59067"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#af115ddf66acf21f05d4fb09ffec59067">CalcMaxNumInfluences</a> () const </td></tr>
<tr class="separator:af115ddf66acf21f05d4fb09ffec59067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2369d1013e03f80077d9c1cfab04a0b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ac2369d1013e03f80077d9c1cfab04a0b">CalcMaxNumInfluences</a> (AZStd::vector&lt; size_t &gt; &amp;outVertexCounts) const </td></tr>
<tr class="separator:ac2369d1013e03f80077d9c1cfab04a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f73e7f7ecff00bfdb4fece222b34d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a0f73e7f7ecff00bfdb4fece222b34d2e">ExtractOriginalVertexPositions</a> (AZStd::vector&lt; AZ::Vector3 &gt; &amp;outPoints) const </td></tr>
<tr class="separator:a0f73e7f7ecff00bfdb4fece222b34d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1465cf4f2d7913c9acd40735b77add84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a1465cf4f2d7913c9acd40735b77add84">Clone</a> ()</td></tr>
<tr class="separator:a1465cf4f2d7913c9acd40735b77add84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5394c97e04347edfa96bda771a8bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a1d5394c97e04347edfa96bda771a8bda">SwapVertex</a> (uint32 vertexA, uint32 vertexB)</td></tr>
<tr class="separator:a1d5394c97e04347edfa96bda771a8bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0623680dc451b34751ccaeb87e24164d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a0623680dc451b34751ccaeb87e24164d">RemoveVertices</a> (uint32 startVertexNr, uint32 endVertexNr, bool changeIndexBuffer=true, bool removeEmptySubMeshes=false)</td></tr>
<tr class="separator:a0623680dc451b34751ccaeb87e24164d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e98e5d5549611c54af8599a7e3e11c1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a5e98e5d5549611c54af8599a7e3e11c1">RemoveEmptySubMeshes</a> (bool onlyRemoveOnZeroVertsAndTriangles=true)</td></tr>
<tr class="separator:a5e98e5d5549611c54af8599a7e3e11c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead97634074d83ef66c63fbbdbab274a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#aead97634074d83ef66c63fbbdbab274a">FindVertexData</a> (uint32 layerID, size_t occurrence=0) const </td></tr>
<tr class="separator:aead97634074d83ef66c63fbbdbab274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30db3f2358084de3261e6c422792be5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac30db3f2358084de3261e6c422792be5"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>FindVertexDataByName</b> (uint32 layerID, const char *name) const </td></tr>
<tr class="separator:ac30db3f2358084de3261e6c422792be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fe3f6ae91929acaa29bfe3c75f62bf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ae0fe3f6ae91929acaa29bfe3c75f62bf">FindOriginalVertexData</a> (uint32 layerID, size_t occurrence=0) const </td></tr>
<tr class="separator:ae0fe3f6ae91929acaa29bfe3c75f62bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757949654233fe46b81b77656fc7f162"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a757949654233fe46b81b77656fc7f162"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>FindOriginalVertexDataByName</b> (uint32 layerID, const char *name) const </td></tr>
<tr class="separator:a757949654233fe46b81b77656fc7f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10bd23aec6a1963f67dfdbe5c33a595"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#aa10bd23aec6a1963f67dfdbe5c33a595">CalcAabb</a> (AZ::Aabb *outBoundingBox, const Transform &amp;transform, uint32 vertexFrequency=1)</td></tr>
<tr class="separator:aa10bd23aec6a1963f67dfdbe5c33a595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c622108fdfe425f857cd7878bd8910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a74479ca439124ede407baf4577c3d946">EMeshType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a91c622108fdfe425f857cd7878bd8910">ClassifyMeshType</a> (size_t lodLevel, <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *actor, size_t nodeIndex, bool forceCPUSkinning, uint32 maxInfluences, uint32 maxBonesPerSubMesh) const </td></tr>
<tr class="separator:a91c622108fdfe425f857cd7878bd8910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bfc10dcea75e3a93d82370e5998fbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#af0bfc10dcea75e3a93d82370e5998fbf">Log</a> ()</td></tr>
<tr class="separator:af0bfc10dcea75e3a93d82370e5998fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2332a2532d6b22132f6bfd921accb291"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a2332a2532d6b22132f6bfd921accb291">ConvertTo16BitIndices</a> ()</td></tr>
<tr class="separator:a2332a2532d6b22132f6bfd921accb291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ca563bfd2ddf831304abd6a14b5937"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a98ca563bfd2ddf831304abd6a14b5937">CheckIfIsTriangleMesh</a> () const </td></tr>
<tr class="separator:a98ca563bfd2ddf831304abd6a14b5937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c722cd65be1a901e6c5dd6641d06c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a42c722cd65be1a901e6c5dd6641d06c9">CheckIfIsQuadMesh</a> () const </td></tr>
<tr class="separator:a42c722cd65be1a901e6c5dd6641d06c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f33074b26f2793d1e2078e687256dbc"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a9f33074b26f2793d1e2078e687256dbc">CalcNumTriangles</a> () const </td></tr>
<tr class="separator:a9f33074b26f2793d1e2078e687256dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad112685558a7e06b55ce2b3ade27fdcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ad112685558a7e06b55ce2b3ade27fdcb">Scale</a> (float scaleFactor)</td></tr>
<tr class="separator:ad112685558a7e06b55ce2b3ade27fdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f9bdefb239beb7df8bda9b0b4d71dd"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a27f9bdefb239beb7df8bda9b0b4d71dd">GetNumUniqueJoints</a> () const </td></tr>
<tr class="separator:a27f9bdefb239beb7df8bda9b0b4d71dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37bd552db831b7262c4bcc933bd1261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ac37bd552db831b7262c4bcc933bd1261">SetNumUniqueJoints</a> (uint16 numUniqueJoints)</td></tr>
<tr class="separator:ac37bd552db831b7262c4bcc933bd1261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3e5528732d4994f83a660e7099225c"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a7b3e5528732d4994f83a660e7099225c">GetHighestJointIndex</a> () const </td></tr>
<tr class="separator:a7b3e5528732d4994f83a660e7099225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03161687cca6537bd03a698ebdc774d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ac03161687cca6537bd03a698ebdc774d">SetHighestJointIndex</a> (uint16 highestJointIndex)</td></tr>
<tr class="separator:ac03161687cca6537bd03a698ebdc774d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3748e60557857aad3b7b2b391d550fb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3748e60557857aad3b7b2b391d550fb9"></a>
MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetIsCollisionMesh</b> () const </td></tr>
<tr class="separator:a3748e60557857aad3b7b2b391d550fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dcec9a568a1da77c8837385b37d18d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83dcec9a568a1da77c8837385b37d18d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetIsCollisionMesh</b> (bool isCollisionMesh)</td></tr>
<tr class="separator:a83dcec9a568a1da77c8837385b37d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_e_motion_f_x_1_1_base_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_e_motion_f_x_1_1_base_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a></td></tr>
<tr class="memitem:ab30842776f205a40428bf45079114a6a inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#ab30842776f205a40428bf45079114a6a">BaseObject</a> ()</td></tr>
<tr class="separator:ab30842776f205a40428bf45079114a6a inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3409404f7d117a896a45750468b7b86e inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#a3409404f7d117a896a45750468b7b86e">~BaseObject</a> ()</td></tr>
<tr class="separator:a3409404f7d117a896a45750468b7b86e inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_core_1_1_memory_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_core_1_1_memory_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_core_1_1_memory_object.html">MCore::MemoryObject</a></td></tr>
<tr class="memitem:acbebcaf9fe821daf94eb391978453e86 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#acbebcaf9fe821daf94eb391978453e86">MemoryObject</a> ()</td></tr>
<tr class="separator:acbebcaf9fe821daf94eb391978453e86 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7656e1a1def84ff64945db88ee65c50 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#aa7656e1a1def84ff64945db88ee65c50">~MemoryObject</a> ()</td></tr>
<tr class="separator:aa7656e1a1def84ff64945db88ee65c50 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aca36760b0c56ec18d99f4f53c4335 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a51aca36760b0c56ec18d99f4f53c4335">IncreaseReferenceCount</a> ()</td></tr>
<tr class="separator:a51aca36760b0c56ec18d99f4f53c4335 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b277fe3fc49344884b522cdc7a305b inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a88b277fe3fc49344884b522cdc7a305b">DecreaseReferenceCount</a> ()</td></tr>
<tr class="separator:a88b277fe3fc49344884b522cdc7a305b inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8132c0072fb1b0b9b0e6cbf804af2a6d inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a8132c0072fb1b0b9b0e6cbf804af2a6d">Destroy</a> ()</td></tr>
<tr class="separator:a8132c0072fb1b0b9b0e6cbf804af2a6d inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ee52d71f71814c6114a021e05ef129 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a80ee52d71f71814c6114a021e05ef129">GetReferenceCount</a> () const </td></tr>
<tr class="separator:a80ee52d71f71814c6114a021e05ef129 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa00faffad79433d916e36adf959b13e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#aa00faffad79433d916e36adf959b13e9">Create</a> ()</td></tr>
<tr class="separator:aa00faffad79433d916e36adf959b13e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3cddd2b23acc7486e8e171258fa698"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#adf3cddd2b23acc7486e8e171258fa698">Create</a> (uint32 numVerts, uint32 numIndices, uint32 numPolygons, uint32 numOrgVerts, bool isCollisionMesh)</td></tr>
<tr class="separator:adf3cddd2b23acc7486e8e171258fa698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb443fe21e138b17880a92e4822a4327"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb443fe21e138b17880a92e4822a4327"></a>
static <a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFromModelLod</b> (const AZ::Data::Asset&lt; AZ::RPI::ModelLodAsset &gt; &amp;sourceModelLod, const AZStd::unordered_map&lt; AZ::u16, AZ::u16 &gt; &amp;skinToSkeletonIndexMap)</td></tr>
<tr class="separator:afb443fe21e138b17880a92e4822a4327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984b4b950d5304d81c78c1296fcd078b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a984b4b950d5304d81c78c1296fcd078b">CalcTangentAndBitangentForFace</a> (const AZ::Vector3 &amp;posA, const AZ::Vector3 &amp;posB, const AZ::Vector3 &amp;posC, const AZ::Vector2 &amp;uvA, const AZ::Vector2 &amp;uvB, const AZ::Vector2 &amp;uvC, AZ::Vector3 *outTangent, AZ::Vector3 *outBitangent)</td></tr>
<tr class="separator:a984b4b950d5304d81c78c1296fcd078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a72e0b2533e0bbec751cfb05aa55fea75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a72e0b2533e0bbec751cfb05aa55fea75">Mesh</a> ()</td></tr>
<tr class="separator:a72e0b2533e0bbec751cfb05aa55fea75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cd704a973b0d253edbeb7a5e7a6224"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a34cd704a973b0d253edbeb7a5e7a6224">Mesh</a> (uint32 numVerts, uint32 numIndices, uint32 numPolygons, uint32 numOrgVerts, bool isCollisionMesh)</td></tr>
<tr class="separator:a34cd704a973b0d253edbeb7a5e7a6224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a967c1903bac52cdf30b80c22e2091"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a39a967c1903bac52cdf30b80c22e2091">~Mesh</a> ()</td></tr>
<tr class="separator:a39a967c1903bac52cdf30b80c22e2091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_e_motion_f_x_1_1_base_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_e_motion_f_x_1_1_base_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a></td></tr>
<tr class="memitem:a021c030d0ce454dfebc6631194c57f0d inherit pro_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#a021c030d0ce454dfebc6631194c57f0d">Delete</a> () override</td></tr>
<tr class="separator:a021c030d0ce454dfebc6631194c57f0d inherit pro_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a823c869eba4a89d445673b6be6536d11"><td class="memItemLeft" align="right" valign="top">AZStd::vector&lt; <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a823c869eba4a89d445673b6be6536d11">m_subMeshes</a></td></tr>
<tr class="separator:a823c869eba4a89d445673b6be6536d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae280fb009c6d1a1856a9f8e94381399e"><td class="memItemLeft" align="right" valign="top">uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ae280fb009c6d1a1856a9f8e94381399e">m_indices</a></td></tr>
<tr class="separator:ae280fb009c6d1a1856a9f8e94381399e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dd1c8f5ae50408a6c57048567abb54"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#af6dd1c8f5ae50408a6c57048567abb54">m_polyVertexCounts</a></td></tr>
<tr class="separator:af6dd1c8f5ae50408a6c57048567abb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d5ad8a82a6e5d96f546a98805820a8"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#ae5d5ad8a82a6e5d96f546a98805820a8">m_numPolygons</a></td></tr>
<tr class="separator:ae5d5ad8a82a6e5d96f546a98805820a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3552b7b7d73165068defc6d7f054bf63"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a3552b7b7d73165068defc6d7f054bf63">m_numOrgVerts</a></td></tr>
<tr class="separator:a3552b7b7d73165068defc6d7f054bf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e79f60e49336aecf660a6160befef41"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a0e79f60e49336aecf660a6160befef41">m_numVertices</a></td></tr>
<tr class="separator:a0e79f60e49336aecf660a6160befef41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd9156a4feea977aea3227886f0ee9b"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#accd9156a4feea977aea3227886f0ee9b">m_numIndices</a></td></tr>
<tr class="separator:accd9156a4feea977aea3227886f0ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaf7448d8a4b2c706077cce5ffa092a"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a7eaf7448d8a4b2c706077cce5ffa092a">m_numUniqueJoints</a></td></tr>
<tr class="separator:a7eaf7448d8a4b2c706077cce5ffa092a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291b23cc59da17172e69d123296bafd4"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a291b23cc59da17172e69d123296bafd4">m_highestJointIndex</a></td></tr>
<tr class="separator:a291b23cc59da17172e69d123296bafd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41405c1010501335506da827282cd66d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a41405c1010501335506da827282cd66d">m_isCollisionMesh</a></td></tr>
<tr class="separator:a41405c1010501335506da827282cd66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cda2f71802d3aac98e00f0ec99584b"><td class="memItemLeft" align="right" valign="top">AZStd::vector<br class="typebreak"/>
&lt; <a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a96cda2f71802d3aac98e00f0ec99584b">m_sharedVertexAttributes</a></td></tr>
<tr class="separator:a96cda2f71802d3aac98e00f0ec99584b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebb29df2c476e90b0da44164985533a"><td class="memItemLeft" align="right" valign="top">AZStd::vector<br class="typebreak"/>
&lt; <a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#afebb29df2c476e90b0da44164985533a">m_vertexAttributes</a></td></tr>
<tr class="separator:afebb29df2c476e90b0da44164985533a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The mesh base class. Every mesh contains a list of vertex data (positions, normals and uv coordinates) and a set of indices. The indices describe the polygons and point into the vertex data. The vertex data is stored in seperate layers. So the position, normal, uv and tangent data is stored in three layers/arrays. You can access the vertex data with <a class="el" href="class_e_motion_f_x_1_1_mesh.html#aead97634074d83ef66c63fbbdbab274a">FindVertexData()</a> and <a class="el" href="class_e_motion_f_x_1_1_mesh.html#ae0fe3f6ae91929acaa29bfe3c75f62bf">FindOriginalVertexData()</a>. The length of all these arrays equals the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#af53ef2b52927b66f50abd5a2e7fb86ac">GetNumVertices()</a>. So this means that there are ALWAYS the same amount of positions, normals and uv coordinates in the mesh. Vertices automatically are duplicated when needed. This means that a flat shaded cube of triangles which normally has 8 vertices will have 24 vertices in this mesh. This is done, because you can use this vertex data directly to render it on the graphics hardware and it allows multiple normals and texture coordinates per vertex, which is needed for good texture mapping support and support for smoothing groups and flat shading. Still, each of the 24 vertices in the 'cube' example will have indices to their original vertices (which are not stored). This array of indices can be accessed by calling GetOrgVerts(). The values stored in this array will range from [0..7]. The mesh also contains a set of vertex attributes, which are user defined attributes per vertex. Next to that there also are shared vertex attributes, which are only there for the real number of vertices. All vertices have the same number of attributes, and attribute number 'n' has to be of the same type for all vertices as well. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a>. </dd>
<dd>
<a class="el" href="class_e_motion_f_x_1_1_mesh.html#aead97634074d83ef66c63fbbdbab274a">FindVertexData</a>. </dd>
<dd>
<a class="el" href="class_e_motion_f_x_1_1_mesh.html#ae0fe3f6ae91929acaa29bfe3c75f62bf">FindOriginalVertexData</a>. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="abad5149987933c589f1d0656dd3c6833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer_abstract_data.html#a47599b86d5317c8700bfe01a06cf18dd">VertexAttributeLayerAbstractData::GetType()</a> values for the vertex data Use these with the <a class="el" href="class_e_motion_f_x_1_1_mesh.html#aead97634074d83ef66c63fbbdbab274a">Mesh::FindVertexData()</a> and <a class="el" href="class_e_motion_f_x_1_1_mesh.html#ae0fe3f6ae91929acaa29bfe3c75f62bf">Mesh::FindOriginalVertexData()</a> methods. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="abad5149987933c589f1d0656dd3c6833a7be1a132bfbde5d166e472f60a1bb1f9"></a>ATTRIB_POSITIONS</em>&nbsp;</td><td class="fielddoc">
<p>Vertex positions. Typecast to AZ::Vector3. Positions are always exist. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="abad5149987933c589f1d0656dd3c6833a99eef4fbd8f2d8915eb680367c7b6512"></a>ATTRIB_NORMALS</em>&nbsp;</td><td class="fielddoc">
<p>Vertex normals. Typecast to AZ::Vector3. Normals are always exist. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="abad5149987933c589f1d0656dd3c6833a49d936535c2b55fbba083af3f1266f75"></a>ATTRIB_TANGENTS</em>&nbsp;</td><td class="fielddoc">
<p>Vertex tangents. Typecast to <b> AZ::Vector4 </b>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="abad5149987933c589f1d0656dd3c6833a123413862985c24a6be7569caf7f969e"></a>ATTRIB_UVCOORDS</em>&nbsp;</td><td class="fielddoc">
<p>Vertex uv coordinates. Typecast to AZ::Vector2. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="abad5149987933c589f1d0656dd3c6833aef89be438a39446e56c1975b49531c14"></a>ATTRIB_ORGVTXNUMBERS</em>&nbsp;</td><td class="fielddoc">
<p>Original vertex numbers. Typecast to uint32. Original vertex numbers always exist. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="abad5149987933c589f1d0656dd3c6833ab318d33b84d2a4538d89b8471ca083cb"></a>ATTRIB_BITANGENTS</em>&nbsp;</td><td class="fielddoc">
<p>Vertex bitangents (aka binormal). Typecast to AZ::Vector3. When tangents exists bitangents may still not exist! </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4a14553c9789e8b8c317c9f9e2befeb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The memory block ID where mesh data will be allocated in. Giving mesh data their own memory blocks can reduce the amount of used total blocks when memory gets deleted again. </p>

</div>
</div>
<a class="anchor" id="a74479ca439124ede407baf4577c3d946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a74479ca439124ede407baf4577c3d946">EMotionFX::Mesh::EMeshType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The mesh type used to indicate if a mesh is either static, like a cube or building, cpu deformed, if it needs to be processed on the CPU, or GPU deformed if it can be processed fully on the GPU. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a74479ca439124ede407baf4577c3d946a769660a6f99888a6ba13c76f1830bdbf"></a>MESHTYPE_STATIC</em>&nbsp;</td><td class="fielddoc">
<p>Static rigid mesh, like a cube or building (can still be position/scale/rotation animated though). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a74479ca439124ede407baf4577c3d946a080a2358d9e98aaf31bae0cd26599e96"></a>MESHTYPE_CPU_DEFORMED</em>&nbsp;</td><td class="fielddoc">
<p>Deformed on the CPU. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a74479ca439124ede407baf4577c3d946a64824832f258f51f501a3cfa04337f80"></a>MESHTYPE_GPU_DEFORMED</em>&nbsp;</td><td class="fielddoc">
<p>Deformed on the GPU. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a72e0b2533e0bbec751cfb05aa55fea75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EMotionFX::Mesh::Mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a34cd704a973b0d253edbeb7a5e7a6224"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EMotionFX::Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numOrgVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCollisionMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor which allocates mesh data. Please keep in mind that this does not create and add any layers for position, normal, tangent, uv data etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numVerts</td><td>The number of vertices to allocate. </td></tr>
    <tr><td class="paramname">numIndices</td><td>The number of indices to allocate. </td></tr>
    <tr><td class="paramname">numPolygons</td><td>The number of polygons to allocate. </td></tr>
    <tr><td class="paramname">numOrgVerts</td><td>The number of original vertices. </td></tr>
    <tr><td class="paramname">isCollisionMesh</td><td>Set to true if this mesh is a collision mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39a967c1903bac52cdf30b80c22e2091"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EMotionFX::Mesh::~Mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Automatically releases all data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7f0bc515cc01828961bf29a10b143b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::AddSharedVertexAttributeLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new layer of shared vertex attributes. The data will automatically be deleted from memory on destruction of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer to add. The array must contain <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a4b89bf192da6d7746ea7d8274a9381be">GetNumOrgVertices()</a> elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f9e7b93d18b843531e41a5c43ab232f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Mesh::AddSubMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>subMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> to this mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subMesh</td><td>A pointer to the <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b3748a63e736ba6137f561a1b38db2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::AddVertexAttributeLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new layer of vertex attributes. The data will automatically be deleted from memory on destruction of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer to add. The array must contain <a class="el" href="class_e_motion_f_x_1_1_mesh.html#af53ef2b52927b66f50abd5a2e7fb86ac">GetNumVertices()</a> elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a680e9c4d0b4f7a567476595469bd61fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::Allocate </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numOrgVerts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate mesh data. If there is already data allocated, this data will be deleted first. Please keep in mind this does not create and add any layers for position, normal, uv and tangent data etc. Only indices will be allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numVerts</td><td>The number of vertices to allocate. </td></tr>
    <tr><td class="paramname">numIndices</td><td>The number of indices to allocate. </td></tr>
    <tr><td class="paramname">numPolygons</td><td>The number of polygons to allocate. </td></tr>
    <tr><td class="paramname">numOrgVerts</td><td>The number of original vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa10bd23aec6a1963f67dfdbe5c33a595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::CalcAabb </td>
          <td>(</td>
          <td class="paramtype">AZ::Aabb *&#160;</td>
          <td class="paramname"><em>outBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Transform &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexFrequency</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the axis aligned bounding box of this mesh, after transforming the positions with the provided transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outBoundingBox</td><td>The bounding box that will contain the bounds after executing this method. </td></tr>
    <tr><td class="paramname">Transform</td><td>The transformation to transform all vertex positions with. </td></tr>
    <tr><td class="paramname">vertexFrequency</td><td>This is the for loop increase counter value. A value of 1 means every vertex will be processed while a value of 2 means every second vertex, etc. The value must be 1 or higher. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af115ddf66acf21f05d4fb09ffec59067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::CalcMaxNumInfluences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the maximum number of bone influences. This is calculated by for each vertex checking the number of bone influences, and take the maximum of that amount. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of influences. This will be 0 for non-softskinned objects. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2369d1013e03f80077d9c1cfab04a0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::CalcMaxNumInfluences </td>
          <td>(</td>
          <td class="paramtype">AZStd::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>outVertexCounts</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the maximum number of bone influences. This is calculated by for each vertex checking the number of bone influences, and take the maximum of that amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexCounts</td><td>Reference to an interger array, which will be filled by this function with vertex counts for specific number of influences. array[0] e.g. holds the number of vertices which have no influences, so non-skinned; array[4] holds the number of vertices which are effected by 4 bones. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of influences. This will be 0 for non-softskinned objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a9132c1502223677426f3983a787f1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 EMotionFX::Mesh::CalcMaxNumInfluencesForFace </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>startIndexOfFace</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the maximum number of bone influences for a given face. This is calculated by for each vertex checking the number of bone influences, and take the maximum of that amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startIndexOfFace</td><td>The start index of the first vertex of the face. So not the vertex number, but the offset in the index array of this mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of influences of the given face. This will be 0 for non-softskinned objects. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3307a9cf47cef2745e962024e448a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::CalcNormals </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useDuplicates</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recalculates the vertex normals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useDuplicates</td><td>Setting this to true will cause hard borders at vertices that have been duplicated. Setting to false (default) will use the original mesh vertex positions only which results in the mesh being fully smoothed. On a cube however that would not work well, as it won't preserve the hard face normals, but it will smooth the normals. Most of the time on character you would want to set this to false though, to prevent seams from showing up in areas between the neck and body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf4e502c86b48699f9cbf700a14b4d41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::CalcNumAttributeLayers </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the number of vertex attribute layers of the given type. It is recommended NOT to put this function inside a loop, because it is not very fast. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of the vertex attribute layer to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of layers/sets currently present inside this mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f33074b26f2793d1e2078e687256dbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 EMotionFX::Mesh::CalcNumTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate how many triangles this mesh has. In case the mesh contains polygons of more than 3 vertices, triangulation will be taken into account. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of triangles that are needed to draw this mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="ad53f8585353fa3600a4320e3198f3924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::CalcNumUVLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the number of UV coordinate layers. It is recommended NOT to put this function inside a loop, because it is not very fast. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of UV layers/sets currently present inside this mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="a984b4b950d5304d81c78c1296fcd078b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void EMotionFX::Mesh::CalcTangentAndBitangentForFace </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>posB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>posC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector2 &amp;&#160;</td>
          <td class="paramname"><em>uvA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector2 &amp;&#160;</td>
          <td class="paramname"><em>uvB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector2 &amp;&#160;</td>
          <td class="paramname"><em>uvC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>outTangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>outBitangent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the tangent and bitangent for a given triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posA</td><td>The position of the first vertex. </td></tr>
    <tr><td class="paramname">posB</td><td>The position of the second vertex. </td></tr>
    <tr><td class="paramname">posC</td><td>The position of the third vertex. </td></tr>
    <tr><td class="paramname">uvA</td><td>The texture coordinate of the first vertex. </td></tr>
    <tr><td class="paramname">uvB</td><td>The texture coordinate of the second vertex. </td></tr>
    <tr><td class="paramname">uvC</td><td>The texture coordinate of the third vertex. </td></tr>
    <tr><td class="paramname">outTangent</td><td>A pointer to the vector to store the calculated tangent vector. </td></tr>
    <tr><td class="paramname">outBitangent</td><td>A pointer to the vector to store the calculated bitangent vector (calculated using the gradients). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a381ef7595988dd6122804219f01f78ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Mesh::CalcTangents </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>uvLayer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>storeBitangents</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the tangent vectors which can be used for per pixel lighting. These are vectors also known as S and T, used in per pixel lighting techniques, like bumpmapping. You can calculate the bitangent for the given tangent by taking the cross product between the normal and the tangent for the given vertex. These three vectors (normal, tangent and bitangent) are used to build a matrix which transforms the lights into tangent space. You can only call this method after you have passed all other vertex and index data to the mesh. So after all that has been initialized, call this method to calculate these vectors automatically. If you specify a UV set that doesn't exist, this method will fall back to UV set 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uvLayer[in]</td><td>The UV texture coordinate layer number. This is not the vertex attribute layer number, but the UV layer number. This means that 0 means the first UV set, and 1 would mean the second UV set, etc. When the UV layer doesn't exist, this method does nothing. </td></tr>
    <tr><td class="paramname">storeBitangents</td><td>Set to true when you want the mesh to store its bitangents in its own layer. This will generate a bitangents layer inside the mesh. False will no do this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, or false on failure. A failure can happen when no UV data can be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a42c722cd65be1a901e6c5dd6641d06c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Mesh::CheckIfIsQuadMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this mesh is a pure quad mesh. Please keep in mind that this method is quite heavy to process as it iterates over all polygons to check if the vertex count equals to 4 for all polygons in the worst case. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true in case this mesh contains only quads, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a98ca563bfd2ddf831304abd6a14b5937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Mesh::CheckIfIsTriangleMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this mesh is a pure triangle mesh. Please keep in mind that this method is quite heavy to process as it iterates over all polygons to check if the vertex count equals to 3 for all polygons in the worst case. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true in case this mesh contains only triangles, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a91c622108fdfe425f857cd7878bd8910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_mesh.html#a74479ca439124ede407baf4577c3d946">EMeshType</a> EMotionFX::Mesh::ClassifyMeshType </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceCPUSkinning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>maxInfluences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>maxBonesPerSubMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for a given mesh how we categorize it. A mesh can be either static, like a cube or building, dynamic if it has mesh deformers which have to be processed on the CPU like a morphing deformer or gpu skinned if they only have a skinning deformer applied. There are additional criteria like the maximum number of influences and the maximum number of bones per submesh to make it fit to different hardware specifications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The geometry LOD level of the mesh to check. </td></tr>
    <tr><td class="paramname">actor</td><td>The actor where this mesh belongs to. </td></tr>
    <tr><td class="paramname">nodeIndex</td><td>The index of the node that has this mesh. </td></tr>
    <tr><td class="paramname">forceCPUSkinning</td><td>If true the function will never return MESHTYPE_GPUSKINNED which means that no hardware processing will be used. </td></tr>
    <tr><td class="paramname">maxInfluences</td><td>The maximum number of influences per vertex that can be processed on hardware. If there will be more influences the mesh will be processed in software which will be very slow. </td></tr>
    <tr><td class="paramname">maxBonesPerSubMesh</td><td>The maximum number of bones per submesh can be processed on hardware. If there will be more bones per submesh the mesh will be processed in software which will be very slow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mesh type meaning if the given mesh is static like a cube or building or if is deformed by the GPU or CPU. </dd></dl>

</div>
</div>
<a class="anchor" id="a1465cf4f2d7913c9acd40735b77add84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a>* EMotionFX::Mesh::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clone the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a mesh that contains exactly the same data as this mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="a2332a2532d6b22132f6bfd921accb291"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Mesh::ConvertTo16BitIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the 32-bit vertex indices to 16-bit index values. Do not call this function more than once per mesh. The number of indices will stay the same while the size of the index buffer will be half as big as before. When calling <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a9c2e6afb48191b77cb2f3db08cdc0122">GetIndices()</a> make sure to type-cast the returned pointer to an uint16*. </p>
<dl class="section return"><dt>Returns</dt><dd>True in case all indices have been ported correctly, false if any of the indices was out of the 16-bit range. </dd></dl>

</div>
</div>
<a class="anchor" id="aa00faffad79433d916e36adf959b13e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a>* EMotionFX::Mesh::Create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="adf3cddd2b23acc7486e8e171258fa698"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a>* EMotionFX::Mesh::Create </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numOrgVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCollisionMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor which allocates mesh data. Please keep in mind that this does not create and add any layers for position, normal, tangent, uv data etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numVerts</td><td>The number of vertices to allocate. </td></tr>
    <tr><td class="paramname">numIndices</td><td>The number of indices to allocate. </td></tr>
    <tr><td class="paramname">numPolygons</td><td>The number of polygons to allocate. </td></tr>
    <tr><td class="paramname">numOrgVerts</td><td>The number of original vertices. </td></tr>
    <tr><td class="paramname">isCollisionMesh</td><td>Set to true if this mesh is a collision mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f73e7f7ecff00bfdb4fece222b34d2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::ExtractOriginalVertexPositions </td>
          <td>(</td>
          <td class="paramtype">AZStd::vector&lt; AZ::Vector3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outPoints</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a list of positions of the original vertices. For a cube, which normally might have 32 vertices, it will result in 8 positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outPoints</td><td>The output array to store the points in. The array will be automatically resized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0fe3f6ae91929acaa29bfe3c75f62bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* EMotionFX::Mesh::FindOriginalVertexData </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>layerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find specific original vertex data in the mesh. The difference between the original vertex data and current vertex data as returned by FindVertexData is that the original vertex data is the data stored in the base pose, before any mesh deformers are being applied to it. Here are some examples to get common vertex data:</p>
<pre>
Vector3* positions = (Vector3*)mesh-&gt;FindOriginalVertexData( Mesh::ATTRIB_POSITIONS );   // the positions
Vector3* normals   = (Vector3*)mesh-&gt;FindOriginalVertexData( Mesh::ATTRIB_NORMALS   );   // the normals
Vector4* tangents  = (Vector4*)mesh-&gt;FindOriginalVertexData( Mesh::ATTRIB_TANGENTS  );   // first set of tangents, can be nullptr, and note the Vector4!
AZ::Vector2* uvCoords  = static_cast&lt;AZ::Vector2*&gt;(mesh-&gt;FindOriginalVertexData( Mesh::ATTRIB_UVCOORDS  ));  // the first set of UVs, can be nullptr
AZ::Vector2* uvCoords2 = static_cast&lt;AZ::Vector2*&gt;(mesh-&gt;FindOriginalVertexData( Mesh::ATTRIB_UVCOORDS, 1 ));    // the second set of UVs, can be nullptr
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerID</td><td>The layer type ID to get the information from. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The layer number to get. Where 0 means the first layer, 1 means the second, etc. This is used when there are multiple layers of the same type. An example is a mesh having multiple UV layers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the layer data. You have to typecast yourself. </dd></dl>

</div>
</div>
<a class="anchor" id="ad242b0e3bbcca6ec6142fe47837d37e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a>* EMotionFX::Mesh::FindSharedVertexAttributeLayer </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>layerTypeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>occurence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the shared vertex attribute layer of a given type. If you like to find the first layer of the given type, the occurence parameter must be set to a value of 0. If you like to find the second layer of this type, the occurence parameter must be set to a value of of 1, etc. This function will return nullptr when the layer cannot be found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerTypeID</td><td>the layer type ID to search for. </td></tr>
    <tr><td class="paramname">occurence</td><td>The occurence to search for. Set to 0 when you want the first layer of this type, set to 1 if you want the second layer of the given type, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex attribute layer, or nullptr when none could be found. </dd></dl>

</div>
</div>
<a class="anchor" id="afd98c248fc392eefbb763dc819dcd9f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::FindSharedVertexAttributeLayerNumber </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>layerTypeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the shared vertex attribute layer of a given type. If you like to find the first layer of the given type, the occurence parameter must be set to a value of 0. If you like to find the second layer of this type, the occurence parameter must be set to a value of of 1, etc. This function will return nullptr when the layer cannot be found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerTypeID</td><td>the layer type ID to search for. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurence to search for. Set to 0 when you want the first layer of this type, set to 1 if you want the second layer of the given type, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertex attribute layer index number that you can pass to GetSharedVertexAttributeLayer. A value of MCORE_INVALIDINDEX32 is returned when no result could be found. </dd></dl>

</div>
</div>
<a class="anchor" id="abc17a07666dc631690f8f40c0f8c56d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a>* EMotionFX::Mesh::FindVertexAttributeLayer </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>layerTypeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>occurence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the non-shared vertex attribute layer of a given type. If you like to find the first layer of the given type, the occurence parameter must be set to a value of 0. If you like to find the second layer of this type, the occurence parameter must be set to a value of of 1, etc. This function will return nullptr when the layer cannot be found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerTypeID</td><td>the layer type ID to search for. </td></tr>
    <tr><td class="paramname">occurence</td><td>The occurence to search for. Set to 0 when you want the first layer of this type, set to 1 if you want the second layer of the given type, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex attribute layer, or nullptr when none could be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a073c3bc959b30a5155e5a79b8d786995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::FindVertexAttributeLayerNumber </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>layerTypeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the non-shared vertex attribute layer of a given type. If you like to find the first layer of the given type, the occurence parameter must be set to a value of 0. If you like to find the second layer of this type, the occurence parameter must be set to a value of of 1, etc. This function will return nullptr when the layer cannot be found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerTypeID</td><td>the layer type ID to search for. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurence to search for. Set to 0 when you want the first layer of this type, set to 1 if you want the second layer of the given type, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertex attribute layer index number that you can pass to GetSharedVertexAttributeLayer. A value of MCORE_INVALIDINDEX32 os returned when no result could be found. </dd></dl>

</div>
</div>
<a class="anchor" id="aead97634074d83ef66c63fbbdbab274a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* EMotionFX::Mesh::FindVertexData </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>layerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find specific current vertex data in the mesh. This contains the vertex data after mesh deformers have been applied to them. If you want the vertex data before any mesh deformers have been applied to it, use the method named FindOriginalVertexData instead. Here are some examples to get common vertex data:</p>
<pre>
Vector3* positions = (Vector3*)mesh-&gt;FindVertexData( Mesh::ATTRIB_POSITIONS );   // the positions
Vector3* normals   = (Vector3*)mesh-&gt;FindVertexData( Mesh::ATTRIB_NORMALS   );   // the normals
Vector4* tangents  = (Vector4*)mesh-&gt;FindVertexData( Mesh::ATTRIB_TANGENTS  );   // first set of tangents, can be nullptr, and note the Vector4!
AZ::Vector2* uvCoords  = static_cast&lt;AZ::Vector2*&gt;(mesh-&gt;FindVertexData( Mesh::ATTRIB_UVCOORDS  ));  // the first set of UVs, can be nullptr
AZ::Vector2* uvCoords2 = static_cast&lt;AZ::Vector2*&gt;(mesh-&gt;FindVertexData( Mesh::ATTRIB_UVCOORDS, 1 ));    // the second set of UVs, can be nullptr
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerID</td><td>The layer type ID to get the information from. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The layer number to get. Where 0 means the first layer, 1 means the second, etc. This is used when there are multiple layers of the same type. An example is a mesh having multiple UV layers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the layer data. You have to typecast yourself. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6224a3e7ec8b35bd28a914ad25a13b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::GatherBonesForFace </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>startIndexOfFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::vector&lt; <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>outBones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gather all bones influencing a specified face into a specified array. The outBones array will be cleared when it enters the method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startIndexOfFace</td><td>The start index of the first vertex of the face. So not the vertex number, but the offset in the index array of this mesh. </td></tr>
    <tr><td class="paramname">outBones</td><td>The array to store the pointers to the bones in. Any existing array contents will be cleared when it enters the method. </td></tr>
    <tr><td class="paramname">actor</td><td>The actor to search the bones in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b3e5528732d4994f83a660e7099225c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint16 Mesh::GetHighestJointIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the highest id of all the jointId's used by this mesh </p>

</div>
</div>
<a class="anchor" id="a9c2e6afb48191b77cb2f3db08cdc0122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 * Mesh::GetIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the face indices. Every face has 3 indices and all faces indices are stored after eachother. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the face index data. </dd></dl>

</div>
</div>
<a class="anchor" id="aab1284a842416cc6283250ba3f7f45ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 Mesh::GetNumIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of indices in the mesh, which is the sum of all polygon vertex counts. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of indices in the mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b89bf192da6d7746ea7d8274a9381be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 Mesh::GetNumOrgVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of original vertices. This can be lower compared to the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#af53ef2b52927b66f50abd5a2e7fb86ac">GetNumVertices()</a>. For the example of the cube with 8 real vertices, but 24 vertices in this mesh, this method would return a value of 8, while the method <a class="el" href="class_e_motion_f_x_1_1_mesh.html#af53ef2b52927b66f50abd5a2e7fb86ac">GetNumVertices()</a> would return 24. Please keep in mind that the number of elements in the array returned by GetOrgVerts() however equals the amount returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#af53ef2b52927b66f50abd5a2e7fb86ac">GetNumVertices()</a> and not the amount returned by this method! </p>
<dl class="section return"><dt>Returns</dt><dd>The number of original vertices in the mesh (which are not stored). </dd></dl>

</div>
</div>
<a class="anchor" id="a447a5a7ea83acab229af54c65670f1ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 Mesh::GetNumPolygons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of polygons. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of polygons inside this mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1844033ff1bc40fb73d7dc868759beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::GetNumSharedVertexAttributeLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of shared vertex attributes. This value is the same for all shared vertices. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of shared vertex attributes for every vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a3c0c2b612b68d6b00f14cc477f0265"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t Mesh::GetNumSubMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of sub meshes currently in the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of sub meshes. </dd></dl>

</div>
</div>
<a class="anchor" id="a27f9bdefb239beb7df8bda9b0b4d71dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint16 Mesh::GetNumUniqueJoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of unique joints that impact this mesh </p>

</div>
</div>
<a class="anchor" id="a17906be1e9f58b8f75e5b1b2434eb8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::GetNumVertexAttributeLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of vertex attributes. This value is the same for all vertices. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertex attributes for every vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="af53ef2b52927b66f50abd5a2e7fb86ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 Mesh::GetNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of vertices in the mesh. The number of positions, normals and uv coordinates is equal to the value returned by this method. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5ef83765bb84f398cd5da4fd6b49cfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint8 * Mesh::GetPolygonVertexCounts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the polygon vertex count. Every polygon stores an integer which represents the number of vertices/indices this polygon stores. The length of this array equals <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a447a5a7ea83acab229af54c65670f1ea">GetNumPolygons()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the polygon vertex count. </dd></dl>

</div>
</div>
<a class="anchor" id="a773c748b0f41d6f0fa147cd81a7cc191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a>* EMotionFX::Mesh::GetSharedVertexAttributeLayer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>layerNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the shared vertex attribute data of a given layer. The number of arrays inside the array returned equals the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a4b89bf192da6d7746ea7d8274a9381be">GetNumOrgVertices()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerNr</td><td>The layer number to get the attributes from. Must be below the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#ac1844033ff1bc40fb73d7dc868759beb">GetNumSharedVertexAttributeLayers()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the array of shared vertex attributes. You can typecast this pointer if you know the type of the vertex attributes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0af428f1b59e89db2a7747d414c757e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> * Mesh::GetSubMesh </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a given <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> number to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a98d0521813faf52a966a0b1828a1367d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a>* EMotionFX::Mesh::GetVertexAttributeLayer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>layerNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the vertex attribute data of a given layer. The number of arrays inside the array returned equals the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#af53ef2b52927b66f50abd5a2e7fb86ac">GetNumVertices()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerNr</td><td>The layer number to get the attributes from. Must be below the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a17906be1e9f58b8f75e5b1b2434eb8ad">GetNumVertexAttributeLayers()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the array of vertex attributes. You can typecast this pointer if you know the type of the vertex attributes. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dd1f3fcdba625b600d52c60017afaa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::InsertSubMesh </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>insertIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>subMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a submesh into the array of submeshes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insertIndex</td><td>The position in the submesh array to insert this new submesh. </td></tr>
    <tr><td class="paramname">subMesh</td><td>A pointer to the submesh to insert into this mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49dcfc00e2f6cbff3a3399fb2052b305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Mesh::Intersects </td>
          <td>(</td>
          <td class="paramtype">const Transform &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for an intersection between the mesh and a given ray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transformation of the mesh. </td></tr>
    <tr><td class="paramname">ray</td><td>The ray to test with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when an intersection has occurred, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a57259c94b8e3dba9b2e46242c71c0160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Mesh::Intersects </td>
          <td>(</td>
          <td class="paramtype">const Transform &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>outIntersect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>outBaryU</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>outBaryV</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outIndices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for an intersection between the mesh a given ray, and calculate the closest intersection point. If you do NOT need to know the intersection point, use the other Intersects method, because that one is faster, since it doesn't need to calculate the closest intersection point. The intersection point returned is in object space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transformation of the mesh. </td></tr>
    <tr><td class="paramname">ray</td><td>The ray to test with. </td></tr>
    <tr><td class="paramname">outIntersect</td><td>A pointer to the vector to store the intersection point in, in case of a collision (nullptr allowed). </td></tr>
    <tr><td class="paramname">outBaryU</td><td>A pointer to a float in which the method will store the barycentric U coordinate, to be used to interpolate values on the triangle (nullptr allowed). </td></tr>
    <tr><td class="paramname">outBaryV</td><td>A pointer to a float in which the method will store the barycentric V coordinate, to be used to interpolate values on the triangle (nullptr allowed). </td></tr>
    <tr><td class="paramname">outIndices</td><td>A pointer to an array of 3 integers, which will contain the 3 vertex indices of the closest intersecting triangle. Even on polygon meshes with polygons of more than 3 vertices three indices are returned. In that case the indices represent a sub-triangle inside the polygon. A value of nullptr is allowed, which will skip storing the resulting triangle indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when an intersection has occurred, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="af0bfc10dcea75e3a93d82370e5998fbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::Log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debug log information. Information will be logged using LOGLEVEL_DEBUG. </p>

</div>
</div>
<a class="anchor" id="a25afdbb4978287faaeec38c81c442d0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::ReleaseData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all allocated mesh data. </p>

</div>
</div>
<a class="anchor" id="a1274e274dd880316a2f56792c8e4d378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::RemoveAllSharedVertexAttributeLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all shared vertex attributes for all shared vertices. The previously allocated attributes will be deleted from memory automatically. </p>

</div>
</div>
<a class="anchor" id="adcf9ef53e2acab164ceda0b0138f68b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::RemoveAllVertexAttributeLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all vertex attributes for all vertices. The previously allocated attributes will be deleted from memory automatically. </p>

</div>
</div>
<a class="anchor" id="a5e98e5d5549611c54af8599a7e3e11c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Mesh::RemoveEmptySubMeshes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyRemoveOnZeroVertsAndTriangles</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all empty submeshes. A submesh is either empty if it has no vertices or no indices or a combination of both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">onlyRemoveOnZeroVertsAndTriangles</td><td>Only remove when both the number of vertices and number of indices/triangles are zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of removed submeshes. </dd></dl>

</div>
</div>
<a class="anchor" id="a94e0a08ab1a3b639635eb2e8c9def3af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::RemoveSharedVertexAttributeLayer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>layerNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a layer of shared vertex attributes. Automatically deletes the data from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerNr</td><td>The layer number to remove, must be below the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#ac1844033ff1bc40fb73d7dc868759beb">GetNumSharedVertexAttributeLayers()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f20ff4d2fe2e3dbc21cfa5dad3840ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::RemoveSubMesh </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delFromMem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a given submesh from this mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The submesh index number to remove, which must be in range of 0..<a class="el" href="class_e_motion_f_x_1_1_mesh.html#a8a3c0c2b612b68d6b00f14cc477f0265">GetNumSubMeshes()</a>-1. </td></tr>
    <tr><td class="paramname">delFromMem</td><td>Set to true when you want to delete the submesh from memory as well, otherwise set to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2560197f1f0b4b7217245b9c18a0169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::RemoveVertexAttributeLayer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>layerNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a layer of vertex attributes. Automatically deletes the data from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerNr</td><td>The layer number to remove, must be below the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a17906be1e9f58b8f75e5b1b2434eb8ad">GetNumVertexAttributeLayers()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0623680dc451b34751ccaeb87e24164d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::RemoveVertices </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>startVertexNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>endVertexNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changeIndexBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeEmptySubMeshes</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a specific range of vertices from the mesh. This also might change all pointers to vertex and index data returned by this mesh and its submeshes. This automatically also adjusts the index buffer as well. Please note that the specified end vertex will also be removed! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startVertexNr</td><td>The vertex number to start removing from. </td></tr>
    <tr><td class="paramname">endVertexNr</td><td>The last vertex number to remove, this value must be bigger or equal than the start vertex number. </td></tr>
    <tr><td class="paramname">changeIndexBuffer</td><td>If this is set to true, the index buffer will be modified on such a way that all vertex number indexed by the index buffer, which are above the startVertexNr parameter value, will be decreased by the amount of removed vertices. </td></tr>
    <tr><td class="paramname">removeEmptySubMeshes</td><td>When set to true (default) submeshes that become empty will be removed from memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8ca791009248832cd0496ff73c8f0b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::ReserveVertexAttributeLayerSpace </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLayers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserve space for the given amount of vertex attribute layers. This just pre-allocates array data to prevent reallocs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numLayers</td><td>The number of layers to reserve space for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4fee5797e3828123e231b1170b9e226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::ResetToOriginalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets all final/output vertex data to its original data, as it was before any deformers where applied. This will copy the original positions over the final positions, the original normals over the final normals and the original uv coordinates over the final uv coordinates. </p>

</div>
</div>
<a class="anchor" id="ad112685558a7e06b55ce2b3ade27fdcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::Scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale all positional data. This is a slow operation and is used to convert between different unit systems (cm, meters, etc). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleFactor</td><td>The scale factor to scale the current data by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac03161687cca6537bd03a698ebdc774d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Mesh::SetHighestJointIndex </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>highestJointIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the highest id of all the jointId's used by this mesh </p>

</div>
</div>
<a class="anchor" id="a5ebb650da465324efd692ab814434c18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void EMotionFX::Mesh::SetNumSubMeshes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numSubMeshes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the number of submeshes. This adjusts the number returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a8a3c0c2b612b68d6b00f14cc477f0265">GetNumSubMeshes()</a>. Do not forget to use <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a5392da8c162a0eec1b0bb0d003c39b49">SetSubMesh()</a> to initialize all submeshes! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numSubMeshes</td><td>The number of submeshes to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac37bd552db831b7262c4bcc933bd1261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Mesh::SetNumUniqueJoints </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numUniqueJoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the total number of unique joints that impact this mesh </p>

</div>
</div>
<a class="anchor" id="a5392da8c162a0eec1b0bb0d003c39b49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void EMotionFX::Mesh::SetSubMesh </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>subMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the value for a given submesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The submesh number, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_mesh.html#a8a3c0c2b612b68d6b00f14cc477f0265">GetNumSubMeshes()</a>-1]. </td></tr>
    <tr><td class="paramname">subMesh</td><td>The submesh to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d5394c97e04347edfa96bda771a8bda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Mesh::SwapVertex </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap two vertices. This will swap all data elements, such as position and normals. Not only it will swap the basic data like position and normals, but also all vertex attributes. This method is used by the meshes support inside GetEMotionFX(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexA</td><td>The first vertex number. </td></tr>
    <tr><td class="paramname">vertexB</td><td>The second vertex number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does NOT update the index buffer! </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a291b23cc59da17172e69d123296bafd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16 EMotionFX::Mesh::m_highestJointIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The highest id of all the joints used by this mesh </p>

</div>
</div>
<a class="anchor" id="ae280fb009c6d1a1856a9f8e94381399e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32* EMotionFX::Mesh::m_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array of indices, which define the faces. </p>

</div>
</div>
<a class="anchor" id="a41405c1010501335506da827282cd66d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Mesh::m_isCollisionMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is this mesh a collision mesh? </p>

</div>
</div>
<a class="anchor" id="accd9156a4feea977aea3227886f0ee9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 EMotionFX::Mesh::m_numIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of indices. </p>

</div>
</div>
<a class="anchor" id="a3552b7b7d73165068defc6d7f054bf63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 EMotionFX::Mesh::m_numOrgVerts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of original vertices. </p>

</div>
</div>
<a class="anchor" id="ae5d5ad8a82a6e5d96f546a98805820a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 EMotionFX::Mesh::m_numPolygons</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of polygons in this mesh. </p>

</div>
</div>
<a class="anchor" id="a7eaf7448d8a4b2c706077cce5ffa092a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16 EMotionFX::Mesh::m_numUniqueJoints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of unique joints </p>

</div>
</div>
<a class="anchor" id="a0e79f60e49336aecf660a6160befef41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 EMotionFX::Mesh::m_numVertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vertices. </p>

</div>
</div>
<a class="anchor" id="af6dd1c8f5ae50408a6c57048567abb54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8* EMotionFX::Mesh::m_polyVertexCounts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of vertices for each polygon, where the length of this array equals the number of polygons. </p>

</div>
</div>
<a class="anchor" id="a96cda2f71802d3aac98e00f0ec99584b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::vector&lt; <a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a>* &gt; EMotionFX::Mesh::m_sharedVertexAttributes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array of shared vertex attribute layers. The number of attributes in each shared layer will be equal to the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#a4b89bf192da6d7746ea7d8274a9381be">Mesh::GetNumOrgVertices()</a>. </p>

</div>
</div>
<a class="anchor" id="a823c869eba4a89d445673b6be6536d11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::vector&lt;<a class="el" href="class_e_motion_f_x_1_1_sub_mesh.html">SubMesh</a>*&gt; EMotionFX::Mesh::m_subMeshes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The collection of sub meshes. </p>

</div>
</div>
<a class="anchor" id="afebb29df2c476e90b0da44164985533a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::vector&lt; <a class="el" href="class_e_motion_f_x_1_1_vertex_attribute_layer.html">VertexAttributeLayer</a>* &gt; EMotionFX::Mesh::m_vertexAttributes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array of non-shared vertex attribute layers. The number of attributes in each shared layer will be equal to the value returned by <a class="el" href="class_e_motion_f_x_1_1_mesh.html#af53ef2b52927b66f50abd5a2e7fb86ac">Mesh::GetNumVertices()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Gems/EMotionFX/Code/EMotionFX/Source/Mesh.h</li>
<li>Gems/EMotionFX/Code/EMotionFX/Source/Mesh.inl</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>EMotionFX</b></li><li class="navelem"><a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a></li>
    <li class="footer">Generated on Thu Apr 20 2023 21:15:45 for Open 3D Engine EMotionFX Gem API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
