<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine EMotionFX Gem API Reference: EMotionFX::MotionInstance Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">23.05.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_e_motion_f_x_1_1_motion_instance.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_e_motion_f_x_1_1_motion_instance-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EMotionFX::MotionInstance Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;MotionInstance.h&gt;</code></p>

<p>Inherits <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_in.html">PlayStateIn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_out.html">PlayStateOut</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68c2849ea9f7e77faefa19693b6fed92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a68c2849ea9f7e77faefa19693b6fed92">Update</a> (float timePassed)</td></tr>
<tr class="separator:a68c2849ea9f7e77faefa19693b6fed92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987b09a2ecd9d87fe0682ff967fc700e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a987b09a2ecd9d87fe0682ff967fc700e">UpdateByTimeValues</a> (float oldTime, float newTime, <a class="el" href="class_e_motion_f_x_1_1_anim_graph_event_buffer.html">AnimGraphEventBuffer</a> *outEventBuffer)</td></tr>
<tr class="separator:a987b09a2ecd9d87fe0682ff967fc700e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346d455b56bb1469caf1a10b79a55124"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a346d455b56bb1469caf1a10b79a55124"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessEvents</b> (float oldTime, float newTime)</td></tr>
<tr class="separator:a346d455b56bb1469caf1a10b79a55124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e82fcf7e6e98a64579efd39ddd73d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8e82fcf7e6e98a64579efd39ddd73d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractEvents</b> (float oldTime, float newTime, <a class="el" href="class_e_motion_f_x_1_1_anim_graph_event_buffer.html">AnimGraphEventBuffer</a> *outBuffer)</td></tr>
<tr class="separator:ab8e82fcf7e6e98a64579efd39ddd73d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeb91af583f7c67273883381732f33d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfeb91af583f7c67273883381732f33d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractEventsNonLoop</b> (float oldTime, float newTime, <a class="el" href="class_e_motion_f_x_1_1_anim_graph_event_buffer.html">AnimGraphEventBuffer</a> *outBuffer)</td></tr>
<tr class="separator:abfeb91af583f7c67273883381732f33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc170e601d61aa3ca004b594116ce1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a7cc170e601d61aa3ca004b594116ce1a">SetCustomData</a> (void *customDataPointer)</td></tr>
<tr class="separator:a7cc170e601d61aa3ca004b594116ce1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeead0d06a5c2e9f788441efb1e00b769"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#aeead0d06a5c2e9f788441efb1e00b769">GetCustomData</a> () const </td></tr>
<tr class="separator:aeead0d06a5c2e9f788441efb1e00b769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bdabe874105c76492e88da3e2053cf"><td class="memItemLeft" align="right" valign="top">AZ::u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a36bdabe874105c76492e88da3e2053cf">GetID</a> () const </td></tr>
<tr class="separator:a36bdabe874105c76492e88da3e2053cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ea2dc8427dcabaa1082fff7ced67db"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ae0ea2dc8427dcabaa1082fff7ced67db">GetBlendInTime</a> () const </td></tr>
<tr class="separator:ae0ea2dc8427dcabaa1082fff7ced67db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178b1385015ed542e5a6b27c9248af59"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a178b1385015ed542e5a6b27c9248af59">GetCurrentTime</a> () const </td></tr>
<tr class="separator:a178b1385015ed542e5a6b27c9248af59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2608171aeb5b0306a2c8acc8234322ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a2608171aeb5b0306a2c8acc8234322ee">AZ_DEPRECATED</a> (float GetMaxTime() const,&quot;This method has been deprecated. Please use <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ad3009760a8a34cb5a2669cea20a99d87">MotionInstance::GetDuration</a>() instead.&quot;)</td></tr>
<tr class="separator:a2608171aeb5b0306a2c8acc8234322ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3009760a8a34cb5a2669cea20a99d87"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ad3009760a8a34cb5a2669cea20a99d87">GetDuration</a> () const </td></tr>
<tr class="separator:ad3009760a8a34cb5a2669cea20a99d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a609e8bbe745ca795c161e78af9a89"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a32a609e8bbe745ca795c161e78af9a89">GetPlaySpeed</a> () const </td></tr>
<tr class="separator:a32a609e8bbe745ca795c161e78af9a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8e85fd58c890a90a8d2c97628649ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a0e8e85fd58c890a90a8d2c97628649ce">GetMotion</a> () const </td></tr>
<tr class="separator:a0e8e85fd58c890a90a8d2c97628649ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5501a89faf8ca88b143c5aff40aedad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5501a89faf8ca88b143c5aff40aedad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMotion</b> (<a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a> *motion)</td></tr>
<tr class="separator:ab5501a89faf8ca88b143c5aff40aedad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be29267ff31bb9a0b41875203a27d10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a7be29267ff31bb9a0b41875203a27d10">SetCurrentTimeNormalized</a> (float normalizedTimeValue)</td></tr>
<tr class="separator:a7be29267ff31bb9a0b41875203a27d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdb3d6991678a65275033a0a9dceceb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#aafdb3d6991678a65275033a0a9dceceb">GetCurrentTimeNormalized</a> () const </td></tr>
<tr class="separator:aafdb3d6991678a65275033a0a9dceceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcec4e73fc1a585a4b144a27aa3fbda1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#adcec4e73fc1a585a4b144a27aa3fbda1">SetCurrentTime</a> (float time, bool resetLastTime=true)</td></tr>
<tr class="separator:adcec4e73fc1a585a4b144a27aa3fbda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950d3d78c75c8d6cf2470448d2c8136d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a950d3d78c75c8d6cf2470448d2c8136d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLastCurrentTime</b> (float timeInSeconds)</td></tr>
<tr class="separator:a950d3d78c75c8d6cf2470448d2c8136d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5640413d82f853cf9fd6d28de449a890"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a5640413d82f853cf9fd6d28de449a890">GetLastCurrentTime</a> () const </td></tr>
<tr class="separator:a5640413d82f853cf9fd6d28de449a890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38157c04abe640a217b0bb1d65af3fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ad38157c04abe640a217b0bb1d65af3fb">SetPlaySpeed</a> (float speed)</td></tr>
<tr class="separator:ad38157c04abe640a217b0bb1d65af3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f610dd3584ea31d720e680dcbccf3ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a7f610dd3584ea31d720e680dcbccf3ac">SetPlayMode</a> (EPlayMode mode)</td></tr>
<tr class="separator:a7f610dd3584ea31d720e680dcbccf3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f457a117c76deee7f14151a2793612"><td class="memItemLeft" align="right" valign="top">EPlayMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ad9f457a117c76deee7f14151a2793612">GetPlayMode</a> () const </td></tr>
<tr class="separator:ad9f457a117c76deee7f14151a2793612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546d17fcb5fce4546e49db64d827cba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a546d17fcb5fce4546e49db64d827cba0">UpdateTime</a> (float timePassed)</td></tr>
<tr class="separator:a546d17fcb5fce4546e49db64d827cba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143b67af5b1dbe415f9f2a336043cebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a143b67af5b1dbe415f9f2a336043cebd">SetFadeTime</a> (float fadeTime)</td></tr>
<tr class="separator:a143b67af5b1dbe415f9f2a336043cebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576257559e28d262d1afec5b02d308e9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a576257559e28d262d1afec5b02d308e9">GetFadeTime</a> () const </td></tr>
<tr class="separator:a576257559e28d262d1afec5b02d308e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4772806cfb1294ec189c965f9d27587a"><td class="memItemLeft" align="right" valign="top">EMotionBlendMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a4772806cfb1294ec189c965f9d27587a">GetBlendMode</a> () const </td></tr>
<tr class="separator:a4772806cfb1294ec189c965f9d27587a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e82117acd445389927496212bb16de2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e82117acd445389927496212bb16de2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetIsInPlace</b> () const </td></tr>
<tr class="separator:a0e82117acd445389927496212bb16de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3dadf87b63756909356886503c6c2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab3dadf87b63756909356886503c6c2b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetIsInPlace</b> (bool inPlace)</td></tr>
<tr class="separator:aab3dadf87b63756909356886503c6c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d373063ab5f61c1dd1fc67c6982206c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a8d373063ab5f61c1dd1fc67c6982206c">GetWeight</a> () const </td></tr>
<tr class="separator:a8d373063ab5f61c1dd1fc67c6982206c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2783aec1177375986d6c7d6214742541"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a2783aec1177375986d6c7d6214742541">GetTargetWeight</a> () const </td></tr>
<tr class="separator:a2783aec1177375986d6c7d6214742541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae04e6f3220148fe988e767faefeaff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a0ae04e6f3220148fe988e767faefeaff">SetWeight</a> (float targetWeight, float blendTimeInSeconds=0)</td></tr>
<tr class="separator:a0ae04e6f3220148fe988e767faefeaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29ba52339653edbb35c25d01ee0817d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ab29ba52339653edbb35c25d01ee0817d">SetBlendMode</a> (EMotionBlendMode mode)</td></tr>
<tr class="separator:ab29ba52339653edbb35c25d01ee0817d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b8c96637cbf0bb8b2f40fcac7ff72c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a13b8c96637cbf0bb8b2f40fcac7ff72c">SetMirrorMotion</a> (bool enabled)</td></tr>
<tr class="separator:a13b8c96637cbf0bb8b2f40fcac7ff72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe5c8d9f7b324bffc4f8a272d4395c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a4fe5c8d9f7b324bffc4f8a272d4395c1">GetMirrorMotion</a> () const </td></tr>
<tr class="separator:a4fe5c8d9f7b324bffc4f8a272d4395c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6205142f84b2e94a98a76fb658921f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ae6205142f84b2e94a98a76fb658921f2">Rewind</a> ()</td></tr>
<tr class="separator:ae6205142f84b2e94a98a76fb658921f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecd79d444ff862f8d775919caf1e709"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#aaecd79d444ff862f8d775919caf1e709">GetHasEnded</a> () const </td></tr>
<tr class="separator:aaecd79d444ff862f8d775919caf1e709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bac1d319c7d7e0aa8dea603729906e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a60bac1d319c7d7e0aa8dea603729906e">SetMixMode</a> (bool mixModeEnabled)</td></tr>
<tr class="separator:a60bac1d319c7d7e0aa8dea603729906e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f505cac55d5cf06ffc3982a0aca04ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a0f505cac55d5cf06ffc3982a0aca04ca">GetIsStopping</a> () const </td></tr>
<tr class="separator:a0f505cac55d5cf06ffc3982a0aca04ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c2c2c8a4c663051c61b391b97b5e4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a78c2c2c8a4c663051c61b391b97b5e4a">GetIsPlaying</a> () const </td></tr>
<tr class="separator:a78c2c2c8a4c663051c61b391b97b5e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763eeaf24f09d60f87fd76034a220c55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a763eeaf24f09d60f87fd76034a220c55">GetIsMixing</a> () const </td></tr>
<tr class="separator:a763eeaf24f09d60f87fd76034a220c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c3eb37bc34d93ac5fe9d560524e29d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a29c3eb37bc34d93ac5fe9d560524e29d">GetIsBlending</a> () const </td></tr>
<tr class="separator:a29c3eb37bc34d93ac5fe9d560524e29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc308a33762dfe5965e55fd96590d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a71cc308a33762dfe5965e55fd96590d2">Pause</a> ()</td></tr>
<tr class="separator:a71cc308a33762dfe5965e55fd96590d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc529d810b67ff33ee2b084ae1b9fbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#adbc529d810b67ff33ee2b084ae1b9fbe">UnPause</a> ()</td></tr>
<tr class="separator:adbc529d810b67ff33ee2b084ae1b9fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13149e20f70d9a51caf195e7067e8a4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a13149e20f70d9a51caf195e7067e8a4c">SetPause</a> (bool pauseEnabled)</td></tr>
<tr class="separator:a13149e20f70d9a51caf195e7067e8a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67846d572a2e4db48009a23c7c593872"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a67846d572a2e4db48009a23c7c593872">GetIsPaused</a> () const </td></tr>
<tr class="separator:a67846d572a2e4db48009a23c7c593872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7ee6e0f0b70fba30b0faad1c73901c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a0f7ee6e0f0b70fba30b0faad1c73901c">SetMaxLoops</a> (AZ::u32 numLoops)</td></tr>
<tr class="separator:a0f7ee6e0f0b70fba30b0faad1c73901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d1bc5be6cb50b7c3849a9ea255a772"><td class="memItemLeft" align="right" valign="top">AZ::u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a93d1bc5be6cb50b7c3849a9ea255a772">GetMaxLoops</a> () const </td></tr>
<tr class="separator:a93d1bc5be6cb50b7c3849a9ea255a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ee4117196903790be7d310a41fb551"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a56ee4117196903790be7d310a41fb551">GetHasLooped</a> () const </td></tr>
<tr class="separator:a56ee4117196903790be7d310a41fb551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36beef8b599b6aba51b6090f61758a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#aa36beef8b599b6aba51b6090f61758a0">SetNumCurrentLoops</a> (AZ::u32 numCurrentLoops)</td></tr>
<tr class="separator:aa36beef8b599b6aba51b6090f61758a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7613a80e38775556ab42ab963a65594f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7613a80e38775556ab42ab963a65594f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetNumLastLoops</b> (AZ::u32 numCurrentLoops)</td></tr>
<tr class="separator:a7613a80e38775556ab42ab963a65594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2487bbf18834aa75fe8bf6598313888f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2487bbf18834aa75fe8bf6598313888f"></a>
AZ::u32&#160;</td><td class="memItemRight" valign="bottom"><b>GetNumLastLoops</b> () const </td></tr>
<tr class="separator:a2487bbf18834aa75fe8bf6598313888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d6a0b66a55c0462f885a525609b74f"><td class="memItemLeft" align="right" valign="top">AZ::u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a41d6a0b66a55c0462f885a525609b74f">GetNumCurrentLoops</a> () const </td></tr>
<tr class="separator:a41d6a0b66a55c0462f885a525609b74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c531c75d188a0275df025ad1a5db46e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a8c531c75d188a0275df025ad1a5db46e">GetIsPlayingForever</a> () const </td></tr>
<tr class="separator:a8c531c75d188a0275df025ad1a5db46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aac69c504159ff796589d6f0b9d0473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a4aac69c504159ff796589d6f0b9d0473">GetActorInstance</a> () const </td></tr>
<tr class="separator:a4aac69c504159ff796589d6f0b9d0473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fbc46da16a24fdf93eee5c5e38c44f"><td class="memItemLeft" align="right" valign="top">AZ::u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ad3fbc46da16a24fdf93eee5c5e38c44f">GetPriorityLevel</a> () const </td></tr>
<tr class="separator:ad3fbc46da16a24fdf93eee5c5e38c44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906edeb5ba568d9f81707733fe7b3506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a906edeb5ba568d9f81707733fe7b3506">SetPriorityLevel</a> (AZ::u32 priorityLevel)</td></tr>
<tr class="separator:a906edeb5ba568d9f81707733fe7b3506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2706c6519769d87f64297eb418f6085f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a2706c6519769d87f64297eb418f6085f">GetMotionExtractionEnabled</a> () const </td></tr>
<tr class="separator:a2706c6519769d87f64297eb418f6085f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ad739c8ec99cd87d0ae837fa3b2e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a21ad739c8ec99cd87d0ae837fa3b2e74">SetMotionExtractionEnabled</a> (bool enable)</td></tr>
<tr class="separator:a21ad739c8ec99cd87d0ae837fa3b2e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392b3575445087439c1b1dfc0691f60c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a392b3575445087439c1b1dfc0691f60c">GetCanOverwrite</a> () const </td></tr>
<tr class="separator:a392b3575445087439c1b1dfc0691f60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443a1e1fff7b001bd506d8908a28fe2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a443a1e1fff7b001bd506d8908a28fe2b">SetCanOverwrite</a> (bool canOverwrite)</td></tr>
<tr class="separator:a443a1e1fff7b001bd506d8908a28fe2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac724d18e4a841a339cdc15911c1e7ca7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ac724d18e4a841a339cdc15911c1e7ca7">GetDeleteOnZeroWeight</a> () const </td></tr>
<tr class="separator:ac724d18e4a841a339cdc15911c1e7ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9262ba4899933f4a1e3c0113cf9c75aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a9262ba4899933f4a1e3c0113cf9c75aa">SetDeleteOnZeroWeight</a> (bool deleteOnZeroWeight)</td></tr>
<tr class="separator:a9262ba4899933f4a1e3c0113cf9c75aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d396aa48c62b941f1d99786ceb837d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a3d396aa48c62b941f1d99786ceb837d2">Stop</a> (float fadeOutTime)</td></tr>
<tr class="separator:a3d396aa48c62b941f1d99786ceb837d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823cf8dc1886a48dd632a12ecec75b4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a823cf8dc1886a48dd632a12ecec75b4f">Stop</a> ()</td></tr>
<tr class="separator:a823cf8dc1886a48dd632a12ecec75b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f27fea4b43ec54966bef3f40e8c2d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ac1f27fea4b43ec54966bef3f40e8c2d4">GetRetargetingEnabled</a> () const </td></tr>
<tr class="separator:ac1f27fea4b43ec54966bef3f40e8c2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e969aae8abc5d6f8826a4bfa40f550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a12e969aae8abc5d6f8826a4bfa40f550">SetRetargetingEnabled</a> (bool enabled)</td></tr>
<tr class="separator:a12e969aae8abc5d6f8826a4bfa40f550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf4e49da292ef5e6bcd285ac0f89336"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#adaf4e49da292ef5e6bcd285ac0f89336">GetIsActive</a> () const </td></tr>
<tr class="separator:adaf4e49da292ef5e6bcd285ac0f89336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3671ddfb5c75bbc4a07b5297a0b146b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ad3671ddfb5c75bbc4a07b5297a0b146b">SetIsActive</a> (bool enabled)</td></tr>
<tr class="separator:ad3671ddfb5c75bbc4a07b5297a0b146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac624d82a9c1e90c5a9d2b817bbf71b69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ac624d82a9c1e90c5a9d2b817bbf71b69">GetIsFrozen</a> () const </td></tr>
<tr class="separator:ac624d82a9c1e90c5a9d2b817bbf71b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909d514e8d68493c2994a01eaeb02eb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a909d514e8d68493c2994a01eaeb02eb1">SetIsFrozen</a> (bool isFrozen)</td></tr>
<tr class="separator:a909d514e8d68493c2994a01eaeb02eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1e77c1d78dd46900cc9bf2bd298688"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#aae1e77c1d78dd46900cc9bf2bd298688">GetMotionEventsEnabled</a> () const </td></tr>
<tr class="separator:aae1e77c1d78dd46900cc9bf2bd298688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee8729d3f526ac8aa26ccbff7b42118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a3ee8729d3f526ac8aa26ccbff7b42118">SetMotionEventsEnabled</a> (bool enabled)</td></tr>
<tr class="separator:a3ee8729d3f526ac8aa26ccbff7b42118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d50e5ec4bddb8cf2666d33d9ba26f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a76d50e5ec4bddb8cf2666d33d9ba26f0">SetEventWeightThreshold</a> (float weightThreshold)</td></tr>
<tr class="separator:a76d50e5ec4bddb8cf2666d33d9ba26f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d21c0f8fadba382a55a4b3fa8efeef"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a52d21c0f8fadba382a55a4b3fa8efeef">GetEventWeightThreshold</a> () const </td></tr>
<tr class="separator:a52d21c0f8fadba382a55a4b3fa8efeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27db13461e4045e20e82dfa7db01cd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ab27db13461e4045e20e82dfa7db01cd4">GetFreezeAtLastFrame</a> () const </td></tr>
<tr class="separator:ab27db13461e4045e20e82dfa7db01cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dd3c24184e5c3878d31dd4ac494fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a99dd3c24184e5c3878d31dd4ac494fc2">SetBlendOutBeforeEnded</a> (bool enabled)</td></tr>
<tr class="separator:a99dd3c24184e5c3878d31dd4ac494fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8cf66e3a2d5946ca6869a67f2eb38c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a8f8cf66e3a2d5946ca6869a67f2eb38c">GetBlendOutBeforeEnded</a> () const </td></tr>
<tr class="separator:a8f8cf66e3a2d5946ca6869a67f2eb38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af833779dd0822e6d9b003dfe216e8e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#af833779dd0822e6d9b003dfe216e8e37">SetFreezeAtLastFrame</a> (bool enabled)</td></tr>
<tr class="separator:af833779dd0822e6d9b003dfe216e8e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d664f02c7d6b177275a980dd4060e0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#af1d664f02c7d6b177275a980dd4060e0">GetTotalPlayTime</a> () const </td></tr>
<tr class="separator:af1d664f02c7d6b177275a980dd4060e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab08d833cb446117d50042447cbfe6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#aab08d833cb446117d50042447cbfe6f5">SetTotalPlayTime</a> (float playTime)</td></tr>
<tr class="separator:aab08d833cb446117d50042447cbfe6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f70e8e87c30df1fb2e7d4d15ba566c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a59f70e8e87c30df1fb2e7d4d15ba566c">GetMaxPlayTime</a> () const </td></tr>
<tr class="separator:a59f70e8e87c30df1fb2e7d4d15ba566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffe578cc47781ef49273ec65a939525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a7ffe578cc47781ef49273ec65a939525">SetMaxPlayTime</a> (float playTime)</td></tr>
<tr class="separator:a7ffe578cc47781ef49273ec65a939525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1e85e2a4618327c53071dc1366cabd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a1c1e85e2a4618327c53071dc1366cabd">InitFromPlayBackInfo</a> (const <a class="el" href="class_e_motion_f_x_1_1_play_back_info.html">PlayBackInfo</a> &amp;info, bool resetCurrentPlaytime=true)</td></tr>
<tr class="separator:a1c1e85e2a4618327c53071dc1366cabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f70e87dcbaca66493a2d755258b66d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ae2f70e87dcbaca66493a2d755258b66d">GetTimeDifToLoopPoint</a> () const </td></tr>
<tr class="separator:ae2f70e87dcbaca66493a2d755258b66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8ba75c652b3840bb68d732fd5427a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a8a8ba75c652b3840bb68d732fd5427a6">AddEventHandler</a> (<a class="el" href="class_e_motion_f_x_1_1_motion_instance_event_handler.html">MotionInstanceEventHandler</a> *eventHandler)</td></tr>
<tr class="separator:a8a8ba75c652b3840bb68d732fd5427a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39be6c02e49c6d411958bc9b1bb02e19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a39be6c02e49c6d411958bc9b1bb02e19">RemoveEventHandler</a> (<a class="el" href="class_e_motion_f_x_1_1_motion_instance_event_handler.html">MotionInstanceEventHandler</a> *eventHandler)</td></tr>
<tr class="separator:a39be6c02e49c6d411958bc9b1bb02e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfe07237c15b3bfc17e192a8927a09a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a7dfe07237c15b3bfc17e192a8927a09a">RemoveAllEventHandlers</a> ()</td></tr>
<tr class="separator:a7dfe07237c15b3bfc17e192a8927a09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab952d7bfb32a2e7b04dda9f009a5210b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_motion_instance_event_handler.html">MotionInstanceEventHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ab952d7bfb32a2e7b04dda9f009a5210b">GetEventHandler</a> (size_t index) const </td></tr>
<tr class="separator:ab952d7bfb32a2e7b04dda9f009a5210b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50109061187f914518c4f7085cb0660"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ab50109061187f914518c4f7085cb0660">GetNumEventHandlers</a> () const </td></tr>
<tr class="separator:ab50109061187f914518c4f7085cb0660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff5737cd0489e3f3037df4f5cde9820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#aaff5737cd0489e3f3037df4f5cde9820">OnEvent</a> (const <a class="el" href="class_e_motion_f_x_1_1_event_info.html">EventInfo</a> &amp;eventInfo) const </td></tr>
<tr class="separator:aaff5737cd0489e3f3037df4f5cde9820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3187e560afea79450e127e1035ee7cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a3187e560afea79450e127e1035ee7cf2">OnStartMotionInstance</a> (<a class="el" href="class_e_motion_f_x_1_1_play_back_info.html">PlayBackInfo</a> *info)</td></tr>
<tr class="separator:a3187e560afea79450e127e1035ee7cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85628c689a3a724f1d208bb0ee09f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#af85628c689a3a724f1d208bb0ee09f0a">OnDeleteMotionInstance</a> ()</td></tr>
<tr class="separator:af85628c689a3a724f1d208bb0ee09f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff952b874de6f75b9e171d96755a269f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#aff952b874de6f75b9e171d96755a269f">OnStop</a> ()</td></tr>
<tr class="separator:aff952b874de6f75b9e171d96755a269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71e667190238e5ecc9b81cdf1d6707e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ac71e667190238e5ecc9b81cdf1d6707e">OnHasLooped</a> ()</td></tr>
<tr class="separator:ac71e667190238e5ecc9b81cdf1d6707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2906bbf0a01dc66edf00729660d0b128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a2906bbf0a01dc66edf00729660d0b128">OnHasReachedMaxNumLoops</a> ()</td></tr>
<tr class="separator:a2906bbf0a01dc66edf00729660d0b128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d4e3e1a8272570783814a3d4d0ce09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ac9d4e3e1a8272570783814a3d4d0ce09">OnHasReachedMaxPlayTime</a> ()</td></tr>
<tr class="separator:ac9d4e3e1a8272570783814a3d4d0ce09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864bd96207f3262db77969f350dcf3eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a864bd96207f3262db77969f350dcf3eb">OnIsFrozenAtLastFrame</a> ()</td></tr>
<tr class="separator:a864bd96207f3262db77969f350dcf3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2239726eaf58ecae82eef928b290d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a8c2239726eaf58ecae82eef928b290d3">OnChangedPauseState</a> ()</td></tr>
<tr class="separator:a8c2239726eaf58ecae82eef928b290d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c6b19b484f6536565620e24f1fd5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a63c6b19b484f6536565620e24f1fd5ef">OnChangedActiveState</a> ()</td></tr>
<tr class="separator:a63c6b19b484f6536565620e24f1fd5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ee6e665b3097a9112219a9b5033152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ad0ee6e665b3097a9112219a9b5033152">OnStartBlending</a> ()</td></tr>
<tr class="separator:ad0ee6e665b3097a9112219a9b5033152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc105d2b0695ac637e60ffe1058eb4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a7fc105d2b0695ac637e60ffe1058eb4a">OnStopBlending</a> ()</td></tr>
<tr class="separator:a7fc105d2b0695ac637e60ffe1058eb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d09814bf2a6d34cf1c3c94c9991857c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a4d09814bf2a6d34cf1c3c94c9991857c">OnQueueMotionInstance</a> (<a class="el" href="class_e_motion_f_x_1_1_play_back_info.html">PlayBackInfo</a> *info)</td></tr>
<tr class="separator:a4d09814bf2a6d34cf1c3c94c9991857c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5974b537d1b110f37592da7ddaa692d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a5974b537d1b110f37592da7ddaa692d9">SetIsOwnedByRuntime</a> (bool isOwnedByRuntime)</td></tr>
<tr class="separator:a5974b537d1b110f37592da7ddaa692d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54ad98fda4f01b692efd7120bc9acea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab54ad98fda4f01b692efd7120bc9acea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetIsOwnedByRuntime</b> () const </td></tr>
<tr class="separator:ab54ad98fda4f01b692efd7120bc9acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a377facbe8ce1ce7d6e15f4c70aa09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67a377facbe8ce1ce7d6e15f4c70aa09"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>GetFreezeAtTime</b> () const </td></tr>
<tr class="separator:a67a377facbe8ce1ce7d6e15f4c70aa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e08dad8a6bb0e2ed5adb46ed5c84561"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e08dad8a6bb0e2ed5adb46ed5c84561"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFreezeAtTime</b> (float timeInSeconds)</td></tr>
<tr class="separator:a6e08dad8a6bb0e2ed5adb46ed5c84561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c2962578e90d4c83dd0803ac99692b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4c2962578e90d4c83dd0803ac99692b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CalcRelativeTransform</b> (<a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *rootNode, float curTime, float oldTime, Transform *outTransform) const </td></tr>
<tr class="separator:af4c2962578e90d4c83dd0803ac99692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bfb5bbee37d385db77916e710141c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65bfb5bbee37d385db77916e710141c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractMotion</b> (Transform &amp;outTrajectoryDelta)</td></tr>
<tr class="separator:a65bfb5bbee37d385db77916e710141c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453f0c564e46c6c3827faa272638f64d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a453f0c564e46c6c3827faa272638f64d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CalcGlobalTransform</b> (const AZStd::vector&lt; size_t &gt; &amp;hierarchyPath, float timeValue, Transform *outTransform) const </td></tr>
<tr class="separator:a453f0c564e46c6c3827faa272638f64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d35e37c01c364a7826deacbb84e251b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d35e37c01c364a7826deacbb84e251b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetTimes</b> ()</td></tr>
<tr class="separator:a5d35e37c01c364a7826deacbb84e251b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f10235ccb9510c739f7aef13051ac46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f10235ccb9510c739f7aef13051ac46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_DEPRECATED</b> (void CalcNewTimeAfterUpdate(float timePassed, float *outNewTime) const,&quot;MotionInstance::CalcNewTimeAfterUpdate has been deprecated, please use MotionInstance::CalcPlayStateAfterUpdate(timeDelta).m_currentTime instead.&quot;)</td></tr>
<tr class="separator:a5f10235ccb9510c739f7aef13051ac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f01e13399f92d1fb69ac0dd80cf7286"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f01e13399f92d1fb69ac0dd80cf7286"></a>
<a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_out.html">PlayStateOut</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CalcPlayStateAfterUpdate</b> (float timePassed) const </td></tr>
<tr class="separator:a8f01e13399f92d1fb69ac0dd80cf7286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b204affc9347e3422e83aa8090d0d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65b204affc9347e3422e83aa8090d0d2"></a>
<a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_in.html">PlayStateIn</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ConstructInputPlayState</b> () const </td></tr>
<tr class="separator:a65b204affc9347e3422e83aa8090d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684cc249e2d9d408552b97205f2d0ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a684cc249e2d9d408552b97205f2d0ca7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetPlayState</b> (const <a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_in.html">PlayStateIn</a> &amp;inState, const <a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_out.html">PlayStateOut</a> &amp;outState, bool triggerEvents)</td></tr>
<tr class="separator:a684cc249e2d9d408552b97205f2d0ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aba8ec97dbd221f98a9a838d58e66e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5aba8ec97dbd221f98a9a838d58e66e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractMotionEvents</b> (const <a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_in.html">PlayStateIn</a> &amp;inState, <a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_out.html">PlayStateOut</a> &amp;outState, <a class="el" href="class_e_motion_f_x_1_1_anim_graph_event_buffer.html">AnimGraphEventBuffer</a> &amp;eventBuffer) const </td></tr>
<tr class="separator:a5aba8ec97dbd221f98a9a838d58e66e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49053fc0b6d03f3c72ef1865544b8e9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49053fc0b6d03f3c72ef1865544b8e9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessMotionEvents</b> (const <a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_in.html">PlayStateIn</a> &amp;inState, <a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_out.html">PlayStateOut</a> &amp;outState) const </td></tr>
<tr class="separator:a49053fc0b6d03f3c72ef1865544b8e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943d93f2ebb0208be64c3db7bbb4dd37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a943d93f2ebb0208be64c3db7bbb4dd37"></a>
MotionInstancePool::SubPool *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSubPool</b> () const </td></tr>
<tr class="separator:a943d93f2ebb0208be64c3db7bbb4dd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36561fd970df78b009681e7002bcd92e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36561fd970df78b009681e7002bcd92e"></a>
const <a class="el" href="class_e_motion_f_x_1_1_motion_link_data.html">MotionLinkData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>FindMotionLinkData</b> (const <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *actor) const </td></tr>
<tr class="separator:a36561fd970df78b009681e7002bcd92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_e_motion_f_x_1_1_base_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_e_motion_f_x_1_1_base_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a></td></tr>
<tr class="memitem:ab30842776f205a40428bf45079114a6a inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#ab30842776f205a40428bf45079114a6a">BaseObject</a> ()</td></tr>
<tr class="separator:ab30842776f205a40428bf45079114a6a inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3409404f7d117a896a45750468b7b86e inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#a3409404f7d117a896a45750468b7b86e">~BaseObject</a> ()</td></tr>
<tr class="separator:a3409404f7d117a896a45750468b7b86e inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_core_1_1_memory_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_core_1_1_memory_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_core_1_1_memory_object.html">MCore::MemoryObject</a></td></tr>
<tr class="memitem:acbebcaf9fe821daf94eb391978453e86 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#acbebcaf9fe821daf94eb391978453e86">MemoryObject</a> ()</td></tr>
<tr class="separator:acbebcaf9fe821daf94eb391978453e86 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7656e1a1def84ff64945db88ee65c50 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#aa7656e1a1def84ff64945db88ee65c50">~MemoryObject</a> ()</td></tr>
<tr class="separator:aa7656e1a1def84ff64945db88ee65c50 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aca36760b0c56ec18d99f4f53c4335 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a51aca36760b0c56ec18d99f4f53c4335">IncreaseReferenceCount</a> ()</td></tr>
<tr class="separator:a51aca36760b0c56ec18d99f4f53c4335 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b277fe3fc49344884b522cdc7a305b inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a88b277fe3fc49344884b522cdc7a305b">DecreaseReferenceCount</a> ()</td></tr>
<tr class="separator:a88b277fe3fc49344884b522cdc7a305b inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8132c0072fb1b0b9b0e6cbf804af2a6d inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a8132c0072fb1b0b9b0e6cbf804af2a6d">Destroy</a> ()</td></tr>
<tr class="separator:a8132c0072fb1b0b9b0e6cbf804af2a6d inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ee52d71f71814c6114a021e05ef129 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a80ee52d71f71814c6114a021e05ef129">GetReferenceCount</a> () const </td></tr>
<tr class="separator:a80ee52d71f71814c6114a021e05ef129 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af5af848d87fa98a67497963b4b90e4bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5af848d87fa98a67497963b4b90e4bb"></a>
static <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Create</b> (<a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a> *motion, <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *actorInstance)</td></tr>
<tr class="separator:af5af848d87fa98a67497963b4b90e4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2eee94400356fd54444149e30ac4f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b2eee94400356fd54444149e30ac4f1"></a>
static <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Create</b> (void *memLocation, <a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a> *motion, <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *actorInstance)</td></tr>
<tr class="separator:a5b2eee94400356fd54444149e30ac4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3a77f7c049cc59c7dd30edced03c6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f3a77f7c049cc59c7dd30edced03c6a"></a>
static <a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_out.html">PlayStateOut</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CalcPlayState</b> (const <a class="el" href="struct_e_motion_f_x_1_1_motion_instance_1_1_play_state_in.html">PlayStateIn</a> &amp;inState, float timePassed)</td></tr>
<tr class="separator:a0f3a77f7c049cc59c7dd30edced03c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8fa56e0820062c3c0b9931380a175697"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fa56e0820062c3c0b9931380a175697"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RepositioningLayerPass</b></td></tr>
<tr class="separator:a8fa56e0820062c3c0b9931380a175697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d685b9011105d37ce4c64d47055334"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34d685b9011105d37ce4c64d47055334"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AnimGraphMotionNode</b></td></tr>
<tr class="separator:a34d685b9011105d37ce4c64d47055334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253966cc2404c1588d99762ab70b9262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a253966cc2404c1588d99762ab70b9262"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MotionInstancePool</b></td></tr>
<tr class="separator:a253966cc2404c1588d99762ab70b9262"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_e_motion_f_x_1_1_base_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_e_motion_f_x_1_1_base_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a></td></tr>
<tr class="memitem:a021c030d0ce454dfebc6631194c57f0d inherit pro_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#a021c030d0ce454dfebc6631194c57f0d">Delete</a> () override</td></tr>
<tr class="separator:a021c030d0ce454dfebc6631194c57f0d inherit pro_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> class. Since <a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a> objects can be shared between different Actors, there needs to be a mechanism which allows this. By introducing this <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> class, we can create instances from Motions, where the instance also contains playback information. This playback information allows us to play the same animation data at different actors all with unique play positions and speeds, etc. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8a8ba75c652b3840bb68d732fd5427a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::AddEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_motion_instance_event_handler.html">MotionInstanceEventHandler</a> *&#160;</td>
          <td class="paramname"><em>eventHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an event handler to this motion instance. After adding, the event handler will receive events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventHandler</td><td>The new event handler to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2608171aeb5b0306a2c8acc8234322ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EMotionFX::MotionInstance::AZ_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">float GetMaxTime()&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;This method has been deprecated. Please use <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ad3009760a8a34cb5a2669cea20a99d87">MotionInstance::GetDuration</a>() instead.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum time of this motion. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum time of this motion, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a4aac69c504159ff796589d6f0b9d0473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a>* EMotionFX::MotionInstance::GetActorInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actor instance we are playing this motion instance on. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the actor where this motion instance is playing on. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0ea2dc8427dcabaa1082fff7ced67db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetBlendInTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the blend in time. This is the time passed to the SetWeight(...) method where when the target weight is bigger than the current. So only blend ins are counted and not blending out towards for example a weight of 0. When you never call SetWeight(...) yourself, this means that this will contain the value specificied to <a class="el" href="class_e_motion_f_x_1_1_play_back_info.html#af624592b81409230dfc821e7370d727e">PlayBackInfo::m_blendInTime</a> at the time of <a class="el" href="class_e_motion_f_x_1_1_motion_system.html#a01f9aedf6bfdebe4e767164a7125f027">MotionSystem::PlayMotion</a>(...). </p>
<dl class="section return"><dt>Returns</dt><dd>The blend-in time, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a4772806cfb1294ec189c965f9d27587a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EMotionBlendMode EMotionFX::MotionInstance::GetBlendMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the motion blending mode of this motion instance. This describes how the motion gets blend with the other motions being played. For more information about what the blendmodes exactly do, read the documentation of the SetBlendMode method. </p>
<dl class="section return"><dt>Returns</dt><dd>The motion blend mode for this motion instance. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#ab29ba52339653edbb35c25d01ee0817d">SetBlendMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f8cf66e3a2d5946ca6869a67f2eb38c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetBlendOutBeforeEnded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "blend out before end"-option allows you to specify whether a motion should start fading out before the motion has ended (before it reached its maximum number of loops) or if it should fade out after the maximum number of loops have been reached. In the latter case it would mean that the motion will start another loop while it starts fading out. On default this option is enabled, which means the motion will be faded out exactly when it reaches the last frame it should play. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when this option is enabled, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a392b3575445087439c1b1dfc0691f60c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetCanOverwrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this motion instance is allowed to overwrite (and thus delete) other motion instances/layers. This happens in the motion layer system when the weight of this motion instance becomes 1, which means it would completely overwrite other motions because the other motions will not have any influence anymore. On default this value is set to true. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion instance will automatically delete other motion instances when its weight reaches a value of 1. If the motion instance will not delete/overwrite any other motion instances, false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a178b1385015ed542e5a6b27c9248af59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetCurrentTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current time in the playback of the motion. </p>
<dl class="section return"><dt>Returns</dt><dd>The current time, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="aafdb3d6991678a65275033a0a9dceceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetCurrentTimeNormalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current time in the playback of the motion. Normalized in this case means from 0.0 to 1.0. The maximum time of this animation is then 1.0. </p>
<dl class="section return"><dt>Returns</dt><dd>The normalized current time, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="aeead0d06a5c2e9f788441efb1e00b769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* EMotionFX::MotionInstance::GetCustomData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the custom data pointer value. This can be used to link your own custom data to this <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> object. You are responsible later on for deleting any allocated data by this custom data. You can use the MotionEventHandler::OnDeleteMotionInstance() callback to detect when a motion instance is being deleted. On default the custom data value will return nullptr, unless you have used <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a7cc170e601d61aa3ca004b594116ce1a">SetCustomData()</a> to adjust the value. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to your custom data that is linked to this <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac724d18e4a841a339cdc15911c1e7ca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetDeleteOnZeroWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this motion instance can delete itself when its weight equals zero, which means the motion would have no visual influence. On default this value is set to true. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion instance will delete itself when its weight equals a value of zero. Otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3009760a8a34cb5a2669cea20a99d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetDuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the duration of the motion, which is the difference between the clip start and end time. </p>
<dl class="section return"><dt>Returns</dt><dd>The playback duration of this motion instance, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ab952d7bfb32a2e7b04dda9f009a5210b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_motion_instance_event_handler.html">MotionInstanceEventHandler</a>* EMotionFX::MotionInstance::GetEventHandler </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the event handler at the given index. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the event handler at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a52d21c0f8fadba382a55a4b3fa8efeef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetEventWeightThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the motion event weight threshold for this motion instance. The threshold value represents the minimum weight value the motion instance should have in order for it to have its motion events executed. For example if the motion event threshold is set to 0.3, and the motion instance weight value is 0.1, then no motion events will be processed. If however the weight value of the motion instance is above or equal to this 0.3 value then all events will be processed. On default the value is 0.0, which means that all events will be processed. </p>
<dl class="section return"><dt>Returns</dt><dd>The motion event threshold value. </dd></dl>

</div>
</div>
<a class="anchor" id="a576257559e28d262d1afec5b02d308e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetFadeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the time spend to fade out the motion when it is being stopped automatically when the motion has reached its end. This will only happen when the play mode is PLAYMODE_ONCE. </p>
<dl class="section return"><dt>Returns</dt><dd>The fade time, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ab27db13461e4045e20e82dfa7db01cd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetFreezeAtLastFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this motion instance will freeze at its last frame (when not using looping). This only happens when using a maximum play time, or a given number of loops that is not infinite. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion instance will freeze at the last frame. Otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="aaecd79d444ff862f8d775919caf1e709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetHasEnded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this motion instance has ended or not. This will only happen when the play mode is PLAYMODE_ONCE, because a looping motion will of course never end. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion has reached the end of the animation, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a56ee4117196903790be7d310a41fb551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetHasLooped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the motion has looped since the last update. This is the case when the number of loops returned by GetNumCurrentLoops is not equal to the number of loops before the playback mode object has been updated. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion has looped, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a36bdabe874105c76492e88da3e2053cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::u32 EMotionFX::MotionInstance::GetID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the unique identification number for the motion instance. </p>
<dl class="section return"><dt>Returns</dt><dd>The unique identification number. </dd></dl>

</div>
</div>
<a class="anchor" id="adaf4e49da292ef5e6bcd285ac0f89336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetIsActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the motion instance is active or not. On default the motion instance will be active. Inactive motion instances do not get processed at all. They will not update their weight blending or time values. The difference with paused motion instances is that paused instances do process their weight blending, while inactive motion instances do not. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion instance is active, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a29c3eb37bc34d93ac5fe9d560524e29d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetIsBlending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the motion is being blended or not. A blend could be the smooth fade in after starting the motion, or a smooth fade out when stopping the animation. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion is currently in a blend process, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ac624d82a9c1e90c5a9d2b817bbf71b69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetIsFrozen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if we are frozen in the last frame or not. This would only happen when the SetFreezeAtLastFrame(...) was set to true and when the maximum number of loops has been reached. Instead of fading out the motion, it will remain in its last frame. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion is frozen in its last frame. </dd></dl>

</div>
</div>
<a class="anchor" id="a763eeaf24f09d60f87fd76034a220c55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetIsMixing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the motion is in mix mode or not. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion is being mixed, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a67846d572a2e4db48009a23c7c593872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetIsPaused </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the motion currently is paused or not. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion is in pause mode. </dd></dl>

</div>
</div>
<a class="anchor" id="a78c2c2c8a4c663051c61b391b97b5e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetIsPlaying </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the motion is currently playing or not. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion is playing, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c531c75d188a0275df025ad1a5db46e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetIsPlayingForever </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the motion will play forever or not. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion is looping forever, or false when there will be a moment where it will be stopped. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f505cac55d5cf06ffc3982a0aca04ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetIsStopping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the motion is currently stopping or not, so if it is fading out. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the motion is currently stopping, so is fading out. </dd></dl>

</div>
</div>
<a class="anchor" id="a5640413d82f853cf9fd6d28de449a890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetLastCurrentTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current time of the previous update. </p>
<dl class="section return"><dt>Returns</dt><dd>The time value, in seconds, of the current playback time, in the previous update. </dd></dl>

</div>
</div>
<a class="anchor" id="a93d1bc5be6cb50b7c3849a9ea255a772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::u32 EMotionFX::MotionInstance::GetMaxLoops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of loops the motion will play. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of times the motion will be played. This value will be EMFX_LOOPFOREVER (see Actor.h for the define) in case the motion will play forever. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>IsPlayingForever </dd></dl>

</div>
</div>
<a class="anchor" id="a59f70e8e87c30df1fb2e7d4d15ba566c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetMaxPlayTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum play time of this motion instance (well actually of the motion where this is an instance from). So this returns the duration of the motion, in seconds. When this value is zero or a negative value, then the maximum play time option has been disabled for this motion instance. </p>
<dl class="section return"><dt>Returns</dt><dd>The duration of the motion, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fe5c8d9f7b324bffc4f8a272d4395c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetMirrorMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On default motion mirroring is disabled, so set to false. <a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a> mirroring is often very useful in sport games, where you can choose whether your character is left or right-handed. The motion mirroring feature allows you to create just one set of motions, for example right handed. By enabling mirroring of EMotion FX we can turn the right handed motions into left handed motions on the fly, by using the right handed motion source data and modifying it into a left handed motion. This does not really take more memory. Of course there is a little performance impact, but it is definitely worth the memory savings and art time savings. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when motion mirroring is enabled, or false when it is disabled. On default it is disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e8e85fd58c890a90a8d2c97628649ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a>* EMotionFX::MotionInstance::GetMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns motion it is using. </p>
<dl class="section return"><dt>Returns</dt><dd>The original motion it's using. </dd></dl>

</div>
</div>
<a class="anchor" id="aae1e77c1d78dd46900cc9bf2bd298688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetMotionEventsEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if motion event processing is enabled for this motion instance. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when processing of motion events for this motion event is enabled. Otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a2706c6519769d87f64297eb418f6085f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetMotionExtractionEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this motion has motion extraction enabled or not. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if motion extraction is enabled, false if not. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_e_motion_f_x_1_1_actor.html#a1883f2bc2f474c6b9f48a1d093d43dcb">Actor::SetMotionExtractionNode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a41d6a0b66a55c0462f885a525609b74f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::u32 EMotionFX::MotionInstance::GetNumCurrentLoops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of times the motion currently has been played. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of times the motion has been completely played. </dd></dl>

</div>
</div>
<a class="anchor" id="ab50109061187f914518c4f7085cb0660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::MotionInstance::GetNumEventHandlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of event handlers. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of event handlers assigned to the motion instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f457a117c76deee7f14151a2793612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPlayMode EMotionFX::MotionInstance::GetPlayMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the play mode, which defines the deireciton the motion is playing (foward or backward). </p>
<dl class="section return"><dt>Returns</dt><dd>The playback mode. </dd></dl>

</div>
</div>
<a class="anchor" id="a32a609e8bbe745ca795c161e78af9a89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetPlaySpeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the play speed factor (1.0 is normal, 0.5 is half speed, etc.). </p>
<dl class="section return"><dt>Returns</dt><dd>The play speed factor. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3fbc46da16a24fdf93eee5c5e38c44f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::u32 EMotionFX::MotionInstance::GetPriorityLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the priority level of the motion instance. Higher values mean less change on getting overwritten by another motion. A good example are facial motions being played on a walking character. You would first play the walk motion, with priority of say 0. After that you will play a facial motion, with mix mode, and priority level 5 for example. Now you want to change the walk motion into a run motion. If we did not set the priority level for the facial motion above 0, the run motion would overwrite the facial motion. But since the facial motion has got a higher priority, it will not be overwritten by the run motion. If we now want to change the facial motion with another one, we simply play the facial motion with the same or a higher priority level as the previous facial motion. So a priority level of 5 or higher would work in the example case. </p>
<dl class="section return"><dt>Returns</dt><dd>The priority level of the motion instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1f27fea4b43ec54966bef3f40e8c2d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::MotionInstance::GetRetargetingEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if motion retargeting on this motion instance is enabled or not. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when motion retargeting is enabled on this motion instance. Otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a2783aec1177375986d6c7d6214742541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetTargetWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the target weight. This is the weight we are blending towards. If you specified a blendTimeInSeconds of zero in the SetWeight method, the target weight will return the same as the value returned by <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a8d373063ab5f61c1dd1fc67c6982206c">GetWeight()</a>. The value returned is in range of [0..1]. </p>
<dl class="section return"><dt>Returns</dt><dd>The target weight value, where we are blending towards. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2f70e87dcbaca66493a2d755258b66d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetTimeDifToLoopPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the time difference between the current play time and the end of the motion. With end of motion we mean the point where there is no more motion data, so where it would need to loop to continue to play. </p>
<dl class="section return"><dt>Returns</dt><dd>The time remaining until the loop point of the motion would be reached. </dd></dl>

</div>
</div>
<a class="anchor" id="af1d664f02c7d6b177275a980dd4060e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetTotalPlayTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total time this motion has been playing already. </p>
<dl class="section return"><dt>Returns</dt><dd>The total time, in seconds, that this motion is already playing. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d373063ab5f61c1dd1fc67c6982206c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::MotionInstance::GetWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current weight of the layer. This weight is in range of [0..1], where 0 means no influence and 1 means full influence. </p>
<dl class="section return"><dt>Returns</dt><dd>The current weight value. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c1e85e2a4618327c53071dc1366cabd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::InitFromPlayBackInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_e_motion_f_x_1_1_play_back_info.html">PlayBackInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetCurrentPlaytime</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the motion instance from <a class="el" href="class_e_motion_f_x_1_1_play_back_info.html">PlayBackInfo</a> settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The playback info settings to initialize from. </td></tr>
    <tr><td class="paramname">resetCurrentPlaytime</td><td>Set back the current playtime, even though this is not an attribute of the playback info in case of true. In case of false the current time won't be modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63c6b19b484f6536565620e24f1fd5ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnChangedActiveState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once the motion active state changes. For example when the motion is active but gets set to inactive using the MotionInstance::SetActive(...) method, then this even twill be triggered. Inactive motions don't get processed at all. They will not update their playback times, blending, nor will they take part in any blending calculations of the final node transforms. In other words, it will just be like the motion instance does not exist at all. </p>

</div>
</div>
<a class="anchor" id="a8c2239726eaf58ecae82eef928b290d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnChangedPauseState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once the motion pause state changes. For example when the motion is unpaused but gets paused, then this even twill be triggered. Paused motions don't get their playback times updated. They do however still perform blending, so it is still possible to fade them in or out. </p>

</div>
</div>
<a class="anchor" id="af85628c689a3a724f1d208bb0ee09f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnDeleteMotionInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event that gets triggered once a <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> object is being deleted. This can happen when calling the <a class="el" href="class_e_motion_f_x_1_1_motion_system.html#af9ca21416882fda227c266b844a7003e">MotionSystem::RemoveMotionInstance()</a> method manually, or when EMotion FX internally removes the motion instance because it has no visual influence anymore. The destructor of the <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> class automatically triggers this event. </p>

</div>
</div>
<a class="anchor" id="aaff5737cd0489e3f3037df4f5cde9820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_e_motion_f_x_1_1_event_info.html">EventInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>eventInfo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method that processes an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventInfo</td><td>The struct holding the information about the triggered event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac71e667190238e5ecc9b81cdf1d6707e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnHasLooped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once a given motion instance has looped. </p>

</div>
</div>
<a class="anchor" id="a2906bbf0a01dc66edf00729660d0b128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnHasReachedMaxNumLoops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once a given motion instance has reached its maximum number of allowed loops. In this case the motion instance will also be stopped automatically afterwards. </p>

</div>
</div>
<a class="anchor" id="ac9d4e3e1a8272570783814a3d4d0ce09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnHasReachedMaxPlayTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once a given motion instance has reached its maximum playback time. For example if this motion instance is only allowed to play for 2 seconds, and the total playback time reaches two seconds, then this event will be triggered. </p>

</div>
</div>
<a class="anchor" id="a864bd96207f3262db77969f350dcf3eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnIsFrozenAtLastFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once the motion instance is set to freeze at the last frame once the motion reached its end (when it reached its maximum number of loops or playtime). In this case this event will be triggered once. </p>

</div>
</div>
<a class="anchor" id="a4d09814bf2a6d34cf1c3c94c9991857c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnQueueMotionInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_play_back_info.html">PlayBackInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once the given motion instance gets added to the motion queue. This happens when you set the <a class="el" href="class_e_motion_f_x_1_1_play_back_info.html#a160a4cb16c2d12b27fb9c7c6f765b953">PlayBackInfo::m_playNow</a> member to false. In that case the <a class="el" href="class_e_motion_f_x_1_1_motion_system.html#a01f9aedf6bfdebe4e767164a7125f027">MotionSystem::PlayMotion()</a> method (OnPlayMotion) will not directly start playing the motion (OnStartMotionInstance), but will add it to the motion queue instead. The motion queue will then start playing the motion instance once it should. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The playback information used to play this motion instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0ee6e665b3097a9112219a9b5033152"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnStartBlending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once a motion instance is automatically changing its weight value over time. For example when a motion is automatically being faded in from weight 0 to a given target weight in half a second, then once this blending starts, this event is being triggered. Once the the <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a0ae04e6f3220148fe988e767faefeaff">MotionInstance::SetWeight</a>(...) method is being called with a blend time bigger than zero, and if the motion instance isn't currently already blending, then this event will be triggered. This event most likely will get triggered when using the <a class="el" href="class_e_motion_f_x_1_1_motion_system.html#a01f9aedf6bfdebe4e767164a7125f027">MotionSystem::PlayMotion()</a> and <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a823cf8dc1886a48dd632a12ecec75b4f">MotionInstance::Stop()</a> methods. </p>

</div>
</div>
<a class="anchor" id="a3187e560afea79450e127e1035ee7cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnStartMotionInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_play_back_info.html">PlayBackInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event that gets triggered when a motion instance is really being played. This can be a manual call through MotionInstance::PlayMotion or when the <a class="el" href="class_e_motion_f_x_1_1_motion_queue.html">MotionQueue</a> class will start playing a motion that was on the queue. The difference between <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a3187e560afea79450e127e1035ee7cf2">OnStartMotionInstance()</a> and this OnPlayMotion() is that the OnPlayMotion doesn't guarantee that the motion is being played yet, as it can also be added to the motion queue. The <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a3187e560afea79450e127e1035ee7cf2">OnStartMotionInstance()</a> method will be called once the motion is really being played. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The playback info used to play the motion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff952b874de6f75b9e171d96755a269f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event that gets triggered when a motion instance is being stopped using one of the <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a823cf8dc1886a48dd632a12ecec75b4f">MotionInstance::Stop()</a> methods. EMotion FX will internally stop the motion automatically when the motion instance reached its maximum playback time or its maximum number of loops. </p>

</div>
</div>
<a class="anchor" id="a7fc105d2b0695ac637e60ffe1058eb4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::OnStopBlending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event gets triggered once a motion instance stops it automatic changing of its weight value over time. For example when a motion is automatically being faded in from weight 0 to a given target weight in half a second, and once the target weight is reached after half a second, will cause this event to be triggered. Once the the <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a0ae04e6f3220148fe988e767faefeaff">MotionInstance::SetWeight</a>(...) method is being called with a blend time equal to zero and the motion instance is currently blending its weight value, then this event will be triggered. This event most likely will get triggered when using the <a class="el" href="class_e_motion_f_x_1_1_motion_system.html#a01f9aedf6bfdebe4e767164a7125f027">MotionSystem::PlayMotion()</a> and <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a823cf8dc1886a48dd632a12ecec75b4f">MotionInstance::Stop()</a> methods. </p>

</div>
</div>
<a class="anchor" id="a71cc308a33762dfe5965e55fd96590d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::Pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pause the motion instance. </p>

</div>
</div>
<a class="anchor" id="a7dfe07237c15b3bfc17e192a8927a09a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::RemoveAllEventHandlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all motion event handlers from this motion instance. </p>

</div>
</div>
<a class="anchor" id="a39be6c02e49c6d411958bc9b1bb02e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::RemoveEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_motion_instance_event_handler.html">MotionInstanceEventHandler</a> *&#160;</td>
          <td class="paramname"><em>eventHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the given event handler. Even if the function returns false, if delFromMem is set to true it will delete the handler from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventHandler</td><td>A pointer to the event handler to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6205142f84b2e94a98a76fb658921f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::Rewind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rewinds the motion instance. It sets the current time to 0 seconds. </p>

</div>
</div>
<a class="anchor" id="ab29ba52339653edbb35c25d01ee0817d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetBlendMode </td>
          <td>(</td>
          <td class="paramtype">EMotionBlendMode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the motion blend mode of this motion instance. If you want to switch between two different motions, for example going from walk into run, you most likely want to use the BLENDMODE_OVERWRITE mode. However, there are some cases where overwriting doesn't work well. Think of a skateboard game, where you play a looping base animation, which is played while moving forwards. Now on top of this you want to bend the character's upper body to the right. So you play a mixing motion of the upper body. You now have a character, which is skate boarding, while bending his upper body to the right. Now imagine you want to have some motion which shoots. You want the character to shoot, while it is skating and while it is has bend his upper body to the right. If you would use overwrite mode, and the shoot animation adjusts the bones in the upper body, the motion of the bend will be overwritten. This means you will only see a shoot animation while skating, and not the desired, shoot, while bending right, while skating. In order to solve this, you can play the shoot motion additive, on top of the bend and skate motions. EMotion FX will then add all relative changes (compared to the original pose of the actor) to the current result, which in our case is the skating, while bending right. Playing an additive motion in mix-mode, will act the same as playing one in non-mixing mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The blendmode to use. The default blendmode of motion instances are set to BLEND_OVERWRITE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>EMotionBlendMode </dd></dl>

</div>
</div>
<a class="anchor" id="a99dd3c24184e5c3878d31dd4ac494fc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetBlendOutBeforeEnded </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This option allows you to specify whether a motion should start fading out before the motion has ended (before it reached its maximum number of loops) or if it should fade out after the maximum number of loops have been reached. In the latter case it would mean that the motion will start another loop while it starts fading out. On default this option is enabled, which means the motion will be faded out exactly when it reaches the last frame it should play. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true to to enable this option, or false to disable it. On default it is set to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a443a1e1fff7b001bd506d8908a28fe2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetCanOverwrite </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canOverwrite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable this motion instance to overwrite and so delete other motion instances. This happens in the motion layer system when the weight of this motion instance becomes 1, which means it would completely overwrite other motions because the other motions will not have any influence anymore. On default overwriting is enabled, so the value would be true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canOverwrite</td><td>Set to true to allow this motion instance to overwrite/delete other motion instances/layers. Otherwise set to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcec4e73fc1a585a4b144a27aa3fbda1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetCurrentTime </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetLastTime</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current time in the animation (automatic wrapping/looping performed when out of range). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The current time in the animation, in seconds. </td></tr>
    <tr><td class="paramname">resetLastTime</td><td>When set to true, the last frame time will be set equal to the new current time as well. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7be29267ff31bb9a0b41875203a27d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetCurrentTimeNormalized </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>normalizedTimeValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current time in the animation (automatic wrapping/looping performed when out of range). Normalized in this case means from 0.0 to 1.0. The maximum time of this animation is then 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalizedTimeValue</td><td>The new normalized time value, in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cc170e601d61aa3ca004b594116ce1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetCustomData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>customDataPointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the custom data pointer. This can be used to link your own custom data to this <a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a> object. You are responsible later on for deleting any allocated data by this custom data. You can use the MotionEventHandler::OnDeleteMotionInstance() callback to detect when a motion instance is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customDataPointer</td><td>The pointer to your custom data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9262ba4899933f4a1e3c0113cf9c75aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetDeleteOnZeroWeight </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteOnZeroWeight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow or disallow the motion instance to delete itself when its weight equals zero. When a motion instance has a weight of zero it means it would have no visual influence in the final result. On default deletion on zero weights is enabled, so the value would be true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteOnZeroWeight</td><td>Set to true when you wish to allow the motion instance to delete itself when it has a weight of zero. Otherwise set it to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76d50e5ec4bddb8cf2666d33d9ba26f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetEventWeightThreshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weightThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the motion event weight threshold for this motion instance. The threshold value represents the minimum weight value the motion instance should have in order for it to have its motion events executed. For example if the motion event threshold is set to 0.3, and the motion instance weight value is 0.1, then no motion events will be processed. If however the weight value of the motion instance is above or equal to this 0.3 value then all events will be processed. On default the value is 0.0, which means that all events will be processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weightThreshold</td><td>The motion event weight threshold. If the motion instance weight is below this value, no motion events will be processed for this motion instance. Basically this value should be in range of [0..1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a143b67af5b1dbe415f9f2a336043cebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetFadeTime </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fadeTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the fade-out time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fadeTime</td><td>The fade time, in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af833779dd0822e6d9b003dfe216e8e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetFreezeAtLastFrame </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable freezing at the last frame. This only happens when using a maximum play time, or a given number of loops that is not infinite. When you play a full body death motion, you probably want to enable this. If in that case this option would be disabled (default) it will blend back into its base/bind pose instead of freezing at the last frame, keeping the character dead on the ground. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true when you want to enable the freeze at last frame option, otherwise set to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3671ddfb5c75bbc4a07b5297a0b146b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetIsActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activate or deactivate this motion instance. On default the motion instance will be active. Inactive motion instances do not get processed at all. They will not update their weight blending or time values. The difference with paused motion instances is that paused instances do process their weight blending, while inactive motion instances do not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true when you want to activate the motion instance, or false when you wish to deactivate it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a909d514e8d68493c2994a01eaeb02eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetIsFrozen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFrozen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set if we are frozen in the last frame or not. Instead of fading out the motion, it will remain in its last frame. </p>

</div>
</div>
<a class="anchor" id="a5974b537d1b110f37592da7ddaa692d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetIsOwnedByRuntime </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOwnedByRuntime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the object as used by the engine runtime, as opposed to the tool suite. </p>

</div>
</div>
<a class="anchor" id="a0f7ee6e0f0b70fba30b0faad1c73901c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetMaxLoops </td>
          <td>(</td>
          <td class="paramtype">AZ::u32&#160;</td>
          <td class="paramname"><em>numLoops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of loops the motion should play. If you want to loop it forever, set the value to EMFX_LOOPFOREVER (which is defined in Actor.h). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numLoops</td><td>The number of loops the motion should play, or EMFX_LOOPFOREVER in case it should play forever. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ffe578cc47781ef49273ec65a939525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetMaxPlayTime </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>playTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum play time, in seconds, that this motion instance is allowed to play. When you set this to zero (default), or a negative value, then this option is disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playTime</td><td>The maximum play time, in seconds, or zero or a negative value to disable the maximum play time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13b8c96637cbf0bb8b2f40fcac7ff72c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetMirrorMotion </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable motion mirroring. On default motion mirroring is disabled. <a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a> mirroring is often very useful in sport games, where you can choose whether your character is left or right-handed. The motion mirroring feature allows you to create just one set of motions, for example right handed. By enabling mirroring of EMotion FX we can turn the right handed motions into left handed motions on the fly, by using the right handed motion source data and modifying it into a left handed motion. This does not really take more memory. Of course there is a little performance impact, but it is definitely worth the memory savings and art time savings. When mirroring is enabled the motion mirror plane normal is used to determine how to mirror the motion. This can be set with SetMirrorPlaneNormal(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true if you want to enable motion mirroring, or false when you want to disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60bac1d319c7d7e0aa8dea603729906e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetMixMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mixModeEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the motion to mix mode or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mixModeEnabled</td><td>Set to true when the motion has to mix, otherwise set to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ee8729d3f526ac8aa26ccbff7b42118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetMotionEventsEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable processing of motion events for this motion instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true when you wish to enable processing of motion events. Otherwise set it to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21ad739c8ec99cd87d0ae837fa3b2e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetMotionExtractionEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable motion extraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Set to true when you want to enable motion extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html#a2706c6519769d87f64297eb418f6085f">GetMotionExtractionEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa36beef8b599b6aba51b6090f61758a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetNumCurrentLoops </td>
          <td>(</td>
          <td class="paramtype">AZ::u32&#160;</td>
          <td class="paramname"><em>numCurrentLoops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the new number of times the motion has been played. Changing this value will misrepresent the exact number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCurrentLoops</td><td>The number of times the motion has been played. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13149e20f70d9a51caf195e7067e8a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetPause </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pauseEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the pause mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pauseEnabled</td><td>When true, the motion will be set to pause, else it will be unpaused. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f610dd3584ea31d720e680dcbccf3ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetPlayMode </td>
          <td>(</td>
          <td class="paramtype">EPlayMode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the play mode, which defines the direction the motion is playing (forward or backward). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The playback mode to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad38157c04abe640a217b0bb1d65af3fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetPlaySpeed </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current play speed (1.0 is normal, 0.5 is half speed, etc.). The speed has to be bigger or equal to 0. You should not use negative playback speeds. If you want to play backward, use the SetPlayMode( PLAYMODE_BACKWARD ), or use the <a class="el" href="class_e_motion_f_x_1_1_play_back_info.html#a320ff7f793e8796d1817f340d9824a0a">PlayBackInfo::m_playMode</a> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>The current play speed (1.0 is normal, 0.5 is half speed, etc.). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a906edeb5ba568d9f81707733fe7b3506"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetPriorityLevel </td>
          <td>(</td>
          <td class="paramtype">AZ::u32&#160;</td>
          <td class="paramname"><em>priorityLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the priority level of the motion instance. Higher values mean less change on getting overwritten by another motion. A good example are facial motions being played on a walking character. You would first play the walk motion, with priority of say 0. After that you will play a facial motion, with mix mode, and priority level 5 for example. Now you want to change the walk motion into a run motion. If we did not set the priority level for the facial motion above 0, the run motion would overwrite the facial motion. But since the facial motion has got a higher priority, it will not be overwritten by the run motion. If we now want to change the facial motion with another one, we simply play the facial motion with the same or a higher priority level as the previous facial motion. So a priority level of 5 or higher would work in the example case. </p>
<dl class="section return"><dt>Returns</dt><dd>The priority level of the motion instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a12e969aae8abc5d6f8826a4bfa40f550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetRetargetingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable motion retargeting on this motion instance. Retargeting takes a bit more speed, but it is a very small performance difference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true when you wish to enable motion retargeting, otherwise set to false (false is the default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab08d833cb446117d50042447cbfe6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetTotalPlayTime </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>playTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjust the total play time that this motion is already playing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playTime</td><td>The total play time, in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ae04e6f3220148fe988e767faefeaff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::SetWeight </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>targetWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blendTimeInSeconds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the target weight value. This can be used to smoothly blend towards another weight value. You specify the new (target) weight value, and the time in seconds in which we should blend into that weight. A weight value of 0 means no influence, and a weight value of 1 means full influence. Please keep in mind that motion layers inside the motion layer system will automatically be removed when we are in overwrite motion blend mode and this motion reaches full influence. In order to prevent this from happening, you can blend towards a weight of for example 0.999. This will not have any visual difference compared to a weight of 1, but will prevent motion instances and layers from being removed. The same goes for motion weights of 0. Instead of motion weights of 0, you can use values like 0.001 in these cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetWeight</td><td>The weight value we want to blend towards. </td></tr>
    <tr><td class="paramname">blendTimeInSeconds</td><td>The time, in seconds, in which we should blend from the current weight value into the specified target weight value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d396aa48c62b941f1d99786ceb837d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::Stop </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fadeOutTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop the motion, using a given fade-out time. This will first modify the fade-out time and then fade to a zero weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fadeOutTime</td><td>The time it takes, in seconds, to fade out the motion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a823cf8dc1886a48dd632a12ecec75b4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::Stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop the motion, using the currently set fade-out time. This will blend the weight into zero. </p>

</div>
</div>
<a class="anchor" id="adbc529d810b67ff33ee2b084ae1b9fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::UnPause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpause the motion instance. </p>

</div>
</div>
<a class="anchor" id="a68c2849ea9f7e77faefa19693b6fed92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::Update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timePassed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the motion info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timePassed</td><td>The time passed, in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a987b09a2ecd9d87fe0682ff967fc700e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::UpdateByTimeValues </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>oldTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_anim_graph_event_buffer.html">AnimGraphEventBuffer</a> *&#160;</td>
          <td class="paramname"><em>outEventBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update based on an old and new time value. This will update the motion instance internally as it was previously at oldTime and now has progressed towards newTime. This does not simply change the current time value, but really detects loops, increasing loop counts, triggering events, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldTime</td><td>The previous time value of the current motion time. </td></tr>
    <tr><td class="paramname">newTime</td><td>The new current motion time. </td></tr>
    <tr><td class="paramname">outEventBuffer</td><td>The output event buffer. This can be nullptr if you want to skip triggering events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a546d17fcb5fce4546e49db64d827cba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::MotionInstance::UpdateTime </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timePassed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the current play time value. This is automatically called. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/EMotionFX/Code/EMotionFX/Source/MotionInstance.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>EMotionFX</b></li><li class="navelem"><a class="el" href="class_e_motion_f_x_1_1_motion_instance.html">MotionInstance</a></li>
    <li class="footer">Generated on Thu Apr 20 2023 21:34:13 for Open 3D Engine EMotionFX Gem API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
