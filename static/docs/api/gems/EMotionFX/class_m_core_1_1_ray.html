<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine EMotionFX Gem API Reference: MCore::Ray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">23.05.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_core_1_1_ray.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_core_1_1_ray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MCore::Ray Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Ray.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcd4394e8c0ba8894fc9e91388660dee"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#adcd4394e8c0ba8894fc9e91388660dee">Ray</a> ()</td></tr>
<tr class="separator:adcd4394e8c0ba8894fc9e91388660dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc7dc9c25e598ce33324fbf7cd9aff6"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a7fc7dc9c25e598ce33324fbf7cd9aff6">Ray</a> (const AZ::Vector3 &amp;org, const AZ::Vector3 &amp;endPoint)</td></tr>
<tr class="separator:a7fc7dc9c25e598ce33324fbf7cd9aff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af706389a3f544c3f5d1c2a19f2e1f2b0"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#af706389a3f544c3f5d1c2a19f2e1f2b0">Ray</a> (const AZ::Vector3 &amp;org, const AZ::Vector3 &amp;endPoint, const AZ::Vector3 &amp;dir)</td></tr>
<tr class="separator:af706389a3f544c3f5d1c2a19f2e1f2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646922f5f60455dceb5ac33c0c74d561"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a646922f5f60455dceb5ac33c0c74d561">Set</a> (const AZ::Vector3 &amp;org, const AZ::Vector3 &amp;endPoint)</td></tr>
<tr class="separator:a646922f5f60455dceb5ac33c0c74d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62073c805b1eeb7720f0fc76c2dc256"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#aa62073c805b1eeb7720f0fc76c2dc256">SetOrigin</a> (const AZ::Vector3 &amp;org)</td></tr>
<tr class="separator:aa62073c805b1eeb7720f0fc76c2dc256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c33c1a3f82d3c8b23e7fcbcef3d412"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a96c33c1a3f82d3c8b23e7fcbcef3d412">SetDest</a> (const AZ::Vector3 &amp;dest)</td></tr>
<tr class="separator:a96c33c1a3f82d3c8b23e7fcbcef3d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf51b9d131ceb0e8acd26e6ca7ba7a09"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const AZ::Vector3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#acf51b9d131ceb0e8acd26e6ca7ba7a09">GetOrigin</a> () const </td></tr>
<tr class="separator:acf51b9d131ceb0e8acd26e6ca7ba7a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a89d3d4437cb134a7be8d41e5a580a"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const AZ::Vector3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a03a89d3d4437cb134a7be8d41e5a580a">GetDest</a> () const </td></tr>
<tr class="separator:a03a89d3d4437cb134a7be8d41e5a580a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c714ff652262ab015404f80923bc8cd"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const AZ::Vector3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a9c714ff652262ab015404f80923bc8cd">GetDirection</a> () const </td></tr>
<tr class="separator:a9c714ff652262ab015404f80923bc8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002535e0937f6d0f2ba488f45be37351"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a002535e0937f6d0f2ba488f45be37351">Intersects</a> (const <a class="el" href="class_m_core_1_1_bounding_sphere.html">BoundingSphere</a> &amp;s, AZ::Vector3 *intersectA=nullptr, AZ::Vector3 *intersectB=nullptr) const </td></tr>
<tr class="separator:a002535e0937f6d0f2ba488f45be37351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d2d3e2642d24d663cbd99b5ef5ae17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a02d2d3e2642d24d663cbd99b5ef5ae17">Intersects</a> (const <a class="el" href="class_m_core_1_1_plane_eq.html">PlaneEq</a> &amp;p, AZ::Vector3 *intersect=nullptr) const </td></tr>
<tr class="separator:a02d2d3e2642d24d663cbd99b5ef5ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cbde3f3de45ac059b304bbcb53a679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#ab8cbde3f3de45ac059b304bbcb53a679">Intersects</a> (const AZ::Vector3 &amp;p1, const AZ::Vector3 &amp;p2, const AZ::Vector3 &amp;p3, AZ::Vector3 *intersect=nullptr, float *baryU=nullptr, float *baryV=nullptr) const </td></tr>
<tr class="separator:ab8cbde3f3de45ac059b304bbcb53a679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813e7752e5eda272631b3d9a07772164"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a813e7752e5eda272631b3d9a07772164">Intersects</a> (const <a class="el" href="class_m_core_1_1_a_a_b_b.html">AABB</a> &amp;b, AZ::Vector3 *intersectA=nullptr, AZ::Vector3 *intersectB=nullptr) const </td></tr>
<tr class="separator:a813e7752e5eda272631b3d9a07772164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f97e86cb5a5f2a58f0287f54df46430"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ray.html#a4f97e86cb5a5f2a58f0287f54df46430">Length</a> () const </td></tr>
<tr class="separator:a4f97e86cb5a5f2a58f0287f54df46430"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_m_core_1_1_ray.html">Ray</a> template/class. A ray is normally an infinite line, starting at a given point (the origin) and heading into a given direction. However, this template does not represent an infinite line, but a finite line, since that will be a lot more useful. This means we have an origin, which is the starting point and a destination, which is the end point. This automatically gives us a direction vector too. So basically we now have a finite ray, which is just a 3D line. We can use rays mainly to perform intersection tests. This class provides you with methods to calculate interection information between the ray and bounding spheres, axis aligned bounding boxes, triangles and planes. More intersection tests might be added in a later stage. Or they have already been added, but this documentation should be updated :) Example fields where rays are (often) used are: collision and hit detection, raytracing images, global illumination, lightmap generation, pathtracing, real-time volumetric effects, lensflares, etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adcd4394e8c0ba8894fc9e91388660dee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::Ray::Ray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Does NOT initialize any members. So this would not be a valid ray. </p>

</div>
</div>
<a class="anchor" id="a7fc7dc9c25e598ce33324fbf7cd9aff6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::Ray::Ray </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>endPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor which sets the start and end point of the ray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">org</td><td>The origin of the ray. </td></tr>
    <tr><td class="paramname">endPoint</td><td>The end (destination) point of the ray. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af706389a3f544c3f5d1c2a19f2e1f2b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::Ray::Ray </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>endPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor which sets the origin, destination point and direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">org</td><td>The origin of the ray, so where it starts. </td></tr>
    <tr><td class="paramname">endPoint</td><td>The destination point of the ray, so where it should end. </td></tr>
    <tr><td class="paramname">dir</td><td>The normalized direction vector of the ray, which should be (endPoint - startPoint).Normalize() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a03a89d3d4437cb134a7be8d41e5a580a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const AZ::Vector3&amp; MCore::Ray::GetDest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the destination of the ray. </p>
<dl class="section return"><dt>Returns</dt><dd>The destination point of the ray, so where it ends. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c714ff652262ab015404f80923bc8cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const AZ::Vector3&amp; MCore::Ray::GetDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the direction of the ray. </p>
<dl class="section return"><dt>Returns</dt><dd>The normalized direction vector of the ray, so the direction its heading to. </dd></dl>

</div>
</div>
<a class="anchor" id="acf51b9d131ceb0e8acd26e6ca7ba7a09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const AZ::Vector3&amp; MCore::Ray::GetOrigin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the origin of the ray. </p>
<dl class="section return"><dt>Returns</dt><dd>The origin of the ray, so where it starts. </dd></dl>

</div>
</div>
<a class="anchor" id="a002535e0937f6d0f2ba488f45be37351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MCore::Ray::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_bounding_sphere.html">BoundingSphere</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>intersectA</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>intersectB</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a ray/sphere intersection test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The bounding sphere to test with. </td></tr>
    <tr><td class="paramname">intersectA</td><td>If not nullptr, the closest intersection point will be stored in this vector, in case of an intersection. </td></tr>
    <tr><td class="paramname">intersectB</td><td>If not nullptr, the farthest intersection point will be stored in this vector, in case of an intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when an intersection occured, otherwise false. If there is no intersection, 'intersectA' and 'intersectB' won't be changed. </dd></dl>

</div>
</div>
<a class="anchor" id="a02d2d3e2642d24d663cbd99b5ef5ae17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MCore::Ray::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_plane_eq.html">PlaneEq</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>intersect</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a ray/plane intersection test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The plane to test with. </td></tr>
    <tr><td class="paramname">intersect</td><td>If not nullptr, the intersection point will be stored in this vector, in case of an intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when an intersection occured, otherwise false. If there is no intersection, 'intersect' will not be changed. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8cbde3f3de45ac059b304bbcb53a679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MCore::Ray::Intersects </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>intersect</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>baryU</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>baryV</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a ray/triangle intersection test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first point of the triangle. </td></tr>
    <tr><td class="paramname">p2</td><td>The second point of the triangle. </td></tr>
    <tr><td class="paramname">p3</td><td>The third point of the triangle. </td></tr>
    <tr><td class="paramname">intersect</td><td>If not nullptr, the intersection point will be stored in here, in case of an intersection. </td></tr>
    <tr><td class="paramname">baryU</td><td>If not nullptr, the 'u' barycentric coordinate will be stored in here. </td></tr>
    <tr><td class="paramname">baryV</td><td>If not nullptr, the 'v' barycentric coordinate will be stored in here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true in case of an intersection, otherwise false. If there is no intersection, 'intersect', 'baryU' and 'baryV' will not be modified. You can calculate the uv or normal or whatsoever at the intersection point by using the baryU and baryV values.</dd></dl>
<p>The calculation goes like:</p>
<p>valueAtIntersectionPoint = (1-u-v)*A + u*B + v*C;</p>
<p>Where u and v are the values written in baryU and baryV and A, B and C are the three 'attributes' on the 3 points of the triangle. For example the three vertex normals or uv coordinates or colors. Where A is the attribute linked with 'p1', B the attribute linked with 'p2' and C the attribute linked with 'p3'.</p>
<p>To make it easy for you, we created a function caled BarycentricInterpolate() which takes the required parameters and returns the attribute value at the given barycentric coordinates for you. The usage would now be:</p>
<p>valueAtIntersectionPoint = BarycentricInterpolate&lt;Vector3&gt;(u, v, A, B, C);</p>
<p>Where A, B and C could be the vertex normals of the triangle for example. You can easily also calculate the intersection point yourself by using the u and v, by doing this:</p>
<p>intersectionPoint = BarycentricInterpolate&lt;Vector3&gt;(u, v, p1, p2, p3);</p>
<dl class="section see"><dt>See Also</dt><dd>BarycentricInterpolate </dd></dl>

</div>
</div>
<a class="anchor" id="a813e7752e5eda272631b3d9a07772164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MCore::Ray::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_a_a_b_b.html">AABB</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>intersectA</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>intersectB</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a ray/AABB (Axis Aligned Bounding Box) intersection test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The box to test with. </td></tr>
    <tr><td class="paramname">intersectA</td><td>If not nullptr, the closest intersection point will be stored in this vector, in case of an intersection. </td></tr>
    <tr><td class="paramname">intersectB</td><td>If not nullptr, the farthest intersection point will be stored in this vector, in case of an intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when an intersection occured, otherwise false. If there is no intersection, 'intersectA' and 'intersectB' won't be modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f97e86cb5a5f2a58f0287f54df46430"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE float MCore::Ray::Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the length of the ray. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of the ray. </dd></dl>

</div>
</div>
<a class="anchor" id="a646922f5f60455dceb5ac33c0c74d561"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::Ray::Set </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>endPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the origin and destination point (end point) of the ray. The direction vector will be calculated automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">org</td><td>The origin of the ray, so the start point. </td></tr>
    <tr><td class="paramname">endPoint</td><td>The destination of the ray, so the end point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96c33c1a3f82d3c8b23e7fcbcef3d412"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::Ray::SetDest </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the destination point of the ray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination of the ray. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa62073c805b1eeb7720f0fc76c2dc256"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::Ray::SetOrigin </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>org</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the origin of the ray, so the start point. The direction will automatically be updated as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">org</td><td>The origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/EMotionFX/Code/MCore/Source/Ray.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>MCore</b></li><li class="navelem"><a class="el" href="class_m_core_1_1_ray.html">Ray</a></li>
    <li class="footer">Generated on Thu Apr 20 2023 21:15:46 for Open 3D Engine EMotionFX Gem API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
