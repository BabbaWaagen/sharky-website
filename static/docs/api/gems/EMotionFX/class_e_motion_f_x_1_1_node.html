<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine EMotionFX Gem API Reference: EMotionFX::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">23.05.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_e_motion_f_x_1_1_node.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_e_motion_f_x_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EMotionFX::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Node.h&gt;</code></p>

<p>Inherits <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abe1dd117c069df29eb68c4249631a2ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>TYPE_ID</b> = 0x00000001
 }</td></tr>
<tr class="separator:abe1dd117c069df29eb68c4249631a2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4cb7ec2cc3b49d48c7cab13c2b5fb5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a2a4cb7ec2cc3b49d48c7cab13c2b5fb5">ENodeFlags</a> : AZ::u8 { <a class="el" href="class_e_motion_f_x_1_1_node.html#a2a4cb7ec2cc3b49d48c7cab13c2b5fb5a775ba1646de81c5cf4278538df79cd0d">FLAG_INCLUDEINBOUNDSCALC</a> = 1 &lt;&lt; 0, 
<a class="el" href="class_e_motion_f_x_1_1_node.html#a2a4cb7ec2cc3b49d48c7cab13c2b5fb5aa1438431a18f7ed4723349cd1c9c0786">FLAG_ATTACHMENT</a> = 1 &lt;&lt; 1, 
<a class="el" href="class_e_motion_f_x_1_1_node.html#a2a4cb7ec2cc3b49d48c7cab13c2b5fb5af41d36b58935aa539698c047bdd21fdd">FLAG_CRITICAL</a> = 1 &lt;&lt; 2
 }</td></tr>
<tr class="separator:a2a4cb7ec2cc3b49d48c7cab13c2b5fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7888fa764ca68acd8332b1e9ce91782b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a7888fa764ca68acd8332b1e9ce91782b">Clone</a> (<a class="el" href="class_e_motion_f_x_1_1_skeleton.html">Skeleton</a> *skeleton) const </td></tr>
<tr class="separator:a7888fa764ca68acd8332b1e9ce91782b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c8e3162a6ddec4efa7e28406919ff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a85c8e3162a6ddec4efa7e28406919ff8">SetParentIndex</a> (size_t parentNodeIndex)</td></tr>
<tr class="separator:a85c8e3162a6ddec4efa7e28406919ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a15d300fe722135be9eb541aa2976be"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a7a15d300fe722135be9eb541aa2976be">GetParentIndex</a> () const </td></tr>
<tr class="separator:a7a15d300fe722135be9eb541aa2976be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03e2b77a04f0bb36a742533b02e6311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#ad03e2b77a04f0bb36a742533b02e6311">GetParentNode</a> () const </td></tr>
<tr class="separator:ad03e2b77a04f0bb36a742533b02e6311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc9d5b2d176742f3376149cf0371aa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a0fc9d5b2d176742f3376149cf0371aa7">RecursiveCollectParents</a> (AZStd::vector&lt; size_t &gt; &amp;parents, bool clearParentsArray=true) const </td></tr>
<tr class="separator:a0fc9d5b2d176742f3376149cf0371aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279129f67ab9c5667ea7246ad016e2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a279129f67ab9c5667ea7246ad016e2e8">SetName</a> (const char *name)</td></tr>
<tr class="separator:a279129f67ab9c5667ea7246ad016e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949ff13e90be709bd060244439c45849"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a949ff13e90be709bd060244439c45849">GetName</a> () const </td></tr>
<tr class="separator:a949ff13e90be709bd060244439c45849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf77d923e3c799ec05e33d91ef3f9977"><td class="memItemLeft" align="right" valign="top">const AZStd::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#abf77d923e3c799ec05e33d91ef3f9977">GetNameString</a> () const </td></tr>
<tr class="separator:abf77d923e3c799ec05e33d91ef3f9977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae414a3b4c94ee9ff0bd731f2f27aa778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#ae414a3b4c94ee9ff0bd731f2f27aa778">SetSemanticName</a> (const char *name)</td></tr>
<tr class="separator:ae414a3b4c94ee9ff0bd731f2f27aa778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9555ef7b3bf9cb4d1e753dd0e3f5e39"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#aa9555ef7b3bf9cb4d1e753dd0e3f5e39">GetSemanticName</a> () const </td></tr>
<tr class="separator:aa9555ef7b3bf9cb4d1e753dd0e3f5e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b5bf38b6929ee464339462ce610a2b"><td class="memItemLeft" align="right" valign="top">const AZStd::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#ac0b5bf38b6929ee464339462ce610a2b">GetSemanticNameString</a> () const </td></tr>
<tr class="separator:ac0b5bf38b6929ee464339462ce610a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f81e0aadc1d5be3eb6a895be8cdb09"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a77f81e0aadc1d5be3eb6a895be8cdb09">GetID</a> () const </td></tr>
<tr class="separator:a77f81e0aadc1d5be3eb6a895be8cdb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5286c98c179ee8fb896585179cdcd5e3"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a5286c98c179ee8fb896585179cdcd5e3">GetSemanticID</a> () const </td></tr>
<tr class="separator:a5286c98c179ee8fb896585179cdcd5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6dfa7cbc9257543d428df21791dafb"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#aff6dfa7cbc9257543d428df21791dafb">GetNumChildNodes</a> () const </td></tr>
<tr class="separator:aff6dfa7cbc9257543d428df21791dafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a293a5977c5e178b5e2e0b947586cf5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a6a293a5977c5e178b5e2e0b947586cf5">GetNumChildNodesRecursive</a> () const </td></tr>
<tr class="separator:a6a293a5977c5e178b5e2e0b947586cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967cfe1697656d30ab2130f690a876a9"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a967cfe1697656d30ab2130f690a876a9">GetChildIndex</a> (size_t nr) const </td></tr>
<tr class="separator:a967cfe1697656d30ab2130f690a876a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a2e157620e023f8273f9ec4c26092b"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a40a2e157620e023f8273f9ec4c26092b">CheckIfIsChildNode</a> (size_t nodeIndex) const </td></tr>
<tr class="separator:a40a2e157620e023f8273f9ec4c26092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba26a88367cc2b9ccc6b09f4a881f424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#aba26a88367cc2b9ccc6b09f4a881f424">AddChild</a> (size_t nodeIndex)</td></tr>
<tr class="separator:aba26a88367cc2b9ccc6b09f4a881f424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b96d73b043ad3e633df54d4a91ed855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a3b96d73b043ad3e633df54d4a91ed855">SetChild</a> (size_t childNr, size_t childNodeIndex)</td></tr>
<tr class="separator:a3b96d73b043ad3e633df54d4a91ed855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6750ea89cea3c320c3454bd1c31e83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#aef6750ea89cea3c320c3454bd1c31e83">SetNumChildNodes</a> (size_t numChildNodes)</td></tr>
<tr class="separator:aef6750ea89cea3c320c3454bd1c31e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2c19de7c6d7de7cbfbf15663c9efc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a7d2c19de7c6d7de7cbfbf15663c9efc4">PreAllocNumChildNodes</a> (size_t numChildNodes)</td></tr>
<tr class="separator:a7d2c19de7c6d7de7cbfbf15663c9efc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb6b0b2d361a17d50babbbbb0305b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a9bb6b0b2d361a17d50babbbbb0305b20">RemoveChild</a> (size_t nodeIndex)</td></tr>
<tr class="separator:a9bb6b0b2d361a17d50babbbbb0305b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12febf19f73e724e1db82e5b870c78f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a12febf19f73e724e1db82e5b870c78f7">RemoveAllChildNodes</a> ()</td></tr>
<tr class="separator:a12febf19f73e724e1db82e5b870c78f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48d8bd5c0fc15ffc243723e35189471"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#ad48d8bd5c0fc15ffc243723e35189471">GetIsRootNode</a> () const </td></tr>
<tr class="separator:ad48d8bd5c0fc15ffc243723e35189471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e96a597024b7c6da5913bea0fb047a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a7e96a597024b7c6da5913bea0fb047a8">GetHasChildNodes</a> () const </td></tr>
<tr class="separator:a7e96a597024b7c6da5913bea0fb047a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fd948d4364af7e3e6cab1910be8960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#af3fd948d4364af7e3e6cab1910be8960">FindRoot</a> () const </td></tr>
<tr class="separator:af3fd948d4364af7e3e6cab1910be8960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3250c93aabc9d2e9cbe0820c438a9ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#ae3250c93aabc9d2e9cbe0820c438a9ba">AddAttribute</a> (<a class="el" href="class_e_motion_f_x_1_1_node_attribute.html">NodeAttribute</a> *attribute)</td></tr>
<tr class="separator:ae3250c93aabc9d2e9cbe0820c438a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106d42e89ff430672dce73ab9823ac60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a106d42e89ff430672dce73ab9823ac60">GetNumAttributes</a> () const </td></tr>
<tr class="separator:a106d42e89ff430672dce73ab9823ac60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d69d64304baae5c2ab44757d55103bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node_attribute.html">NodeAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a6d69d64304baae5c2ab44757d55103bd">GetAttribute</a> (size_t attributeNr)</td></tr>
<tr class="separator:a6d69d64304baae5c2ab44757d55103bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655c776764bba11fc610d18155a671f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node_attribute.html">NodeAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a655c776764bba11fc610d18155a671f4">GetAttributeByType</a> (uint32 attributeType)</td></tr>
<tr class="separator:a655c776764bba11fc610d18155a671f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeec54bdc13ec3a201da9db8f333da4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a5eeec54bdc13ec3a201da9db8f333da4">FindAttributeNumber</a> (uint32 attributeTypeID) const </td></tr>
<tr class="separator:a5eeec54bdc13ec3a201da9db8f333da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d467a2f9e9e4a8aa9ba2b7a86b578a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a43d467a2f9e9e4a8aa9ba2b7a86b578a">RemoveAllAttributes</a> ()</td></tr>
<tr class="separator:a43d467a2f9e9e4a8aa9ba2b7a86b578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038e8ec99a69e44cfced556977e00241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a038e8ec99a69e44cfced556977e00241">RemoveAttribute</a> (size_t index)</td></tr>
<tr class="separator:a038e8ec99a69e44cfced556977e00241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44462deb7f1b8eb9cb3140a2dea58d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#ad44462deb7f1b8eb9cb3140a2dea58d1">RemoveAttributeByType</a> (uint32 attributeTypeID, size_t occurrence=0)</td></tr>
<tr class="separator:ad44462deb7f1b8eb9cb3140a2dea58d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b93f27175703320af69b99fcb93733"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a30b93f27175703320af69b99fcb93733">RemoveAllAttributesByType</a> (uint32 attributeTypeID)</td></tr>
<tr class="separator:a30b93f27175703320af69b99fcb93733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b57fe2810ddc5ec856bdd9f26ffcce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a62b57fe2810ddc5ec856bdd9f26ffcce">SetNodeIndex</a> (size_t index)</td></tr>
<tr class="separator:a62b57fe2810ddc5ec856bdd9f26ffcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01594402f558fc7ec1f9d684bd358e77"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a01594402f558fc7ec1f9d684bd358e77">GetNodeIndex</a> () const </td></tr>
<tr class="separator:a01594402f558fc7ec1f9d684bd358e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d9cc936aac939f3692f5b51841f47a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a13d9cc936aac939f3692f5b51841f47a">SetSkeletalLODLevelBits</a> (size_t bitValues)</td></tr>
<tr class="separator:a13d9cc936aac939f3692f5b51841f47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9b844d4e5d3145278b0432f3ec0fe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a6c9b844d4e5d3145278b0432f3ec0fe1">SetSkeletalLODStatus</a> (size_t lodLevel, bool enabled)</td></tr>
<tr class="separator:a6c9b844d4e5d3145278b0432f3ec0fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cb83046d049cc4d73885f37b49feaf"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a29cb83046d049cc4d73885f37b49feaf">GetSkeletalLODStatus</a> (size_t lodLevel) const </td></tr>
<tr class="separator:a29cb83046d049cc4d73885f37b49feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bea6612f73e97ba39b75f4c83cad4e"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a77bea6612f73e97ba39b75f4c83cad4e">GetIncludeInBoundsCalc</a> () const </td></tr>
<tr class="separator:a77bea6612f73e97ba39b75f4c83cad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf66b28d0a9adb5e686771433aa0bae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#acf66b28d0a9adb5e686771433aa0bae0">SetIncludeInBoundsCalc</a> (bool includeThisNode)</td></tr>
<tr class="separator:acf66b28d0a9adb5e686771433aa0bae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f19186bfa57f23c146853fb7638e638"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a8f19186bfa57f23c146853fb7638e638">GetIsCritical</a> () const </td></tr>
<tr class="separator:a8f19186bfa57f23c146853fb7638e638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ffa72c9d11da8f147080c8c0d913d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a10ffa72c9d11da8f147080c8c0d913d9">SetIsCritical</a> (bool isCritical)</td></tr>
<tr class="separator:a10ffa72c9d11da8f147080c8c0d913d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7346a1bb56f85bfacfbebbbfd95b8511"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#a7346a1bb56f85bfacfbebbbfd95b8511">GetIsAttachmentNode</a> () const </td></tr>
<tr class="separator:a7346a1bb56f85bfacfbebbbfd95b8511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa859f627e6256b55deab63f658f0d53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#afa859f627e6256b55deab63f658f0d53">SetIsAttachmentNode</a> (bool isAttachmentNode)</td></tr>
<tr class="separator:afa859f627e6256b55deab63f658f0d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_e_motion_f_x_1_1_base_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_e_motion_f_x_1_1_base_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a></td></tr>
<tr class="memitem:ab30842776f205a40428bf45079114a6a inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#ab30842776f205a40428bf45079114a6a">BaseObject</a> ()</td></tr>
<tr class="separator:ab30842776f205a40428bf45079114a6a inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3409404f7d117a896a45750468b7b86e inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#a3409404f7d117a896a45750468b7b86e">~BaseObject</a> ()</td></tr>
<tr class="separator:a3409404f7d117a896a45750468b7b86e inherit pub_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_core_1_1_memory_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_core_1_1_memory_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_core_1_1_memory_object.html">MCore::MemoryObject</a></td></tr>
<tr class="memitem:acbebcaf9fe821daf94eb391978453e86 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#acbebcaf9fe821daf94eb391978453e86">MemoryObject</a> ()</td></tr>
<tr class="separator:acbebcaf9fe821daf94eb391978453e86 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7656e1a1def84ff64945db88ee65c50 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#aa7656e1a1def84ff64945db88ee65c50">~MemoryObject</a> ()</td></tr>
<tr class="separator:aa7656e1a1def84ff64945db88ee65c50 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aca36760b0c56ec18d99f4f53c4335 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a51aca36760b0c56ec18d99f4f53c4335">IncreaseReferenceCount</a> ()</td></tr>
<tr class="separator:a51aca36760b0c56ec18d99f4f53c4335 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b277fe3fc49344884b522cdc7a305b inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a88b277fe3fc49344884b522cdc7a305b">DecreaseReferenceCount</a> ()</td></tr>
<tr class="separator:a88b277fe3fc49344884b522cdc7a305b inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8132c0072fb1b0b9b0e6cbf804af2a6d inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a8132c0072fb1b0b9b0e6cbf804af2a6d">Destroy</a> ()</td></tr>
<tr class="separator:a8132c0072fb1b0b9b0e6cbf804af2a6d inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ee52d71f71814c6114a021e05ef129 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_memory_object.html#a80ee52d71f71814c6114a021e05ef129">GetReferenceCount</a> () const </td></tr>
<tr class="separator:a80ee52d71f71814c6114a021e05ef129 inherit pub_methods_class_m_core_1_1_memory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaccb81f47af49c3c0ece710945be38ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#aaccb81f47af49c3c0ece710945be38ad">Create</a> (const char *name, <a class="el" href="class_e_motion_f_x_1_1_skeleton.html">Skeleton</a> *skeleton)</td></tr>
<tr class="separator:aaccb81f47af49c3c0ece710945be38ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9c022b4c1c9b70653e71fd52e7209f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_node.html#adc9c022b4c1c9b70653e71fd52e7209f">Create</a> (uint32 nameID, <a class="el" href="class_e_motion_f_x_1_1_skeleton.html">Skeleton</a> *skeleton)</td></tr>
<tr class="separator:adc9c022b4c1c9b70653e71fd52e7209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae4af50bf1743d112cb2c2c784bea21c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4af50bf1743d112cb2c2c784bea21c8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Actor</b></td></tr>
<tr class="separator:ae4af50bf1743d112cb2c2c784bea21c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985dc6f902e972617076a11ebb997b74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a985dc6f902e972617076a11ebb997b74"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkeletonModel</b></td></tr>
<tr class="separator:a985dc6f902e972617076a11ebb997b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_e_motion_f_x_1_1_base_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_e_motion_f_x_1_1_base_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_e_motion_f_x_1_1_base_object.html">EMotionFX::BaseObject</a></td></tr>
<tr class="memitem:a021c030d0ce454dfebc6631194c57f0d inherit pro_methods_class_e_motion_f_x_1_1_base_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_base_object.html#a021c030d0ce454dfebc6631194c57f0d">Delete</a> () override</td></tr>
<tr class="separator:a021c030d0ce454dfebc6631194c57f0d inherit pro_methods_class_e_motion_f_x_1_1_base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The node class. A node in EMotion FX is a connection point in the hierarchy of the character. Each node can have one parent, but multiple child nodes. Every node has a transformation describing the orientation of the node, so where it is positioned and how it is scaled and rotated in 3D space. Examples of nodes could be a bone, like an upper arm or lower arm, a finger, a head, a gun, a cigarette, a camera, a light, etc. So basically it can be everything, which can be animated (but it doesn't have to be animated of course). </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a2a4cb7ec2cc3b49d48c7cab13c2b5fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_e_motion_f_x_1_1_node.html#a2a4cb7ec2cc3b49d48c7cab13c2b5fb5">EMotionFX::Node::ENodeFlags</a> : AZ::u8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The node flags (options). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a2a4cb7ec2cc3b49d48c7cab13c2b5fb5a775ba1646de81c5cf4278538df79cd0d"></a>FLAG_INCLUDEINBOUNDSCALC</em>&nbsp;</td><td class="fielddoc">
<p>Specifies whether we have to include this node in the bounds calculation or not (true on default). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2a4cb7ec2cc3b49d48c7cab13c2b5fb5aa1438431a18f7ed4723349cd1c9c0786"></a>FLAG_ATTACHMENT</em>&nbsp;</td><td class="fielddoc">
<p>Indicates if this node is an attachment node or not (false on default). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2a4cb7ec2cc3b49d48c7cab13c2b5fb5af41d36b58935aa539698c047bdd21fdd"></a>FLAG_CRITICAL</em>&nbsp;</td><td class="fielddoc">
<p>Indicates if this node is a critical node. A critical node is always included the skeleton and cannot be optimized out (false on default). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae3250c93aabc9d2e9cbe0820c438a9ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::AddAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_node_attribute.html">NodeAttribute</a> *&#160;</td>
          <td class="paramname"><em>attribute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a node attribute to this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>The attribute to add to the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba26a88367cc2b9ccc6b09f4a881f424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::AddChild </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a child to this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>The index of the child node to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40a2e157620e023f8273f9ec4c26092b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE bool EMotionFX::Node::CheckIfIsChildNode </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given node is a child of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>The node to check whether it is a child or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given node is a child, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a7888fa764ca68acd8332b1e9ce91782b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::Node::Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_skeleton.html">Skeleton</a> *&#160;</td>
          <td class="paramname"><em>skeleton</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clone the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skeleton</td><td>The skeleton that the cloned node will be part of, you still need to manually add it to this skeleton though. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cloned node. </dd></dl>

</div>
</div>
<a class="anchor" id="aaccb81f47af49c3c0ece710945be38ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::Node::Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_skeleton.html">Skeleton</a> *&#160;</td>
          <td class="paramname"><em>skeleton</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node. </td></tr>
    <tr><td class="paramname">skeleton</td><td>The skeleton where this node will belong to, you still need to manually add it to the skeleton though. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc9c022b4c1c9b70653e71fd52e7209f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::Node::Create </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>nameID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_skeleton.html">Skeleton</a> *&#160;</td>
          <td class="paramname"><em>skeleton</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create method using a name ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nameID</td><td>The name ID, generated using the MCore::GetStringIdPool(). </td></tr>
    <tr><td class="paramname">skeleton</td><td>The skeleton where this node will belong to, you still need to manually add it to the skeleton though. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5eeec54bdc13ec3a201da9db8f333da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Node::FindAttributeNumber </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>attributeTypeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the node attribute number of a given type. When there are no node attributes, or there is no attribute of the specified type this method will return MCORE_INVALIDINDEX32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributeTypeID</td><td>The attribute type ID (returned by <a class="el" href="class_e_motion_f_x_1_1_node_attribute.html#aa5554a98c9b35049e430f864af822319">NodeAttribute::GetType()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first located attribute number which is of the given type, or MCORE_INVALIDINDEX32 when the attribute of this type could not be located. </dd></dl>

</div>
</div>
<a class="anchor" id="af3fd948d4364af7e3e6cab1910be8960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::Node::FindRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root node in the hierarchy. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node (can point to itself). </dd></dl>

</div>
</div>
<a class="anchor" id="a6d69d64304baae5c2ab44757d55103bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node_attribute.html">NodeAttribute</a>* EMotionFX::Node::GetAttribute </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attributeNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a given node attribute. You will need to typecast to the correct type of the attribute yourself. You can get the attribute type by using the <a class="el" href="class_e_motion_f_x_1_1_node_attribute.html#aa5554a98c9b35049e430f864af822319">NodeAttribute::GetType()</a> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributeNr</td><td>The attribute number to get from the node. You can find the attribute number when you have the attribute type by using the <a class="el" href="class_e_motion_f_x_1_1_node.html#a5eeec54bdc13ec3a201da9db8f333da4">FindAttributeNumber()</a> method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node attribute. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>FindNodeAttributeNumber </dd></dl>

</div>
</div>
<a class="anchor" id="a655c776764bba11fc610d18155a671f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node_attribute.html">NodeAttribute</a>* EMotionFX::Node::GetAttributeByType </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>attributeType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a given node attribute of a given type. The method will return nullptr when no attribute of the specified type could be found. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node attribute, or nullptr when not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a967cfe1697656d30ab2130f690a876a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t EMotionFX::Node::GetChildIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a given child's node index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The child number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the child node, which is a node number inside the actor. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e96a597024b7c6da5913bea0fb047a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Node::GetHasChildNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this node has any child nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when this node has child nodes, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a77f81e0aadc1d5be3eb6a895be8cdb09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 EMotionFX::Node::GetID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the unique ID of this node, which has been generated based on the name. You are guaranteed that nodes having the same name have the same ID. This means you can do fast compares between nodes by using the ID instead of a comparison between the node names. However, ever time you run the application, the ID values for given names can be different. So if you run your program, the node with name "Arm" might have an ID of 10. While next time you run the program this node might have an ID of for example 36. Still it is guaranteed that every time you run your program all nodes with the name "Arm" will have the same ID number. </p>
<dl class="section return"><dt>Returns</dt><dd>The node ID number, which can be used for fast compares between nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a77bea6612f73e97ba39b75f4c83cad4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE bool EMotionFX::Node::GetIncludeInBoundsCalc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether this node is included inside the bounding volume calculations or not. Sometimes it is useful to disable some nodes from the bounding volume calculation. Examples of these are nodes that are lights or cameras, or nodes that just always stay at the origin, while your character moves away from the origin without motion based actor repositioning. On default all nodes are included inside the bounding volume calculations. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when this node will be included in the bounds calculation, or false when it won't. </dd></dl>

</div>
</div>
<a class="anchor" id="a7346a1bb56f85bfacfbebbbfd95b8511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Node::GetIsAttachmentNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the node is an attachment node. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the node is an attachment node, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f19186bfa57f23c146853fb7638e638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE bool EMotionFX::Node::GetIsCritical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether this node is critcal and should not be optimized out in any situations. Sometimes we perform optimization process on the node. This flag make sure that critical node will always be included in the actor heirarchy. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when this node is critical, or false when it won't. </dd></dl>

</div>
</div>
<a class="anchor" id="ad48d8bd5c0fc15ffc243723e35189471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Node::GetIsRootNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this node is a root node. A node is seen as root node when it has no parent. So if <a class="el" href="class_e_motion_f_x_1_1_node.html#ad03e2b77a04f0bb36a742533b02e6311">Node::GetParentNode()</a> equals nullptr we are dealing with a root node. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when this node is a root node, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a949ff13e90be709bd060244439c45849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* EMotionFX::Node::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of the node in form of a C character buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the null terminated buffer, containing the name of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="abf77d923e3c799ec05e33d91ef3f9977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AZStd::string&amp; EMotionFX::Node::GetNameString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of the node in form of String object. </p>
<dl class="section return"><dt>Returns</dt><dd>The string containing the node name. </dd></dl>

</div>
</div>
<a class="anchor" id="a01594402f558fc7ec1f9d684bd358e77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t EMotionFX::Node::GetNodeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the node index value. This is the index inside the array of nodes inside the <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a>. So Actor::GetNode( nodeIndex ) will return this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a106d42e89ff430672dce73ab9823ac60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Node::GetNumAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of node attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of node attributes for this node. </dd></dl>

</div>
</div>
<a class="anchor" id="aff6dfa7cbc9257543d428df21791dafb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t EMotionFX::Node::GetNumChildNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of child nodes attached to this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of child nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a293a5977c5e178b5e2e0b947586cf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Node::GetNumChildNodesRecursive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of child nodes down the hierarchy of this node. The current node is not included in the count. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of nodes down the hierarchy of this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a15d300fe722135be9eb541aa2976be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t EMotionFX::Node::GetParentIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the parent node's index. This is either a valid index, or MCORE_INVALIDINDEX32 in case there is no parent node. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the parent node, or MCORE_INVALIDINDEX32 in case this node has no parent. </dd></dl>

</div>
</div>
<a class="anchor" id="ad03e2b77a04f0bb36a742533b02e6311"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::Node::GetParentNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the parent node as node pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to the parent node, or nullptr in case there is no parent. </dd></dl>

</div>
</div>
<a class="anchor" id="a5286c98c179ee8fb896585179cdcd5e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 EMotionFX::Node::GetSemanticID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the semantic name ID. To get the name you can also use <a class="el" href="class_e_motion_f_x_1_1_node.html#aa9555ef7b3bf9cb4d1e753dd0e3f5e39">GetSemanticName()</a> and <a class="el" href="class_e_motion_f_x_1_1_node.html#ac0b5bf38b6929ee464339462ce610a2b">GetSemanticNameString()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The semantic name ID. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9555ef7b3bf9cb4d1e753dd0e3f5e39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* EMotionFX::Node::GetSemanticName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the semantic name. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the null terminated buffer, containing the semantic name of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0b5bf38b6929ee464339462ce610a2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AZStd::string&amp; EMotionFX::Node::GetSemanticNameString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the semantic name as string. </p>
<dl class="section return"><dt>Returns</dt><dd>The string containing the semantic name. </dd></dl>

</div>
</div>
<a class="anchor" id="a29cb83046d049cc4d73885f37b49feaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE bool EMotionFX::Node::GetSkeletalLODStatus </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the skeletal LOD status for this node at a given skeletal LOD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The skeletal LOD level to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when this node is enabled in the specified LOD level. Otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d2c19de7c6d7de7cbfbf15663c9efc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::PreAllocNumChildNodes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numChildNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preallocate the array of child nodes. Unlike SetNumChildNodes, this will NOT grow the child node array as reported by <a class="el" href="class_e_motion_f_x_1_1_node.html#aff6dfa7cbc9257543d428df21791dafb">GetNumChildNodes()</a>. However, it internally pre-allocates memory to make the <a class="el" href="class_e_motion_f_x_1_1_node.html#aba26a88367cc2b9ccc6b09f4a881f424">AddChild()</a> calls faster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numChildNodes</td><td>The number of child nodes to pre-allocate space for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fc9d5b2d176742f3376149cf0371aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::RecursiveCollectParents </td>
          <td>(</td>
          <td class="paramtype">AZStd::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearParentsArray</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively go through the parents until a root node is reached and store all parents inside an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parents</td><td>The array to which parent and the parents of the parents of the node will be added. </td></tr>
    <tr><td class="paramname">clearParentsArray</td><td>When true the given parents array will be cleared before filling it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43d467a2f9e9e4a8aa9ba2b7a86b578a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::RemoveAllAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all node attributes from this node. The previously allocated attributes will be deleted from memory automatically. </p>

</div>
</div>
<a class="anchor" id="a30b93f27175703320af69b99fcb93733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Node::RemoveAllAttributesByType </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>attributeTypeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all node attributes from this node of the given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributeTypeID</td><td>The attribute type ID (returned by <a class="el" href="class_e_motion_f_x_1_1_node_attribute.html#aa5554a98c9b35049e430f864af822319">NodeAttribute::GetType()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of attributes that have been removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a12febf19f73e724e1db82e5b870c78f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::RemoveAllChildNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all child nodes (not from memory though but just clears the childs pointers in this node). Beware, the child nodes will still point to this node after executing this method! So you have to adjust their parent indices manually. </p>

</div>
</div>
<a class="anchor" id="a038e8ec99a69e44cfced556977e00241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::RemoveAttribute </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the given node attribute from this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the node attribute to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad44462deb7f1b8eb9cb3140a2dea58d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::RemoveAttributeByType </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>attributeTypeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the given node attribute from this node which occurs at the given position. If the given occurrence is bigger than the number of actual attributes inside the node no node attribute will be removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributeTypeID</td><td>The attribute type ID (returned by <a class="el" href="class_e_motion_f_x_1_1_node_attribute.html#aa5554a98c9b35049e430f864af822319">NodeAttribute::GetType()</a>). </td></tr>
    <tr><td class="paramname">occurrence</td><td>The number of node attributes which will be skipped until we reached the node to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bb6b0b2d361a17d50babbbbb0305b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::RemoveChild </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a given child (does not delete it from memory though). Beware, the child node will still point to this node after executing this method! So you have to adjust the parent pointer of the child node manually. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>The index of the child to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b96d73b043ad3e633df54d4a91ed855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetChild </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>childNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>childNodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the value for a given child node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childNr</td><td>The child number, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_node.html#aff6dfa7cbc9257543d428df21791dafb">GetNumChildNodes()</a>-1]. </td></tr>
    <tr><td class="paramname">childNodeIndex</td><td>The node index for this child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf66b28d0a9adb5e686771433aa0bae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetIncludeInBoundsCalc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeThisNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify whether this node should be included inside the bounding volume calculations or not. Sometimes it is useful to disable some nodes from the bounding volume calculation. Examples of these are nodes that are lights or cameras, or nodes that just always stay at the origin, while your character moves away from the origin without motion based actor repositioning. On default all nodes are included inside the bounding volume calculations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includeThisNode</td><td>Set to true when you want this node to be included in the bounds calculation, or set to false when it should be excluded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa859f627e6256b55deab63f658f0d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetIsAttachmentNode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAttachmentNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set if the node is an attachment node. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the node is an attachment node, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a10ffa72c9d11da8f147080c8c0d913d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetIsCritical </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCritical</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify whether this node is critcal and should not be optimized out in any situations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isCritical</td><td>Set to true when you want this node to be critical. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a279129f67ab9c5667ea7246ad016e2e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the node name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new node name, which should be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62b57fe2810ddc5ec856bdd9f26ffcce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetNodeIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the node index for this node. This has to be the index inside the array of nodes inside the <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a>. So Actor::GetNode( nodeIndex ) will return this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef6750ea89cea3c320c3454bd1c31e83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetNumChildNodes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numChildNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize the array of child nodes. This will grow the child node array so that the value returned by <a class="el" href="class_e_motion_f_x_1_1_node.html#aff6dfa7cbc9257543d428df21791dafb">GetNumChildNodes()</a> will return the same value as you specify as parameter here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numChildNodes</td><td>The number of child nodes to create. Be sure to initialize all of the child nodes using <a class="el" href="class_e_motion_f_x_1_1_node.html#a3b96d73b043ad3e633df54d4a91ed855">SetChild()</a> though! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85c8e3162a6ddec4efa7e28406919ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetParentIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>parentNodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the parent node index. When this is set to MCORE_INVALIDINDEX32 then this is considered as no parent. In that case this node is a root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentNodeIndex</td><td>The node index of the node where to link this node to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae414a3b4c94ee9ff0bd731f2f27aa778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetSemanticName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the semantic name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new node name, which should be unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13d9cc936aac939f3692f5b51841f47a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetSkeletalLODLevelBits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the skeletal LOD status for all LOD levels. Each bit specifies whether this node is active in a given LOD or not. Bit 0 represents LOD 0, bit 1 represents LOD 1, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitValues</td><td>The unsigned 32-bits integer that contains the settings for each LOD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c9b844d4e5d3145278b0432f3ec0fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Node::SetSkeletalLODStatus </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the skeletal LOD status for a given LOD level. This enables or disables the node entirely from all calculations inside EMotion FX. It is important to know that the nodes that you disable should not be used anywhere inside skinning information of meshes or other places where there transformations are needed. There are 32 possible LOD levels. On default all nodes are enabled in a given LOD that hasn't been initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The skeletal LOD level to change the settings for. This must be in range of [0..31]. </td></tr>
    <tr><td class="paramname">enabled</td><td>Set to true when you wish the node to be enabled in the given LOD, or false when you wish to disable it in the given LOD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/EMotionFX/Code/EMotionFX/Source/Node.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>EMotionFX</b></li><li class="navelem"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a></li>
    <li class="footer">Generated on Thu Apr 20 2023 21:34:13 for Open 3D Engine EMotionFX Gem API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
