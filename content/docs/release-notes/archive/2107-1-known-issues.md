---
linktitle: 2107.1 Known Issues
title: Known Issues for Open 3D Engine 2107.1 (alpha)
description: Find out the known issues in 2107.1 (alpha).
weight: 102
toc: true
menu_uuid: releasenotes
guide_img: "/images/release-notes/guide_img.svg"
---

Open 3D Engine (O3DE) Release 2107.1 (alpha) has the following known issues:

## AI

* AI Components are unusable due to missing Agent Types.

## Asset Pipeline

* Virtual File System (VFS) is not currently working correctly.

## Atom

* Atom debug information is not currently displayed in the O3DE Editor.
* Duplication of entities throws an Out of Memory error.
* "Planting" with Dynamic Vegetation on Atom meshes results in unpredictable behavior.
* Rendering errors using Vulkan with NVidia's Titan X hardware.
* (macOS only) AutomatedTesting.GameLauncher and the O3DE Editor cannot be started.

### Global Illumination and Reflections

* Diffuse probes incorrectly alter **BoxShape** sizes.

### Raytracing

* Vulkan ray tracing crashes on NVidia 10-series cards.

### Render Hardware Interface (RHI)

The following errors occur using RHI with Vulkan on Android platforms:

* Dynamic Material Test throws Device Lost error upon switch test material on Mali
* Device lost on Features/SSAO sample
* Device lost error on Features/LightCulling sample
* Device lost on Features/Exposure sample
* Device lost on Features/Exposure sample
* Unknown error assert for RPI/SceneReloadTest
* Unknown error assert for RPI/Dynamic Material Test
* Unknown error assert for RPI/AssetLoadTest
* RPI/DynamicDrawTest assert: Vulkan API method failed: Unknown error
* Crash on RPI/Bistrobenchmark sample

## Character

* You cannot currently save **Event Data** to **Motion Events**.

## Editor

* O3DE Editor layout is broken in Atom projects when moved to a second monitor.

## UI Canvas (LYShine)

* UI Canvas cannot meet Mesh component dependencies at this time.
* The Masking function does not currently work with the Atom renderer.

## Platforms

* A target must currently be specified when registering a Gem.
* (macOS only) Using XCode's Modern Build System fails in Jenkins.
* (iOS only) CMake generator expressions used in the `Find<3rdParty>.cmake` files don't currently work.
* (iOS only) Building the `AutomatedTesting` project fails.
* (Android only) Building an APK with `gradlew assembleProfile` fails.

## Systems

* After an o3de project is built, the `project_path` is still incorrectly points to "AutomatedTest".

## NVIDIA Blast

* The supplied pre-compiled plug-ins support Houdini 18.0 only.
* Some Houdini installations might create the Houdini user directory at `C:\Users\user_name\houdini18.0\` rather than in the `Documents` directory. If Houdini does not load the NVIDIA Blast tools, check to see if Houdini has created a user directory at `C:\Users\<user_name>\houdini18.0\`. If the directory exists and contains Houdini files such as `dso.cache`, move the above files to `C:\Users\<user_name>\houdini18.0\` and add `C:\Users\<user_name>\houdini18.0\` to the Windows **PATH** environment variable.
* The number of chunks generated by **Fracture Hierarchy** grows exponentially. Setting the **Fracture levels** and **Fractures per level** too high can generate assets that are too large to load and simulate with NVIDIA Blast. For fine control over multiple fracture levels, use multiple **Fracture Single** SOPs.
* Once you have manually edited a `.fbx` asset for NVIDIA Blast in **FBX Settings**, a `.assetinfo` file is created for the `.fbx` asset. The `.assetinfo` file prevents the mesh assets from being processed automatically by **Python Asset Builder**. Any further changes made to the source `.fbx` file, such as adding or removing fracture levels or chunks, must be manually edited in **FBX Settings**.
* Passive forces like gravity can have a cumulative damage effect on a NVIDIA Blast assets causing destruction to trigger when no obvious external force or collider has acted on the asset, particularly with large objects. To mitigate this, be sure to create `.blast` materials for your NVIDIA Blast assets and set the Health and Damage Thresholds appropriately for the asset.

## NVIDIA Cloth

* Cloth Debug Visualization will not show when running from Launchers.
* Cloth does not support LOD meshes.
* Cloth does not support scaled transforms.
* An Actor Component using a mesh with cloth modifiers will not preview animation in the editor for its cloth nodes unless the Cloth Component has **Simulate in editor** property enabled as well. **Game mode** is not affected.
* Cloth does not collide with Actor cloth colliders in the O3DE Editorâ€™s **Preview Mode**. However, cloth does collide with Actor cloth colliders in **Game Mode**.
* The O3DE debug display system is always rendered with a 1 frame delay. The cloth mesh component compensates for this by sending draw calls with the previous frame data while the **Cloth Debug Display** draws the current data. This workaround suffices when the entity is not moving. However, when an actor has an animation that moves the root bone, the cloth colliders are delayed in the debug display. On top of that, if the animation graph uses the root bone to move the entity (motion extraction joint), then both the cloth debug mesh and the colliders are delayed in debug display.

## PhysX

* It may be possible for the **PhysX Character Controller** to climb slopes or steps higher than expected if the **Step Height** value is set to 0, or if the **Maximum Slope Angle** is set to a small value (15 degrees or less).
* There is currently no mechanism to automatically disable collisions between a **PhysX Character Controller** and a **PhysX Ragdoll** belonging to the same character, which will cause simulated characters to behave unexpectedly. Collisions can be prevented using the collision filtering settings for the controller and the ragdoll nodes.
* Joint limits may be exceeded in the ragdoll because of interactions with animated movements.
* If the PhysX collider and the mesh are the same size, you will observe jittering during rendering. This behavior is expected.
* Functional and rendering issues, such as jittering, occur if you apply impulse to parent-child entities that have **PhysX Rigid Body** components. To work around this issue, use joints.
* When there is more than one **PhysX Ragdoll** component in your level, increasing the **Position Iteration Count** and **Velocity Iteration Count** parameters of one ragdoll affects the other ragdolls.
* Modifying the **World Transform** of entities with non-kinematic **PhysX Rigid Body** Components at game-time (with scripts) is not supported and may result in unexpected behavior.
* The existing cases of using `RayCast` and `ShapeCast` must be evaluated to see where the hits from the inside of collision mesh are desired. In those cases, the `Physics::HitFlags::MeshBothSides` flag needs to be added to `RayCastRequest::m_hitFlags` or `ShapeCastRequest::m_hitFlags`.
    {{< note >}}
    This only applies to triangle meshes. Primitives and Convex meshes are considered to be solid and will give the hit from the inside if ray starting position is inside the shape (the distance will be 0 in this case).
    {{< /note >}}
* If the PhysX TGS solver is enabled, ragdolls with high position or velocity iteration counts can become unstable. Note that PhysX internally groups together nearby bodies for simulation and uses the highest iteration counts of any object in the grouping, so ragdolls with high iteration counts may affect other nearby ragdolls.
* V-HACD Mesh Decomposition:
    * Mesh decomposition is only available if the export type is selected as Convex or Primitive.
    * The actual results achieved by the decomposition depend mostly on the V-HACD library and are out of our control.
* Importing from FBX as Primitive with automatic **Target Shape**:
    * Almost any FBX mesh will be exportable, but the accuracy of the result will depend on how close the mesh is to one of the supported primitives.
    * O3DE will attempt to fix one primitive for each node selected for export. It will not recognize multiple primitive shapes contained within the same node.
    * The algorithm considers only the vertices of the mesh, not edges/faces. Apart from some edge cases, this is usually sufficient, but the user may need to configure the export parameters correctly before a desirable result is obtained.
    * The algorithm is subject to mathematical restrictions and does not work well if the mesh has extreme proportions or sizes. Likewise, a vertex cloud that predominantly occupies a lower dimension subspace (plane, line or point) will not work well.
    * Non-uniform scaling of automatically fitted primitive colliders can have unintuitive behavior and is not recommended.
* PhysX parameter changes in the **PhysX Configuration** window may only take effect when the editor is restarted.
* Using multiple ragdolls with pose moves may result in poor performance.
* Entity transforms would not be updated correctly for ragdolls if physics is disabled on the character controller.