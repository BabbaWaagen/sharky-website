---
linktitle: Overview
title: Overview of Event Messaging Systems
description: Use event buses (EBus), AZ::Interface, and AZ::Event to dispatch messages between systems in Open 3D Engine (O3DE). 
weight: 100
---

Event messaging systems are essential to a game engine because they allow each system to communicate with each other. **Open 3D Engine (O3DE)** uses a few types of communication methods, which are separated into the following modules: 

- **Event Bus (EBus)**: A single global bus that all modules can use to invoke requests and dispatch messages, respectively known as *request* and *notification* buses.
- `AZ::Interface`: A C++ template class for a global interface that other components can invoke requests from. The equivalent of the EBus sytem's request bus.
- `AZ::Event`: A C++ template class that can publish single-value messages, which other components can subscribe to. The equivalent of the EBus system's notification bus.

Some of the functionality of these three modules overlaps: `AZ::Interface` provides a request interface, `AZ::Event` provides a publish-subscribe interface, and EBus provides both. However, each module has strengths and weaknesses that make it more suitable for different scenarios.

The following table compares some key characteristics of EBus, `AZ::Interface`, and `AZ::Event`. You can find all three event messaging modules throughout O3DE's code base.

| | `AZ::Interface` | `AZ::Event` | EBus |
| --- | --- | --- | --- |
| **Communication model** | An `AZ::Interface<T>` template specialization defines a global singleton-like request interface, which other systems can invoke. Other systems can simply access the request interface by calling `AZ::Interface<T>.Get()`.  | `AZ::Event`s are defined as members of a component and as such, other components must have a reference to the component to subscribe to the event. To listen and process an event, subscriber components must implement a handler. A single handler can only connect to one event, but an event can have multiple handlers. <br><br>Some patterns for cross-entity communication include:<ul><li>Exposing the `AZ::Event` to an `AZ::Interface`</li><li>Calling `SceneQuery()` and `AZ::IVisibility` to get a reference to the entity</li></ul>| EBus is a general purpose event messaging system whose design focuses on abstraction and decoupling systems. It allows many source components to provide requests or publish messages, and many listener components to invoke those requests or subscribe to those messages - all without the components having to know about each other. Unlike `AZ::Event`, a listener can subscribe to an EBus specialization even if it doesn't exist yet. |
| **Lifetime** | There can only be a single instance of an `AZ::Interface<T>` specialization at a time. It initializes when the application launches and gets destroyed when the application is terminated. | There can be many instances of an `AZ::Event<T>` specialization. Each instance must be attached to a component. It initializes when the component is created and gets destroyed when the component is destroyed. | EBus is a global singleton. It initializes when the application launches and gets destroyed when the application terminates. |
| **Scripting** | `AZ::Interface` doesn't support script binding. You can still use `AZ::Interface`, but you must also use an EBus to expose it to scripting modules. | `AZ::Event` supports script binding. | EBus supports script binding for both its notification bus (like `AZ::Event`) and request bus (unlike `AZ::Interface`). |
| **Advantages** | Compared to EBus, `AZ::Interface` has improved runtime performance, improved debuggability, and compatibility with code autocomplete. | Compared to EBus, `AZ::Event` has improved runtime performance, allows simpler syntax to implement, uses fewer files, and removes aggregate interfaces where a handler cares only about a subset of events. | EBus is O3DE's most flexible and powerful event messaging system. Any system can connect to it and communicate with any other system by simply providing a system's EBus name. EBus is generally used for situations in which event flow is more important than the source of the event. |
| **Examples** | A spawner-spawnee system. The spawner interface contains functions to manage spawnees. If you want another class to spawn something, that class can make a request via  `AZ::Interface<ISpawner>`. By calling `AZ::Interface<ISpawner>.Get()`, other components can invoke requests from the spawner. | In the networking layer, when a remote process call (RPC) is sent, it signals an `AZ::Event<NetworkEntityRpcMessage&>`. Then, a connected handler listens for that signal change and processes the `NetworkEntityRpcMessage`. | EBus examples are similar to `AZ::Interface` and `AZ::Event`. In most cases, using those two is preferable due to their optimizations. However, you must use EBus to add script binding support for request buses. |