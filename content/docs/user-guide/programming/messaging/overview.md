---
linktitle: Overview
title: Overview of Event Messaging Systems
description: Use event buses (EBus), AZ::Interface, and AZ::Event to dispatch messages between systems in Open 3D Engine (O3DE). 
weight: 100
---

Event messaging systems are essential to a game engine because they allow each system to communicate with each other. **Open 3D Engine (O3DE)** uses a few types of communication methods, which are separated into the following modules: 

- Event bus (EBus): A single global bus that all modules can use to invoke requests and dispatch messages, respectively known as a *request* and *notification* buses.
- `AZ::Interface`: A C++ template class for a global interface that other components can invoke requests from. The equivalent of EBus's request bus.
- `AZ::Event`: A C++ template class that can publish single value messages, which other components can subscribe to. The equivalent of EBus's notification bus.

These three modules overlap some of their functionality: `AZ::Interface` provides a request interface, `AZ::Event` provides a publish-subscribe interface, and EBus provides both. However, each has strengths and weaknesses that make them more suitable for different scenarios. 

At a glance, the following table compares some key characteristics of EBus, `AZ::Interface`, and `AZ::Event`. All three event messaging modules can be found throughout O3DE's code base.

| | EBus | `AZ::Interface` | `AZ::Event` |
| --- | --- | --- | --- |
| **Communication model** |  EBus is a general purpose event messaging system whose design focuses on abstraction and decoupling systems. It allows many source components to provide requests or publish messages. It also allows many listener components to invoke those requests or subscribe to those messages---all without the components having to know about each other. Unlike `AZ::Event`, a listener can subscribe to an EBus specialization even if the EBus doesn't exist yet. | An `AZ::Interface<T>` template specialization defines a global singleton-like request interface that other systems can invoke. To access the request interface, other systems can call `AZ::Interface<T>.Get()`. | `AZ::Event` events are defined as members of a component. As such, other components must have a reference to the component to subscribe to the event. To listen and process an event, subscriber components must implement a handler. A single handler can connect to only one event, but an event can have multiple handlers.<br><br>Some patterns for cross-entity communication include:<ul><li>Exposing the `AZ::Event` to an `AZ::Interface`.</li><li>Calling `SceneQuery()` and `AZ::IVisibility` to get a reference to the entity.</li></ul> |
| **Lifetime** | EBus is a global singleton that initializes when the application launches and gets destroyed when the application terminates. | There can be only a single instance of an `AZ::Interface<T>` specialization at a time. An instance initializes when the application launches and gets destroyed when the application is terminated. | There can be many instances of an `AZ::Event<T>` specialization. Each instance must be attached to a component. An instance initializes when the component is created and gets destroyed when the component is destroyed. |
| **Scripting** | EBus has script-binding support for both its notification bus (same as AZ::Event), and request bus (unlike AZ::Interface). | There is no script binding support for `AZ::Interface`. You can still use `AZ::Interface`, but you must also use an EBus to expose it to scripting modules. | `AZ::Event` has script binding support. |
| **Advantages** | EBus is O3DE's most flexible and powerful event messaging system. Any system can connect to it and communicate with any other system by simply providing a system's EBus name. EBus is generally used for situations where event flow is more important than the source of the event. | Compared to EBus, `AZ::Interface` has improved runtime performance, improved debuggability, and compatibility with code autocomplete. | Compared to EBus, `AZ::Event` has improved runtime performance, allows simpler syntax to implement, uses fewer files, and removes aggregate interfaces where a handler only cares about a subset of events. |
| **Examples** | EBus examples are similar to `AZ::Interface` and `AZ::Event`. In most cases, using those two is more preferable due to their optimizations. However, you must use EBus to add script-binding support for request busses.  | A spawner-spawnee system. The spawner interface contains functions to manage spawnees. If we want another class to spawn something, that class can make a request via  `AZ::Interface<ISpawner>`. By calling `AZ::Interface<ISpawner>.Get()`, other components can invoke requests from the spawner. | In the networking layer, when a remote process call (RPC) is sent, it signals an `AZ::Event<NetworkEntityRpcMessage&>`. Then, a connected handler listens for that signal change and processes the `NetworkEntityRpcMessage`. |