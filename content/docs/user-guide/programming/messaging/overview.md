---
linktitle: Overview
title: Overview of Event Messaging Systems
description: Use event buses (EBus), AZ::Interface, and AZ::Event to dispatch messages between systems in Open 3D Engine (O3DE). 
weight: 100
---

Event messaging systems are essential to a game engine because they allow each system to communicate with each other. **Open 3D Engine (O3DE)** uses a few types of communication methods, which are separated into the following modules: 

- Event bus (EBus): A single global bus that all modules can use to invoke requests and dispatch messages, respectively known as a *request* and *notification* buses.
- `AZ::Interface`: A C++ template class for a global interface that other components can invoke requests from. 
- `AZ::Event`: A C++ template class that can publish single value messages, which other components can subscribe to. 

These three modules overlap some of their functionality: `AZ::Interface` provides a request interface, `AZ::Event` provides a publish-subscribe interface, and EBus provides both. However, each has strengths and weaknesses that make them more suitable for different scenarios. 

At a glance, the following table compares some key characteristics of EBus, `AZ::Interface`, and `AZ::Event`. All three event messaging modules can be found throughout O3DE's code base.

| | `AZ::Interface` | `AZ::Event` | EBus |
| --- | --- | --- | --- |
| Communication model | An `AZ::Interface<T>` template specialization defines a global singleton-like request interface, which other systems can invoke. Other systems can simply access the request interface by calling `AZ::Interface<T>.Get()`.  | An `AZ::Event` instance must be attached to a source component. Therefore, other components must have a reference to the source component to subscribe to the event. Other components subscribe to an event by implementing a handler that will process the event when it's signaled. An event can be signaled by calling `Signal()`, which subscribers can listen to and process via their event handler. A handler can only connect to one event, but an event can have multiple handlers. Events are useful for components talking to other components within the same entity. For cross-entity communication, you can implement `AZ::Event`s on an `AZ::Interface`, or use an EBus. | EBus is a general purpose event messaging system whose design focuses on abstraction and decoupling systems. It allows many source components to provide requests or publish messages, and many listener components to invoke those requests or subscribe to those messages - all without the components having to know about each other. Unlike `AZ::Event`, a listener can subscribe to an EBus specialization even if it doesn't exist yet. |
| Lifetime | There can only be a single instance of an `AZ::Interface<T>` specialization at a time. It initializes when the application launches and gets destroyed when the application is terminated. | There can be many instances of an `AZ::Event<T>` specialization. Each instance must be attached to a component. It initializes when the component is created and gets destroyed when the component is destroyed. | EBus is a global singleton. It initializes when the application launches and gets destroyed when the application terminates. |
| Scripting |  |  | Unlike `AZ::Interface`, only EBus can connect to scripting. This allows your component to expose its functionality to O3DE's scripting modules, such as Script Canvas and Lua. |
| Advantages | Compared to EBus, `AZ::Interface` has improved runtime performance, improved debuggability, and compatibility with code autocomplete. | Compared to EBus, `AZ::Event` has improved runtime performance, allows simpler syntax to implement, uses fewer files, and removes aggregate interfaces where a handler only cares about a subset of events. | EBus is O3DE's most flexible and powerful event messaging system. Any system can connect to it and communicate with any other system by simply providing a system's EBus name. EBus is generally used for situations where event flow is more important than the source of the event. |
| Examples | A spawner-spawnee system. The spawner interface contains functions to manage spawnees. If we want another class to spawn something, that class can make a request via  `AZ::Interface<ISpawner>`. By calling `AZ::Interface<ISpawner>.Get()`, other components can invoke requests from the spawner. | In the networking layer, when a remote process call (RPC) is sent, it signals an `AZ::Event<NetworkEntityRpcMessage&>`. Then, a connected handler listens for that signal change and processes the `NetworkEntityRpcMessage`. | EBus examples are similar to `AZ::Interface` and `AZ::Event`. However, it can provide request and notification interfaces without needing a pointer reference to the component instance. Rather, it simply needs the name of the bus and the entityID of the component that's calling the EBus handler. |